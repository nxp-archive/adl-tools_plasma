         file:///proj/ppctools/svn/plasma/ release 0.8.28 (v0_8_28) on Linux (lb0169) on 11/9/2006 

         file:///proj/ppctools/svn/plasma release 0.8.28 (v0_8_28) on Linux (lb32001) on 11/9/2006 

         file:///proj/ppctools/svn/plasma release 0.8.28 (v0_8_28) on Linux (lb32001) on 11/9/2006 

         file:///proj/ppctools/svn/plasma release 0.8.28 (v0_8_28) on Linux (lb32001) on 11/9/2006 

         file:///proj/ppctools/svn/plasma release 0.8.28 (v0_8_28) on Linux (lb32001) on 11/9/2006 

2006-11-08  Brian Kahne  <bkahne@freescale.com>

	* Plasma has been ported to the AMD64 architecture.  For
	QuickThreads support, I used a setjmp/longjmp piece of code from
	another project which extended QuickThreads.  No other major
	porting problems existed, except for a few minor little issues,
	such as needing to modify some casts in the ecu tests directory
	and to ensure that the assembler used -m32 when assembling the
	output of minicc in tests/cc.

2006-10-30  Brian Kahne  <bkahne@freescale.com>

	* Plasma should now build correctly if configured and built from a
	different directory than where the source is located.

        ======== plasma release 0.8.27 (v0_8_27) on Linux (lb32001) on 10/30/2006 ========

        ======== plasma release 0.8.27 (v0_8_27) on Linux (lb32001) on 10/30/2006 ========

        ======== plasma release 0.8.27 (v0_8_27) on Linux (lb32001) on 10/30/2006 ========

        ======== plasma release 0.8.27 (v0_8_27) on Linux (lb32001) on 10/30/2006 ========

        ======== plasma release 0.8.27 (v0_8_27) on Linux (lb32001) on 10/30/2006 ========

        ======== plasma release 0.8.27 (v0_8_27) on Linux (lb32001) on 10/30/2006 ========

        ======== plasma release 0.8.27 (v0_8_27) on Linux (lb32001) on 10/27/2006 ========

2006-10-27  Brian Kahne  <bkahne@freescale.com>

	* opencxx/Environment.cc (Append):  Removed an explicit delete
	which was causing a free() error b/c the memory was not allocated
	by the system but rather by GC.

2006-08-14  Brian Kahne  <bkahne@freescale.com>

	* opencxx/Environment.cc (DumpAll): Added a dump-everything
	function for debugging purposes.

        ===== plasma release 0.8.26 (v0_8_26) on Linux (cde-tx32-ldt189) on 8/4/2006 =====

        ===== plasma release 0.8.26 (v0_8_26) on Linux (cde-tx32-ldt189) on 8/4/2006 =====

        ===== plasma release 0.8.26 (v0_8_26) on Linux (cde-tx32-ldt189) on 8/4/2006 =====

        ===== plasma release 0.8.26 (v0_8_26) on Linux (cde-tx32-ldt189) on 8/4/2006 =====

        ====== plasma release 0.8.26 (v0_8_26) on Linux (cde-tx32-ldt189) ======

        ====== plasma release 0.8.26 (v0_8_26) on Linux (cde-tx32-ldt189) ======

        ====== plasma release 0.8.26 (v0_8_26) on Linux (cde-tx32-ldt189) ======

        ====== plasma release 0.8.26 (v0_8_26) on Linux (cde-tx32-ldt189) ======

2006-03-21  Brian Kahne  <bkahne@freescale.com>

	* Moved the website to Compass so that everyone can access it.

        ====== plasma release 0.8.26 (v0_8_26) on Linux (cde-tx32-ldt189) ======

        ====== plasma release 0.8.26 (v0_8_26) on Linux (cde-tx32-ldt189) ======

2006-03-17  Brian Kahne  <bkahne@freescale.com>

	* Fixed minor issues in order to port to gcc 4.1.  The problems
	were that the new compiler eliminated a lot of timing loops,
	making some regressions break when compiled with optimization.

        ====== plasma release 0.8.25 (v0_8_25) on Linux (cde-tx32-ldt189) ======

2006-03-17  Brian Kahne  <bkahne@freescale.com>

	* Various minor changes to port Plasma to gcc 4.1.

	* The garbage collector was upgraded to version 6.7.

        ====== plasma release 0.8.24 (v0_8_24) on Linux (cde-tx32-ldt189) ======

        ====== plasma release 0.8.24 (v0_8_24) on Linux (cde-tx32-ldt189) ======

        ====== plasma release 0.8.24 (v0_8_24) on Linux (cde-tx32-ldt189) ======

2006-03-07  Brian Kahne  <bkahne@freescale.com>

	* Fixed bugs in TypeInfo:

	  * Added ability to get encoding string.

	  * Fixed the nth-template-argument accessor function.

	* Fixed nested functions so that they work (I think).  This
	feature is now turned on by default.

2006-02-08  Brian Kahne  <bkahne@freescale.com>

	* Removed trailing whitespace from shbang lines to avoid an
	issue with running them under Cygwin.

        ====== plasma release 0.8.23 (v0_8_23) on Linux (cde-tx32-ldt189) ======

2006-01-05  Brian Kahne  <bkahne@freescale.com>

	* Fixed a bug with parsing long strings: We didn't handle the case
	where we received a null character, indicating that we had a badly
	formed string (had run to the end of the buffer w/o finding the
	terminator).  This meant that we ended up in an infinite loop.
	Fixed this and added tests/parsing/in7.C to verify this.

        ====== plasma release 0.8.22 (v0_8_22) on Linux (cde-tx32-ldt189) ======

        ====== plasma release 0.8.22 (v0_8_22) on Linux (cde-tx32-ldt189) ======

2005-11-09  Brian Kahne  <bkahne@freescale.com>

	* Removed references to Somerset and FIL from documentation.

	* Modified the documentation and configure/Makefile stuff so that
	we print an URL location that's specified using a command-line
	option (--web-url).

        ====== plasma release 0.8.21 (v0_8_21) on Linux (cde-tx32-ldt189) ======

2005-11-02  Brian Kahne  <bkahne@freescale.com>

	* Added copy-right notices to all C++/Plasma files.  Created a
	script called "add-copyright" that tries to do this in an
	intelligent fashion.

        ====== plasma release 0.8.20 (v0_8_20) on Linux (cde-tx32-ldt189) ======


2005-05-26  Brian Kahne  <bkahne@freescale.com>

	* If configure finds that the path to the compiler is a link, it
	tries to follow it.

	* Modified plasma.in so that the contents of an autoconf variable
	CONFOPTS will be added to cpp and gcc options when plasma is run.

	* Modified configure.ac so that if you configure on an IA32
	machine, -m32 is added to CONFOPTS.  The idea is that we want
	32-bit code generated even on an Opteron if Plasma is built on an
	IA32 machine.

        ====== plasma release 0.8.19 (v0_8_19) on Linux (cde-tx32-ldt189) ======

2005-05-18  Brian Kahne  <bkahne@freescale.com>

	* Modified Encoding so that integer template parameters are
	encoded using an 'N' prefix followed by the number as a string.

2005-04-27  Brian Kahne  <bkahne@freescale.com>

	* configure and Makefile.in files are now checked in so that the
	user does not have to run automake/autoconf to build from CVS.

        ====== plasma release 0.8.18 (v0_8_18) on Linux (cde-tx32-ldt189) ======

        ====== plasma release 0.8.18 (v0_8_18) on Linux (cde-tx32-ldt189) ======

        ====== plasma release 0.8.18 (v0_8_18) on Linux (cde-tx32-ldt189) ======

        ====== plasma release 0.8.18 (v0_8_18) on Linux (cde-tx32-ldt189) ======

        ====== plasma release 0.8.18 (v0_8_18) on Linux (cde-tx32-ldt189) ======

2005-04-20  Brian Kahne  <bkahne@freescale.com>

	* Added support for a "let" statement.  It has the form of:

	let (decl [, decl ...]) { body }

	where decl is a variable declaration with or without a type.  If
	no type is present, its type is inferenced using gcc's typeof operator.

        ====== plasma release 0.8.17 (v0_8_17) on Linux (cde-tx32-ldt189) ======

2005-03-16  Brian Kahne  <bkahne@ibmoto.com>

	* Added a Ptree::Reify function to handle booleans and added to
	tests/parsing to test this.

	* Modified the SourceLocation function to recursively find the
	first leaf- this is a better implementation than what I had
	before.

        ====== plasma release 0.8.16 (v0_8_16) on Linux (cde-tx32-ldt189) ======

2005-03-10  Brian Kahne  <bkahne@ibmoto.com>

	* Additional minor changes, such as better source location support
	for error messages:  Given a ptree, if it's not a leaf, we attempt
	to find a leaf item.

2005-03-09  Brian Kahne  <bkahne@ibmoto.com>

	* Enhanced the parser to accept several new things:

	Multi-line quotes are now supported using Python's doc-string
	format:  """ string """.

	Nested code blocks are allowed:

	foo = { ... };

	Bare user-statements are allowed in expressions:

	foo = func(int i) { ... };

	Support for nested functions was added, but is currently commented
	out in Parser.cc.

        ====== plasma release 0.8.15 (v0_8_15) on Linux (cde-tx32-ldt189) ======

2005-02-22  Brian Kahne  <bkahne@ibmoto.com>

	* Upgraded to OpenC++ 2.8 (current CVS snapshot).  I merged in my
	changes and got everything working.  The interface is pretty much
	the same, with a few minor tweeks.  In the future, I think that
	we'll want to move towards using OpenC++ simply as a filter and
	have plasma (the perl program) call the preprocessor and
	compiler.  However, that can wait for now.

        ====== plasma release 0.8.14 (v0_8_14) on Linux (cde-tx32-ldt189) ======

2005-02-15  Brian Kahne  <bkahne@ibmoto.com>

	* Included OpenC++ within the Plasma distribution to make it
	easier to distribute the code.

        ====== plasma release 0.8.13 (v0_8_13) on Linux (cde-tx32-ldt189) ======


2005-01-28  Brian Kahne  <bkahne@ibmoto.com>

	* Added an API to the channels in order to allow for some
	reflection/connectivity deduction.  It works like this:  Each
	channel needs to define the following:

	bool multiple_producers_allowed() const:  Returns true if multiple
		producers are allowed for this channel.

	bool multiple_consumers_allowed() const:  Returns true if multiple
		producers are allowed for this channel.

	void *get_source_channel() const:  Return a pointer to the channel
		that feeds this one.  This pointer should be initialized
		to the 'this' pointer of the channel at first.  Make sure
		that if the void pointer is stored in a base class, that
		the base class occurs first in the list of parent classes.

	void *set_source_channel() const:  Set the source channel.

	The idea with the source channel is that broadcaster objects set
	the source to the source channel- this allows a program to deduce
	connectivity information.  Channels which don't have a source,
	such as timeout and result, don't need a source channel pointer.

        ====== plasma release 0.8.12 (v0_8_12) on Linux (cde-tx32-ldt189) ======

2005-01-27  Brian Kahne  <bkahne@ibmoto.com>

	* Modified the broadcaster classes so that you don't specify how
	many you need- you simply call get_sink() and that appends to the
	list.  I changed the data structure from a vector to a list so
	that you don't have to worry about relocations.

	* Modified the clocked channels so that you can have one with a
	zero clock period.  This becomes equivalent to a non-clocked
	channel.  The reasoning behind this is that you can write a design
	where everything is a clocked channel, then modify its behavior if
	you want to, rather than having to change types.

        ====== plasma release 0.8.11 (v0_8_11) on Linux (cde-tx32-ldt189) ======

2005-01-25  Brian Kahne  <bkahne@ibmoto.com>

	* Fixed a minor issue with alt code generation- we don't create a
	top loop label if we have a default block because we don't loop:
	If no channel is ready, we execute the default block and continue.

2005-01-20  Brian Kahne  <bkahne@ibmoto.com>

	* Fixed bug w/clearing 0-sized clocked channels:  We used to not
	re-queue a waiting writer, so it would stay blocked.  Fixed this
	with a tail clause in clear().

	* Removed the handle from threads.  I still have a valid flag for
	use by busysleep/busywake, but that's it.  Removed HandleType from
	all channels.

	* Re-wrote how alt works:  It no longer uses a handle.  Instead, a
	thread goes asleep and when it wakes, it jumps back to the
	checking logic.  This was done to fix a subtle bug with prialt:
	If two channels become ready at the same time, the priorities
	should be obeyed even if the lower priority thread is what wakes
	the channel.  Using the handle, it wasn't possible to ensure
	this.  The handle is still there, but will be removed next.

	* Added chan25 to test the prialt issue mentioned above.

        ======= plasma release 0.8.9 (v0_8_9) on Linux (cde-tx32-ldt189) =======

2005-01-17  Brian Kahne  <bkahne@ibmoto.com>

	* Changed the clear() functions- they simply do a get() if ready()
	is true.  This was because the other behavior of clear() could
	lead to non-deterministic behavior and runaway conditions.

	* Added a zero-size capability to clocked channels and made this
	the default size.  If the size is 0, a write will block until a
	read removes the data.  This lets you do a fully interlocked
	pipeline.

	* Fixed a bug with priorities- terminate now adds all waiters,
	then queries for the next ready thread.  This fixes a problem
	whereby we used to get the next ready thread before adding the
	waiters which could result in us executing a lower-priority thread
	before others of higher priority.
	
        ======= plasma release 0.8.8 (v0_8_8) on Linux (cde-tx32-ldt189) =======

2005-01-04  Brian Kahne  <bkahne@ibmoto.com>

	* Fixed bug with pLowestPriority(): It was returning 0, rather
	than the 1 less than the total number of priorities (which is the
	lowest priority from the user's point of view).  Modified pri2 to
	test this.

        ======= plasma release 0.8.7 (v0_8_7) on Linux (cde-tx32-ldt189) =======

2004-12-22  Brian Kahne  <bkahne@ibmoto.com>

	* Fixed bug:  We could get a crash if we tried accessing the
	current priority from a global constructor because the current
	processor wasn't set up yet.  I now return the lowest priority in
	such a situation.

2004-12-22  Brian Kahne  <bkahne@ibmoto.com>

	* Created a simple broadcaster template that takes input from a
	channel and writes it to its output channels, clearing them
	first.  Added a convenience class for clocked channels that
	creates a broadcaster with an input clocked channel and an output
	that's non-clocked.  The channels are cleared so that the
	broadcast can be ignored without backing anything up, e.g. if one
	consumer doesn't care, the data is wiped out on the next read.

        ======= plasma release 0.8.6 (v0_8_6) on Linux (cde-tx32-ldt189) =======

2004-12-21  Brian Kahne  <bkahne@ibmoto.com>

	* Added clear methods to the channels.  This will clear out the
	data and any pending writers.

2004-12-14  Brian Kahne  <bkahne@ibmoto.com>

	* Fixed bug with single-consumer clocked channels:  We weren't
	clearing _readt so on a second pass to an alt where we had to
	sleep, we'd assert.

	* Added clock9 to test clocked channels interacting with
	non-clocked channels in an alt.

        ======= plasma release 0.8.5 (v0_8_5) on Linux (cde-tx32-ldt189) =======

        ======= plasma release 0.8.5 (v0_8_5) on Linux (cde-tx32-ldt189) =======

        ======= plasma release 0.8.5 (v0_8_5) on Linux (cde-tx32-ldt189) =======

2004-12-03  Brian Kahne  <bkahne@ibmoto.com>

	* Added support for multiple consumers to clocked channels.  You
	can create a multi-consumer clocked channel by specifying
	MultiConsumerClockChannel as the second template argument to a
	ClockChan type.  Added clock7 and clock8 to test this.

	* Timeout::ready() now returns true after a timeout as issued.
	Get "consumes" this readiness, setting the ready state to false.
	You can now call get() and it will sleep until the timeout issues,
	so you can use a timeout outside of an alt, though it's pretty
	much equivalent to just calling pDelay.

	* Modified the code generated for an alt to handle multi-consumers
	properly.  Once a thread has been awakened, each switch element,
	before the get, calls ready on the channel.  If it's not ready
	(somebody else consumed the data), then we jump back to the
	beginning and start over.

2004-11-30  Brian Kahne  <bkahne@ibmoto.com>

	* spawn now supports void functions:  They're treated as returning
	an int that's always 0.  So, the result object should be of type
	int.  Since that's now the default type for Result, you can just
	omit it and have an empty template declaration:

	Result<> r = spawn(foo());

	You can then wait or kill r if necessary.

	* Refactored the channels to take advantage of common code.  Thus,
	channels which allow for multiple producers inherit from
	MultiProducerChannel.  Channels which have a single piece of data
	inherit from SingleDataChannel.  There is also
	SingleConsumerChannel and MultiConsumerChannel base classes, which
	are now template arguments for Channel, QueueChan, and BusyChan.
	This allows the channel to support multiple consumers, if desired.

        ======= plasma release 0.8.4 (v0_8_4) on Linux (cde-tx32-ldt189) =======

        ======= plasma release 0.8.4 (v0_8_4) on Linux (cde-tx32-ldt189) =======


2004-11-16  Brian Kahne  <bkahne@ibmoto.com>

        ======= plasma release 0.8.4 (v0_8_4) on Linux (cde-tx32-ldt189) =======
	
	* Fixed bug:  Empty statements, i.e. just a semicolon, in a par
	block would cause the parser to crash because it would try to
	extract stuff from an empty object.

        ======= plasma release 0.8.4 (v0_8_4) on Linux (cde-tx32-ldt189) =======

2004-11-12  Brian Kahne  <bkahne@ibmoto.com>

        ======= plasma release 0.8.3 (v0_8_3) on Linux (cde-tx32-ldt189) =======

	* Fixed next_phi() equation b/c clocked channels with a skew could
	have multiple reads at the same time if the second read occurred
	on a cycle boundary.

2004-11-11  Brian Kahne  <bkahne@ibmoto.com>

	* Clocked channels now take three parameters:  Period, skew, and
	size.  Skew defaults to 0.  This lets a user have a channel that's
	delayed with respect to other clocked channels, but with the same
	period, e.g. a half-cycle delay.  Regression "clock5" tests this.

        ======= plasma release 0.8.2 (v0_8_2) on Linux (cde-tx32-ldt189) =======

2004-11-04  Brian Kahne  <bkahne@ibmoto.com>

	* All channels now define value_type as the type of the channel.

        ======= plasma release 0.8.1 (v0_8_1) on Linux (cde-tx32-ldt189) =======

2004-11-02  Brian Kahne  <bkahne@ibmoto.com>

	* Fixed a bug with clocked channels: If you wrote to a clocked
	channel, then delayed by the clock period, you'd get a segfault
	because we would have started a delayed waker, then done our own
	reset (because we're now on a clock boundary) without canceling
	that waker thread.  Fixed this by canceling the thread if it
	exists.  Added "clock4" to test this.

2004-10-13  Brian Kahne  <bkahne@ibmoto.com>

	* Added plasma.m4, a macro that can be used by plasma users to
	detect plasma.

        ======= plasma release 0.8.0 (v0_8_0) on Linux (cde-tx32-ldt189) =======

2004-10-08  Brian Kahne  <tdukes@freescale.com>

	* Port to PowePC:  Minor changes to fix regressions, plus I fixed
	a bug with the parser- I had some STL data structures that didn't
	use a traceable allocator.

2004-10-07  Brian Kahne  <bkahne@ibmoto.com>

	* Added QuickThreads PowerPC port to the qt directory.  This
	doesn't support varargs, but that should be okay, since we never
	use it.  Note:  This has only been tested a little bit, and not
	with these files here- that's the next step!

2004-10-05  Brian Kahne  <bkahne@ibmoto.com>

	* Moved the energy API out of Interface and Proc and into a
	separate class.  This is a thin wrapper around the ProcValue
	class, which is a hash keyed by processors.  The idea is that the
	user can now record any value- energy just being a common
	specialization.

	* Created the Quantity class to handle the case where the user
	wants to model a limited resource that multiple threads/processors
	are trying to get.  This uses a new channel, BusyChan, which is
	like a simple channel, except that it causes the process to go
	busy if a read is attempted and no data is available.

	To implement BusyChan, a new form of busy was added (pBusySleep)
	which keeps a processor busy until it is awoken (pBusyWake).

	The Quantity class works like this:

	1.  The user declares the class and specifies a timeslice.  This
	corresponds to the amount of time it takes to do 1 of that
	quantity, e.g. a bus object might take 10 time units to do a read.

	2.  A thread calls Quantity::request(int amount), where amount
	specifies the number of items it needs.  The class then does a
	round-robin on all requesting threads, taking up a timeslice and
	decrementing the count of a thread.  When a thread's request has
	decremented to zero, the requesting thread's processor is un-busied.
	
        ======= plasma release 0.7.0 (v0_7_0) on Linux (cde-tx32-ldt189) =======

2004-09-23  Brian Kahne  <bkahne@ibmoto.com>

	* Added some support for power modelling.  The basic idea is that
	the user can annotate a model with calls to 

	void pEnergy(energy_t);

	This adds to the current processor's value representing consumed
	energy.  You can then call either:

	energy_t pGetEnergy(Processor);
	energy_t pReadEnergy(Processor);

	The first clears the energy value while the second does not.  To
	obtain power, just create a thread which regularly samples the
	energy of the relevant processors and divides by the sample
	period.
	
2004-09-21  Brian Kahne  <bkahne@ibmoto.com>

	* Got skribe to produce a pdf of the main document (not the source
	code listings).  Modified configure so that it checks to see if
	pdflatex is available and good (a very recent version of the
	hyperref package is required).

        ======= plasma release 0.6.0 (v0_6_0) on Linux (cde-tx32-ldt189) =======


2004-09-20  Brian Kahne  <bkahne@ibmoto.com>

	* Modified configure.ac to specify the version using AC_INIT,
	which is the standard method.

2004-09-20  Brian Kahne  <bkahne@ibmoto.com>

	* Added prialt and priafor constructs.  These are guaranteed to
	read the ports in the order specified by the user, whereas the
	ordering is indeterminate for alt/afor.

	* Changed the handling of alt blocks so that the channels are read
	in reverse order, just to distinguish between alt and prialt.  The
	afor is handled the same as priafor, but the idea is that a more
	sophisticated compiler, which recognized that an afor is a
	constant loop, might unroll the loop and do some reordering.

2004-09-17  Brian Kahne  <bkahne@ibmoto.com>

	* Fixed some scheduling bugs related to pooled processors:

	1.  We used to throw out empty processors in
	Cluster::update_proc().  However, this had the effect of getting
	rid of pooled processors- they would never then be used.  Changed
	this so that we no longer have a loop in update_proc.  Instead,
	get_new_proc() calls ProcQ::get_non_empty() which scans the queue
	for a proc w/threads.  If it doesn't find any then it advances
	time.  I like to avoid loops, but this should almost never advance
	beyond the first iteration- it'll only occur w/pooled processors
	and only when few threads are present.

	2.  Modified Cluster::busy() so that it removes the scheduling
	thread, then finds the next processor (or updates time), then adds
	in the scheduler.  This fixed the problem of switching to a
	processor whose only thread is the scheduler.  When that happens,
	update_proc gets called, which then finds that the processor is
	empty and sets it to wait.  This way, if busy doesn't find
	anything, it'll advance time.

	I moved qsort to qsort1 and added qsort2 to test these changes.

2004-09-15  Brian Kahne  <bkahne@ibmoto.com>

	* Moved thecluster and thesystem out of the plasma namespace to
	faciliate better debugging: GDB couldn't see them, for some
	reason.

	* Removed SIGBUS and SIGSEGV catching from Init.C since the GC
	uses those for itself.

	* Fixed gc bugs:  We now push on roots defined by
	Thread::stackbegin() and Thread::stackend().  For the main thread,
	stackbegin() comes from GC_stackbottom.  This means that the main
	thread is now scanned.

	* Since I fixed the above problem, I now derive QVect from gc so
	that it can be gc'd.  Previously, I couldn't do it b/c the main
	processor's ready queue was being collected due to the main thread
	not being scanned.

        ======= plasma release 0.5.0 (v0_5_0) on Linux (cde-tx32-ldt189) =======


2004-09-14  Brian Kahne  <bkahne@ibmoto.com>

	* Added support for shared issue queues.  This works as follows:
	The user can create a new Processor with a shared queue by calling
	either:

	make_sharedproc(Processor);

	or by creating a Processors data structure with a third argument
	of true:

	Processors procs(10,"procs",true);

	Shared processors all feed from the same queue, so if one is busy,
	others are able to work on the available threads.  This allows one
	to model SMP-type systems.

	Internal changes were:

	1.  The thread queue is now dynamically allocated.  If it's
	shared, we just do a pointer copy from the source.

	2.  The busy thread is queried for end-times and when we clear the
	busy thread, it gets added back to the queue.  If we preempt a
	busy process, it also gets added back to the ready queue.  This is
	in contrast to how we used to do it, where the busy thread was
	added back to the ready queue and we would find it by looking at
	the next ready-to-run thread.

	3.  An extra loop was added to update_proc():  This guards against
	finding a processor in the queue that now has no ready threads b/c
	another processor with the same queue executed them.  In this way,
	we discard processors that are empty, assuming that they're busied
	by a thread, or have nothing to do.

	4.  Various context-swapping functions (busy, exec_block,
	exec_ready) update the Proc pointer of the Thread, since a thread
	can now migrate between processors.

2004-09-14  Brian Kahne  <bkahne@ibmoto.com>

	* Removed Makefile.in files from gc b/c they were affecting our
	build order.  Switched over to autoreconf so that we would run
	automake in all directories (it would skip gc if we just ran it
	from the top-level directory b/c automake doesn't recurse into
	child autoconf prejects).

        ======= plasma release 0.4.0 (v0_4_0) on Linux (cde-tx32-ldt189) =======

2004-09-08  Brian Kahne  <bkahne@ibmoto.com>

	* Converted all documentation to Skribe.  Added lots of stuff,
	such as future work, description of examples, etc.

2004-08-30  Brian Kahne  <bkahne@ibmoto.com>

	* Found bug w/busy:  I added the thread after I pushed the proc
	onto the priority queue, so the priority queue wasn't correctly
	sorting things.  Added proc6 to test this.

	* Changed Proc::endtime() to just query the busythread, which is
	much simpler than the old technique of searching the ready queue.

2004-08-27  Brian Kahne  <bkahne@ibmoto.com>

	* minicc: Moved the parallelism of the compiler out of Compiler.pa
	and into CodeGen so that I could use the double-dispatch
	mechanism, rather than having to use dynamic_cast.  This means
	that the only dynamic_cast stuff is conained within Node.C.  Just
	about everything else has been implemented as virtual function
	calls w/double-dispatch.

	* minicc:  Moved the spawn/result-vector code into a series of
	templates in Interface.h.

	* minicc:  Changed the architecture somewhat:  All code generation
	data now resides within CodeGen:  Shared data is in an object
	called SharedData and per-thread data is in ThreadData.  A new
	CodeGen object is spawned for each function encountered.

2004-08-26  Brian Kahne  <bkahne@ibmoto.com>

	* minicc: Finished code generation.  Added regressions, including
	one which runs a program compiled by minicc.  This is enabled only
	if we are building on an x86 machine.

2004-08-20  Brian Kahne  <bkahne@ibmoto.com>

	* minicc: Modified main parser/compiler routine so that we spawn
	off a compile job after each file is done.  We then synchronize at
	the end.

	* minicc: Added type-checking and flow-control analysis passes.
	These are done in parallel across all top-level items in a
	translation unit.

2004-08-19  Brian Kahne  <bkahne@ibmoto.com>

	* minicc: Fixed bug: I wasn't calling setinfo on all of the Node
	objects that I should have, in cparser.yy.

	* minicc: Added symbol-table generation.  I decided to remove the
	double-dispatch stuff, because it really doesn't work that well
	(refer to "More Effective C++" for why the double-virtual function
	call is not an idea solution).  Instead, I'm just using
	single-dispatch with virtual functions in the Node class.

2004-08-18  Brian Kahne  <bkahne@ibmoto.com>

	* minicc: AST generation seems to be working; added regressions to
	test this.

2004-08-11  Brian Kahne  <bkahne@ibmoto.com>

	* minicc:  Initial AST code done.

2004-08-10  Brian Kahne  <bkahne@ibmoto.com>

	* Modified lemon so that its suffix is .cc
	
	* minicc: Integrated in C grammar from mini-C.  I'm able to parse
	the example C program provided by that program.

2004-08-09  Brian Kahne  <bkahne@ibmoto.com>

	* Added the lemon parser generator.  The source can be obtained
	from here:  

		http://www.hwaci.com/sw/lemon/

	A tutorial can be obtained from here:

		http://sourceforge.net/project/showfiles.php?group_id=79320&package_id=124528

	* minicc:  Added a parsing class, which wraps a lemon parser.
	Proof-of-concept lemon parser created which just parses simple
	mathematical expressions.  It runs in its own thread and gets
	tokens from the tokenizer thread.

	* minicc: Implemented the tokenizer stage for the compiler.
	
	* minicc: Started on an example multithreaded C compiler.  The
	basic architecture will be:

	1.  Tokenizer implemented using flex.  This passes tokens via a
	channel to the parser.

	2.  Parser implemented with lemon.  This creates an AST and a
	symbol-table.  When a function has been completed, a
	code-generator thread will be dispatched.

	3.  Code generator implemented by copying mini-C (a sample Python
	C compiler):  http://people.cs.uchicago.edu/~varmaa/mini_c/

	4.  The top-level tree will be traversed and code will be written
	out.  This will be the synchronization point, where we'll wait for
	threads to finish.

2004-08-05  Brian Kahne  <bkahne@ibmoto.com>

	* Fixed ecu- problem was with cylinders() having a lower priority
	than baseload(), so that it never got a chance to start up the
	cylinder managers.  Added regression to test operation.

2004-08-05  Brian Kahne  <bkahne@ibmoto.com>

	* Fixed a bug with priorities:  The wake function would always
	wake up a thread, even if its processor was busy.  The new
	behavior is:  If a thread is awakened whose priority is higher
	than the busy thread, the busy thread will re-compute, just as
	delay was handled.  If the awakened thread is lower priority, it
	will be added to the ready queue but the processor will stay busy.

	Added pri7 and pri8 to test this.

	* Checked in ecu code.  Still need to do some debugging.

        ======= plasma release 0.3.0 (v0_3_0) on Linux (cde-tx32-ldt189) =======

2004-07-29  Brian Kahne  <bkahne@ibmoto.com>

	* Fixed line directive line-numbering- each line directive should
	count as 2 lines so that the line directives for the .ii file are
	correct.

	* Added pipe.pa, a simple RISC processor model.

2004-07-22  Brian Kahne  <bkahne@ibmoto.com>

	* Imported libgc6.3.

        ======= plasma release 0.2.0 (v0_2_0) on Linux (cde-tx32-lc210) =======

        ======= plasma release 0.2.0 (v0_2_0) on Linux (cde-tx32-lc210) =======

2004-07-22  Brian Kahne  <bkahne@ibmoto.com>

	* The plasma wrapper script now hardcodes in the compiler so that
	you don't need to have a compiler policy.

        ======= plasma release 0.1.0 (v0_1_0) on Linux (cde-tx32-lc210) =======

        ======= plasma release 0.1.0 (v0_1_0) on Linux (cde-tx32-lc210) =======

2004-07-19  Brian Kahne  <bkahne@ibmoto.com>

	* Added line directives to the original methods for pMutex
	classes.  This should allow the user to place breakpoints within
	these methods and have gdb work correctly.

	* Further fixes to the plasma wrapper:  Added the ability to just
	link with it, using the required libraries.  This happens if we
	don't find a .pa file or there isn't a --plasma or --p option.

	* Added a --devel option, which takes the top src directory as
	a parameter.  This switches over to the devel mode, where include
	and library paths are set for an uninstalled development sandbox,
	rather than for an installation.  This means that the prefix is
	not used.  Modified the regression suite to use the wrapper script.

	* Found a bug:  I couldn't use the "waiter" queue, as previously
	implemented, b/c when we have an alt block and are using ResChans,
	it means that we might have a situation where a single thread (the
	alt-block containing thread) might be waiting on multiple items to
	finish (all of the ResChan objects).  This doesn't work b/c the
	Queue class only allows an object to be in a single list at any
	given time- otherwise bad things can happen.  Fixed this by
	changing the _waiters member to a gc'd vector class.

2004-07-15  Brian Kahne  <bkahne@ibmoto.com>

	* Plasma should now be useable by others when installed.  I
	created "plasma", which is a wrapper program that invokes the main
	executable (plasma-comp).  This massages parameters into the
	proper order.  I also created plasma-config for printing link
	lines, etc.

	* Converted over to using libtool.  The main parser/compiler is
	now statically linked.  Installation seems to work.  I also fixed
	up the root makefile so that remaking after a change to
	configure.ac will work properly.

2004-07-14  Brian Kahne  <bkahne@ibmoto.com>

	* Added line directives to plasma output so that debugging and
	error messages work better.  To add a line directive, I created a
	new object derived from Leaf which inserts a newline before it
	prints itself, to ensure that a line directive is valid (these
	directives must occur at the beginning of a line).  The result is
	that you can put a breakpoint in the middle of a par block and
	compilation error messages refer to the .pa file, rather than the
	.ii file.

2004-07-13  Brian Kahne  <bkahne@ibmoto.com>

	* Fixed bug w/alt parsing:  We didn't handle par blocks nested
	w/in alt.  Fixed this by calling TranslateExpression on p.body and
	adding the port variable to the environment so that the VarWalker
	would find it.  The test clock3 tests this.

	* Fixed bug in clocked channels- if a data value was already
	present, but not at the current time, we needed set_notify to
	create a waker.  The test clock3 tests this.

	* Added clock.pa to tests/sw to demonstrate a simple cpu/alu
	pipeline.

2004-07-12  Brian Kahne  <bkahne@ibmoto.com>

	* Added a clocked channel, ClockChan.  This is similar to
	QueueChan, except that the constructor's first argument is a clock
	period.  The second argument is the size of the queue (default is
	1).  This behaves like a normal channel, except that reads must
	occur on clock-cycle boundaries, i.e. (pTime() % period) == 0.
	Thus, a writer doesn't immediately wake up a reader- it dispatches
	a thread that delays for the requisite amount of time, then wakes
	up the reader.  Added clock1 and clock2 to test this.

2004-07-09  Brian Kahne  <bkahne@ibmoto.com>

	* Fixed the distributions.  The one change is that exponential now
	takes a scale parameter, giving you data in [0,scale], with lambda
	describing the fall-off rate.

	* We now support uniform, triangular, exponential, and normal
	distributions.  The latter two, however, appear to be somewhat
	broken- we'll fix it later.

	* Added the Random template class for random number generation.
	The template takes a generator as a parameter and lets the user
	have n number of independent generation streams.  The currently
	supported generators are:  

	1.  LCG:  2^31 period, reversible, 1 state word.

	2.  KISS:  2^127 period, not reversible, 5 state words.

	3.  Mersenne Twist:  2^19337 period, reversible, 625 state words.

	The Random class lets the user generate numbers, load/save state
	to a stream, and generate numbers in reverse (if supported).  To
	do:  Add various distributions.

	* Removed the Random class from the regress directories and
	modified necessary tests to use the new Random class.

2004-07-07  Brian Kahne  <bkahne@ibmoto.com>

	* Added the ability to name Processor objects.  The memory is
	unmanaged, so you can just allocate from the GC and you can
	compare pointers for fast identification.

	* The QueueChan class is now templated on its container type.  The
	default is to use a list.

	* Modified all STL containers to use traceable_allocator.

2004-07-06  Brian Kahne  <bkahne@ibmoto.com>

	* Fixed bug w/busy-okay:  If we turned off preemption due to
	setting ConfigParms::_busyokay, it could be turned on again by
	GC_startworld.  Fixed this by adding a static member to Cluster
	that is set when we process the config parms to indicate that
	preemption should stay off..

2004-07-02  Brian Kahne  <bkahne@ibmoto.com>

	* Modified the basic Channel template to support multiple
	producers.  Added chan17 to test this.  This simply meant
	converting over to having a vector of waiting writers, just like
	the queued channel class.

	* Changed how we go about setting a priority.  We used to always
	yield, but this was wrong b/c if we change to a higher priority,
	that thread should execute, since the highest priority thread
	should always run before anything else.  Modified
	Cluster::set_priority so that if the new priority is higher, we
	simply record it and return, i.e. we don't swap.  If it's equal or
	lower, then we record it and yield.

	* Fixed bug with busy and higher-priority delayed threads.  I
	wasn't correctly calculating elapsed time and I wasn't correctly
	tracking what the busy thread was.  Added a busy-thread pointer to
	Proc to track who is currently the busy-ing thread.

2004-07-01  Brian Kahne  <bkahne@ibmoto.com>

	* EAV regression added.

	* Fixed bug with busy:  It was possible to get the same processor
	back, where the first item to execute is the same thread that
	we're currently in.  This can happen when there's a processor with
	just a single thread that goes busy.  Put in a check that if the
	new processor's next thread is our current thread, skip the call
	to exec_block.

	* Fixed problem with channels, when the user doesn't need the
	channel value.  We weren't calling get, so we never cleared out
	the channel value.

2004-06-28  Brian Kahne  <bkahne@ibmoto.com>

	* Fixed implicit method calls within par blocks.  This means that
	functions have to be looked up and then we have to see if we're in
	a class.  The complication is that we need to get a Class object,
	but the user-plain metaclass (Plasma) interfered with this.  Added
	a static pointer to VarWalker that Plasma::InitializeInstance
	sets.  This should be okay b/c there should only be one instance
	of this class.

	Once we get the Class object, we see if the variable is a method
	of the class.  If it is, we store the 'this' pointer and translate
	the code to an explicit method call using that pointer.

	* Fixed explicit method calls within par blocks, e.g. we can now
	handle "this->xx()".  The problem was that "this" is handled in a
	special manner, via Walker::TranslateThis.  We then also had to
	add appropriate forward defines b/c C++ is so lame.

2004-06-25  Brian Kahne  <bkahne@ibmoto.com>

	* Fixed nested par blocks w/on statements.  I also made the
	Processors array be a vector w/the traceable_allocator so that
	Proc objects wouldn't be collected.

	* Fixed some bugs so that alt/afor and pfor could be nested within
	par blocks.  The alt fix was simply that I needed to have the
	VarWalker handle user statements, e.g. port statements.

	* Fixed problems w/nested par blocks.  Two problems were found:
	The VarWalker class needed to overload TranslateUserPlain so that
	par and alt blocks weren't opaque.  Second, the code that we were
	producing was created as a simple string, so that a nested par
	block, when we scanned it for variables, didn't have any
	translated b/c they weren't stored as variables.  This was fixed
	by creating a new Ptree derived object with a proper Translate
	method.  Added par5 to test this.

2004-06-23  Brian Kahne  <bkahne@ibmoto.com>

	* Fixed problems w/having plasma statements in inlined-methods.

2004-06-22  Brian Kahne  <bkahne@ibmoto.com>

	* Fixed bugs:

	1. We weren't migrating the scheduling thread from a busy
	processor to the new processor chosen.  Fixed this by adding to
	QBase a prev pointer and adding a remove function to Queue that
	lets a thread be removed in O(1) time.  This allows Cluster::busy
	to remove the scheduling thread from where it was and add it to
	the new processor.

	2. Fixed bug w/pfor:  We weren't supporting on blocks.

	3. Added a Processors class, which is just a vector of Processor
	objects.  However, the constructor lets you create N unique
	processors.  Just creating a vector and giving it Processor() as
	an argument means that you'd end up with an array all pointing to
	the same Proc.

2004-06-18  Brian Kahne  <bkahne@ibmoto.com>

	* Added mutex I/O routines which mirror the printf suite.  Still
	don't have a good solution for cout- probably just need to wrap it
	in a macro with pLock()/pUnlock() calls.

	* Added the Timeout class.  This is a channel that will deliver a
	value in an alt block after a specified amount of time (using
	pDelay).  Example:

		Timeout t(20);
		alt {
		  t.port() { cout << "Got a timeout!" << endl; }
		}

	The constructor requires a timeout value; this may be changed or
	read via methods.  No useful value is returned via the port, so
	you normally wouldn't map the return to a value.

	* Fixed a bug in Cluster::update_time():  If we updated the time
	and added a delay thread, it was possible that the thread had been
	terminated, so it wouldn't be added.  So we'd end up adding an
	empty processor to the processor queue, which would cause us to
	exit.  Fixed this by checking that at the end, _curproc has
	something to run.  If not, we mark the processor as waiting and
	try again.

	* Added the ability to start a thread with an explicit priority.
	This is done as follows:

	1.  Optional second argument to the on block:

		par {
		  on (pCurProc(),0) { /* thread 1 */ }
		  on (pCurProc(),1) { /* thread 2 */ }
      		  { /* thread 3 */ }
      		  { /* thread 4 */ }
    		}

	You have to supply two arguments to "on", so you need to use
	pCurProc() if you want to launch a thread on the same processor
	with a specific priority.

	2.  Optional second argument to spawn:  

		spawn(foo(),0);

	A priority of -1 may be used to specify the current thread's priority.

2004-06-17  Brian Kahne  <bkahne@ibmoto.com>

	* Integrated the Boehm-Demers-Weiser (BDW) garbage collector into
	Plasma.  This is now used by the thread library and available to
	the user.  To use it, derive an object from gc or allocate using
	the placement value (GC).

	For example:  new (GC) int[1000];

	or 

	class A : public gc { };

	You can freely mix managed and unmanaged memory.  To have a
	destructor called, derive from "gc_cleanup".  In general, do not
	delete managed memory- you can do it, but why bother when the
	garbage collector will collect it.

2004-06-11  Brian Kahne  <bkahne@ibmoto.com>

	* Added timeslicing of lowest-priority threads when busy is
	allowed.  This was accomplished by:

	1.  The threads now store relative time and start time. 

	2.  The busy() function loops until all required busy time is
	consumed.  This allows us to handle busy threads that are
	interrupted and timeslicing.

	3.  Time-sliced busy threads are added to the busy queue with a
	busy time of ConfigParms::_simtimeslice.  The busy function then
	loops until the entire time value is consumed.

2004-06-04  Brian Kahne  <bkahne@ibmoto.com>

	* Added time model:

	pDelay():  Puts current thread on the delay queue.  When time
	advances up to this point, process is removed and added back to
	processor.  Processor is added back to ready queue.  If processor
	is busy, then it's only added back to ready queue if priority of
	delayed process is higher than the process which made the
	processor busy.  In that case, the processor is added back, but
	removed as soon as higher priority process is finished.

	pBusy():  Puts current process and processor on the busy queue.
	When time advances up to this point, processor is put back into
	the ready processor queue.

	Time advances whenever there is no more work to be done for the
	current time step, i.e. no more processors are on the processor
	ready queue.  In that case, we advance to the next time step,
	which is the smaller of the tops of the delay and the busy queue.
	These queues are implemented as STL priority queues, so whenever
	we push on a value, the smallest item percolates to the top.

	pTime():  Returns current time of the system.

	If we set ConfigParms::_busyokay to false (default), then we
	cannot use pBusy; it will cause the system to abort.  This also
	means that preemptive thread switching is enabled.  If we set this
	value to true, we can use pBusy, but preemption is turned off- the
	only way that a thread swaps out is by a call to pBusy(),
	pDelay(), or a blocking operation (pWait(), alt, etc.).
	
	Note:  Time slicing not yet implemented.

2004-06-02  Brian Kahne  <bkahne@ibmoto.com>

	* Updated the scheduler to work in the way described by Pete
	Wilson: 

	A procesor works until all of its threads are finished,
	then a new processor is selected.  If none are available, we
	exit.  The scheduling thread hops to whatever the current
	processor is, so we know that there's always a thread to yield to.

	This means that we do *not* timeslice between processors, only
	between threads in the current processor.  As before, we respect
	priorities.

	To implement this, each Proc class has a state variable.  When we
	add a processor (Cluster::add_proc) we set its state to Running
	and add it to the Cluster's processor ready queue.  The scheduler
	calls update_proc before it gets the next thread to run- this
	checks to see if the current processor has any threads.  If not,
	we set its state to Waiting and we get another processor, exiting
	if no more exist.

	Each Thread now has a pointer to its parent processor, which we
	use to ensure that when a thread is awoken, its processor is on
	the run queue.  We can always call Cluster::add_proc b/c if the
	processor is already running, it's not added again.

	The scheduler thread, since it hops between processors, has its
	parent thread updated to the current processor by the scheduler,
	so that when we yield to it, it always takes us to the current
	processor.
	
2004-06-01  Brian Kahne  <bkahne@ibmoto.com>

	* Added the "on" block, which allows users to specify a target
	processor on which to run a statement within a par block:

	par {
	  on(p1) {
	    ....
	  }
	  on(p2) {
	    ...
	  }
	  {
	    ...
	  }
	}

	In the above, the first block runs on Processor p1, the second on
	Procesor p2, and the third on the current processor.

	Added a spawn pseudo-method to the Processor class::

		p1.spawn(foo(1,2));

	This spawns a new process on the specified processor.

2004-05-27  Brian Kahne  <bkahne@ibmoto.com>

	* Created the Processor class, which just wraps a Proc object.
	The user can instantiate Processor objects and supply the
	underlying Proc ptr to pSpawn.

	* The current scheduler architecture is as follows:

	- The Cluster object has a queue of Proc objects.  Each time the
	scheduler thread is run, it chooses another Proc with threads to
	run.  If none are available, we exit.

	- We add the current Proc to the Proc queue before we query
	again.  Thus, we do not discard empty Procs from the Proc queue-
	we simply cycle through the list.  This means that we don't need
	to store the Proc with a Thread when the Thread is waitinng on
	another Thread.

	- We get the thread to execute from the Proc object (respecting
	priorities) and swap to it.  This has the effect of passing the
	main scheduling thread amongst the processors, but it means that
	we timeslice between processors.

	* Pretty big re-org of the backend:  I renamed Processor to
	Cluster and created a new Proc class which stores the
	priority-ordered ready queues.  The Cluster object contains the
	scheduler and the queue of processors.  The scheduler picks a
	processor and then runs the next available thread from it.  The
	idea is that the Proc class will be exposed to users, whereas
	the Cluster will be kept hidden and will eventually map to each
	kernel thread (if we ever implement that).

	* The ThreadQ class was made into a generic Queue class which uses
	QBase as a container element.  Thread and Proc now derives
	from it and ThreadQ and ProcQ privately inherit from Queue, adding
	wrappers which do the appropriate pointer casting.

2004-05-26  Brian Kahne  <bkahne@ibmoto.com>

	* Added priorities to Plasma.  You can change the current thread's
	priority by calling pSetPriority() and you can get the current
	priority by calling pGetPriority().  Priorities are numbers 0 to
	n-1, where n is set in pSetup and defaults to 32.  0 is the
	highest priority, but internally 0 is the lowest, so that we can
	easily tell whether we should timeslice or not.  The idea is that
	we only timeslice on the lowest priority- all other threads run to
	completion.

2004-05-25  Brian Kahne  <bkahne@ibmoto.com>

	* Changed port statement syntax to be more clear.  Now, the format
	is:

	  <expr>.port(<decl>) { ... }

	or

	  <expr>->port(<decl>) { ... }
	
	* Added support for varargs handling with mutex classes.  The
	support isn't perfect, though:  You can't write a true variadic
	function, e.g. foo(const char *fmt,..), because you can't pass the
	variable argument list.  Instead, you must write a va_list
	function directly, e.g. foo(const char *fmt,va_list ap).  Plasma
	will then create a variadic version and a v_list version for you
	that are wrapped with locking code.

	* Re-did alt/afor blocks.  You can now nest alt and afor blocks
	and we'll block on all of these items.  You can put and alt or an
	aforr inside of another alt, but only a single port statement may
	go inside of an afor, e.g.

	alt {
	  port () {
	  }
	  afor () {
	    port() {
	    }
	  }
	  alt {
	  }
	}

	We will treat this as one big alt block, allowing you to wait on
	multiple data structures and combine data structures with single
	elements.  This meant that I had to change the handle type used by
	pSleep and pWake from an integer to HandleType which is currently
	a pair of integers:  The first element designates the port block
	(case statement item) and the second element refers to the loop
	index (if an afor- ignored if an alt).

	I refactored the code so that generateAltBlock() generates all
	code, given a PortVect object.  This object is populated by a call
	to parseAltBody() or parseAforBody().  They call parseAltBlock(),
	which may recursively call the two parse-body functions.  Then,
	generateAltBlock() writes the setup code and calls
	generateAltBody(), which writes the case statement.

	Added chan10 to test the above.

2004-05-20  Brian Kahne  <bkahne@ibmoto.com>

	* Added exception safety to locking mechanism.

	* Added support for shared data structures.  To make a class
	shared, simply add a modifier of pMutex to the front of its
	declaration.  This will protect all public functions (except
	constructors and the destructor) with locking code.  Note that
	varargs functions are not supported because I don't know how to
	pass on the variable arguments to another function.

	To prevent a public function from being protected, add a modifier
	of pNoMutex to the front.

	Example:

		pMutex class Foo {
		public:
		  // Not protected.
		  Foo();
		  ~Foo();
		  // Protected.
		  int a();
		  // Not protected.
		  pNoMutex int b();
		private:
		  // Not protected.
		  int c();
		};

2004-05-19  Brian Kahne  <bkahne@ibmoto.com>

	* Added QueueChan, a queued channel classs.  This allows multiple
	producers to write to a single consumer.  You can set the maximum
	size of the queue, or just let it float.

2004-05-18  Brian Kahne  <bkahne@ibmoto.com>

	* A Result<T> object can now interface with an alt block by using
	ResChan<T>, which may be constructed directly from Result<T>.

	* I changed the architecture of how handles are returned.  A
	handle now lives in a thread, rather than as a single instance in
	a Processor.  When a thread terminates, it will now wake each
	waiter and set its handle to the terminating thread's handle.
	pSleep() then returns the current handle and it may be queried by
	calling pHandle().

	It may be necessary to expand this in the future to where the
	waiter queue stores a handle and a thread.  Right now, the
	limitation is that at most one alt block can wait on a channel.
	This is inline with how other channels work and doesn't apply to
	using Result directly, but we may want to expand it in the future.

	* Added support to spawn for handling function pointers and method
	pointers.  Spawn now supports the following ways to call a
	subroutine:

	1. Literal function call:       spawn(foo());
	2. Function pointer call:       p = foo; spawn(p());
	3. Method call w/reference:     spawn(a.b());
	4. Method call w/pointer:       spawn(a->b());
	5. Static method call:          spawn(A::b());
	6. Method pointer w/reference:  p = &A::b; spawn(a.*p());
	7. Method pointer w/pointer:    p = &A::b; spawn(a->*p());

2004-05-17  Brian Kahne  <bkahne@ibmoto.com>

	* Added support to spawn for handling member calls.

	* Initial implementation of spawn operator.  It currently only
	processes function calls.

	* Created Result template for storing data from a spawn operation.

2004-05-14  Brian Kahne  <bkahne@ibmoto.com>

	* Added pDone(const THandle), which returns true if the specified
	thread is finished.  

	* Added initial code to parser to parse spawn command.

	* Added C++-only spawn test to test spawn implementation concept.

2004-05-12  Brian Kahne  <bkahne@ibmoto.com>

	* Broke plasma.mc into multiple files.

	* Finished alt work- added exception cleanup code.

	* Modified looping alt so that if the loop index variable
	is not a simple built-in type (integer compatible), we'll create
	an auxiliary vector and store index values there.  The handle we
	store in each channel is the index of the corresponding entry in
	the vector.

2004-05-11  Brian Kahne  <bkahne@ibmoto.com>

	* Changed alt/port block to a new synax.  Now, it's:

	alt {
	  port([<value decl>];<channel>;) { <action> }
	  ...
	  [ { <default action> } ]
	}

	In other words, it's a for-loop style syntax for the port block
	and a full declaration is required; the type-inferencing wasn't
	working very well, so I just made it explicit.

	* Added plasma.h for Plasma interface stuff that we want users to
	have to explicitly include, e.g. channel classes, etc.

	* Moved all plasma interface stuff into the plasma namespace.

2004-05-10  Brian Kahne  <bkahne@ibmoto.com>

	* Initial version of alt added.  The syntax is:

	alt {
	  port(<channel>[,<variable]) { <action> }
	  ...
	  [ { <default action> } ]
	}

	We check each channel listed in a port directive.  If one is found
	ready, its action is executed.  If a variable is present in the
	port statement, the value read from the channel is mapped to the
	variable, which is in scope for the action code.  If the default
	action block is present, then if no channels are ready, it is
	executed.  Otherwise, if no channels are ready, the alt-block
	sleeps until a channel is ready.  The action associated with the
	ready channel is then executed.

2004-05-07  Brian Kahne  <bkahne@ibmoto.com>

	* Expanded plasma-interface.h with functions needed to channels.
	Added chan1 regression to test a primitive channel written
	directly in C++.

2004-05-06  Brian Kahne  <bkahne@ibmoto.com>

	* Started a user guide (doc/user-guide.rst) and a schedule
	(doc/schedule.rst).  The idea is that the schedule will be updated
	in advance and the user guide will be updated before a feature is
	committed.

2004-04-29  Brian Kahne  <bkahne@ibmoto.com>

	* Modified the implementation of pfor:  Instead of allocating
	space for the argument structure on the heap, I added a new
	version of pSpawn which allocates space on the stack structure,
	then copies data to this space.

	* Added support for the "pfor" construct.  Originally, this was to
	be called "par" too, but OpenC++ does not allow the same keyword
	to be used for multiple constructs.

	The usage is:

		pfor (<for-style condition>) {
		  <body>
		}

	<body> is launched as a thread for each iteration of the loop.
	Execution waits at the end of the loop until all threads
	complete.  A pfor loop currently requires that there be at least
	one declaration in the condition of the loop, e.g.

		pfor (int i = 0; i != 10; ++i) { ... }

	The reason for this is that anything declared in the loop
	condition is passed by value to the thread, while everything else
	is passed by reference in order to allow for side effects.
	Without the pass-by-value, the loop would complete (most likely)
	before any thread got scheduled, so every thread would see the
	same final value for the loop variable, rather than the value with
	which the thread was launched.  This seemed the best way to get
	around that undesirable behavior.

2004-04-27  Brian Kahne  <bkahne@ibmoto.com>

	* Added a parallel quicksort to the regression.

	* Fixed parser bug:  You can't make a pointer to a reference, so
	if we use a reference within a par block, we don't take a pointer
	to it- we just keep treating it as a reference.

	* Fixed problem with pAbort() and pExit():  They now immediately
	switch to the scheduler, which sees that a shutdown is requested
	and thus exits.

	* Plasma project should now build and pass its regression.

2004-04-23  Brian Kahne  <bkahne@ibmoto.com>

	*  Start of the plasma project.
