//
// This class takes ASTs and performs all of the compilation passes.
//

#include <iostream>
#include <stdexcept>

#include "Compiler.h"
#include "SymTab.h"
#include "Node.h"

using namespace std;
using namespace plasma;

Compiler::Compiler( Nodes &asts) :
  _asts(asts)
{
}

// Each thread returns a boolean- false means that an error
// was encountered.
typedef Result<bool> CompRes;
typedef vector<CompRes,traceable_allocator<CompRes> > Results;

// Spawn off each translation-unit compilation phase as a separate thread.
void Compiler::compileUnits(bool sym_only,bool check_only)
{
  pfor (Nodes::iterator i = _asts.begin(); i != _asts.end(); ++i) {
    compileUnit(*i,sym_only,check_only);
  }
}

// For each translation unit, compile it.
void Compiler::compileUnit(Node *tu,bool sym_only,bool check_only)
{
  // First, we generate the symbol table.  This has to be done serially b/c of
  // the sequential nature of C, i.e. symbols are visible in the order in which
  // they appear in the file.
  try {
    tu->gensymtab();
  }
  catch (exception &err) {
    cerr << err.what() << endl;
    _error = true;
  }
  if (sym_only) {
    return;
  }
  // Now we spawn off threads to do the rest of the work.
  TranslationUnit &turef = ncastr<TranslationUnit>(tu);
  Results results;
  for (NodeList::iterator i = turef.begin(); i != turef.end(); ++i) {
    results.push_back(spawn(compile( *i, check_only )));
  }
  // If any of the results are false, we've got an error.
  for (Results::iterator i = results.begin(); i != results.end(); ++i) {
    if ( !i->value() ) {
      _error = true;
    }
  }
}

bool Compiler::compile(Node *n,bool check_only)
{
  try {
    // Perform type checking.
    n->typecheck();
    // Perform basic flow-control analysis.
    n->flowcontrol();
    if (!check_only) {
      // Perform rest of compilation phase.
    }
  }
  catch (exception &err) {
    cerr << err.what() << endl;
    return false;
  }
  return true;
}

void Compiler::print_ast_list(ostream &o,bool ps)
{
  if (ps) {
    o << printsyms;
  }
  for (Nodes::const_iterator i = _asts.begin(); i != _asts.end(); ++i) {
    o << "\nTranslation Unit\n"
      << "================\n"
      << (*i)
      << endl;
  }
}
