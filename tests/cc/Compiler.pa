//
// This class takes ASTs and performs all of the compilation passes.
//

#include <iostream>
#include <stdexcept>

#include "Compiler.h"
#include "SymTab.h"
#include "Node.h"

using namespace std;
using namespace plasma;

Compiler::Compiler( )
{
}

// Compile a translation unit.
bool Compiler::compileUnit(Node *tu,bool sym_only,bool check_only)
{
  // First, we generate the symbol table.  This has to be done serially b/c of
  // the sequential nature of C, i.e. symbols are visible in the order in which
  // they appear in the file.
  try {
    tu->gensymtab();
  }
  catch (exception &err) {
    cerr << err.what() << endl;
    return false;
  }
  if (sym_only) {
    return true;
  }
  // Now we spawn off threads to do the rest of the work.
  TranslationUnit &turef = ncastr<TranslationUnit>(tu);
  Results results;
  for (NodeList::iterator i = turef.begin(); i != turef.end(); ++i) {
    results.push_back(spawn(compile( *i, check_only )));
  }
  // If any of the results are false, we've got an error.
  for (Results::iterator i = results.begin(); i != results.end(); ++i) {
    if ( !i->value() ) {
      return false;
    }
  }
  return true;
}

bool Compiler::compile(Node *n,bool check_only)
{
  try {
    // Perform type checking.
    n->typecheck();
    // Perform basic flow-control analysis.
    n->flowcontrol();
    if (!check_only) {
      // Perform rest of compilation phase.
    }
  }
  catch (exception &err) {
    cerr << err.what() << endl;
    return false;
  }
  return true;
}

