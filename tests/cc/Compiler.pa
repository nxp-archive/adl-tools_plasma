//
// This class takes ASTs and performs all of the compilation passes.
//

#include <iostream>
#include <stdexcept>

#include "Compiler.h"
#include "SymTab.h"
#include "Node.h"
#include "CodeGen.h"

using namespace std;
using namespace plasma;

Compiler::Compiler( )
{
}

// Compile a translation unit.
bool Compiler::compileUnit(Node *tu,const char *filename,bool sym_only,bool check_only)
{
  // First, we generate the symbol table.  This has to be done serially b/c of
  // the sequential nature of C, i.e. symbols are visible in the order in which
  // they appear in the file.
  try {
    tu->gensymtab();
  }
  catch (exception &err) {
    cerr << err.what() << endl;
    return false;
  }
  if (sym_only) {
    return true;
  }
  // Now we spawn off threads to do the checking phases.
  TranslationUnit &turef = ncastr<TranslationUnit>(tu);
  BoolCheck results(make_boolcheck(true));
  for (NodeList::iterator i = turef.begin(); i != turef.end(); ++i) {
    results.push_back(spawn(dochecks( *i, check_only )));
  }
  // If any of the results are false, we've got an error.
  if (!results.check()) {
    return false;
  }
  if (check_only) {
    return true;
  }

  // Main global generator- creates shared data.
  CodeGen maingen(true);

  try {
    // Next, generate global variables.
    // This is done serially.
    maingen.handleGlobals(tu);

    // Generate main code.  This is done in parallel.
    results.clear();
    for (NodeList::iterator i = turef.begin(); i != turef.end(); ++i) {
      results.push_back(spawn(gencode(maingen,*i)));
    }
    // If any of the results are false, we've got an error.
    if (!results.check()) {
      return false;
    }
    
    // Create output name from input name.
    string outname = filename;
    size_t pos = outname.rfind(".c");
    if (pos != string::npos) {
      outname = outname.substr(0,pos) + ".s";
    } else {
      outname = outname + ".s";
    }
    pos = outname.rfind("/");
    if (pos != string::npos) {
      outname = outname.substr(pos+1);
    }

    cout << "\n" << filename << " -> " << outname << "\n";
    
    // Write out all assembly data.
    maingen.write(outname,&turef);
  }
  catch (exception &err) {
    cerr << err.what() << endl;
    return false;
  }
  return true;
}

// This creates a copy of the main generator, to be used
// by each thread.
bool Compiler::gencode(CodeGen codegen,Node *n)
{
  try {
    n->codegen(&codegen);
  }
  catch (exception &err) {
    cerr << err.what() << endl;
    return false;
  }
  return true;
}

bool Compiler::dochecks(Node *n,bool check_only)
{
  try {
    // Perform type checking.
    n->typecheck();
    // Perform basic flow-control analysis.
    n->flowcontrol();
  }
  catch (exception &err) {
    cerr << err.what() << endl;
    return false;
  }
  return true;
}

