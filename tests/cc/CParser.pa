//
// Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.
//
// You may distribute under the terms of the Artistic License, as specified in
// the COPYING file.
//
//
// The main parser class.  This wraps the parser internals,
// which are generated by Lemon.
//

#include <iostream>

#include "Tokens.h"
#include "CParser.h"
#include "Node.h"

using namespace std;

void *ParseAlloc(void *(*mallocProc)(size_t));
void ParseFree(void *,void (*freeProc)(void*));
void Parse(void *,int,Tokens,CParser *);
void ParseTrace(FILE *, char *);

CParser::CParser(bool debug) : 
  _parser(ParseAlloc(GC_malloc)),
  _error(false)
{
  if (debug) {
    ParseTrace(stdout,"lemon:  ");
  }
}

void CParser::parse(int t,Tokens tk) 
{ 
  //cout << "Token:  " << t << endl;
  _linenumber = tk._ln;
  _filename = tk._fn;
  Parse(_parser,t,tk,this); 
}

void CParser::setinfo(Node *n) const
{
  n->setFileData(_filename,_linenumber);
}

void CParser::reset()
{
  _error = false;
}

void CParser::reset_all()
{
  reset();
  _asts.clear();
}

void CParser::add_translation_unit(Node *n)
{
  _asts.push_back(n);
}

void CParser::print_ast_list(ostream &o,bool ps)
{
  if (ps) {
    o << printsyms;
  }
  for (Nodes::const_iterator i = _asts.begin(); i != _asts.end(); ++i) {
    o << "\nTranslation Unit\n"
      << "================\n"
      << (*i)
      << endl;
  }
}
