
#include <iostream>

#include "String.h"
#include "CLexer.h"
#include "CParser.h"
#include "Channels.h"
#include "Compiler.h"

using namespace plasma;
using namespace std;

void tokenize(TokChan &tc);
void parse(TokChan &tc);

// Options singleton structure.
struct Options {
  bool                 _debug; // Show parser debug info.
  bool                 _ast;   // Generate AST.
  bool                 _syms;  // Print AST + symbols.
  bool                 _check; // Stop after checking phase.
  vector<const char *> _files; // Files to parse.       

  Options() :
    _debug(false),
    _ast(false),
    _syms(false),
    _check(false)
  {};
};

Options options;

bool parseOptions(int argc,const char *argv[])
{
  if (argc < 2) {
    return false;
  }
  for (int i = 1; i < argc; ++i) {
    if (!strcmp(argv[i],"-ast")) {
      options._ast = true;
    }
    else if (!strcmp(argv[i],"-syms")) {
      options._ast = true;
      options._syms = true;
    }
    else if (!strcmp(argv[i],"-check")) {
      options._check = true;
    }
    else if (!strcmp(argv[i],"-d")) {
      options._debug = true;
    }
    else {
      int len = strlen(argv[i]);
      if (len > 2 && !strcmp(&argv[i][len-2],".c")) {
        options._files.push_back(argv[i]);
      } else {
        cerr << "Error:  Unknown option " << argv[i] << "\n\n";
        return false;
      }
    }
  }
  if (options._files.empty()) {
    cerr << "Error:  No input files were specified.\n\n";
    return false;
  }
  return true;
}

int pMain(int argc,const char *argv[])
{
  if (!parseOptions(argc,argv)) {
    cerr << "Usage:  " << argv[0] << " <filename | options>... " << endl;
    return 1;
  }

  TokChan tc;

  par {
    tokenize(tc);
    parse(tc);
  }
  cerr << "\nCompile succeeded." << endl;
  return 0;
}

void tokenize(TokChan &tc)
{
  CLexer cl(tc);
  // Tokenize all files.
  for (unsigned i = 0; i != options._files.size(); ++i) {
    cl.reset(options._files[i]);
    cl.yylex();
  }
  cl.send_alldone();
}

void parse(TokChan &tc)
{
  CParser cp(options._debug);
  while(!cp.error()) {
    Tokens tk = tc.get();
    if (tk._tok < 0) break;
    cp.parse(tk._tok,tk);
    if (!tk._tok) {
      cp.reset();
    }
  }
  // If we have a parsing error, exit.
  if (cp.error()) {
    pExit(1);
  }
  // Do the compilation:  Give each translation unit
  // to the compiler and tell it to go to work.
  Compiler compiler(cp.translationUnits());
  compiler.compileUnits(options._ast,options._check);
  if (compiler.error()) {
    pExit(2);
  }
  // Print ASTs, if so requested.
  if (options._ast) {
    compiler.print_ast_list(cout,options._syms);
  }
}

