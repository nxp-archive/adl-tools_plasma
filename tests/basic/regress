#!/usr/bin/env perl 
# -- -*-perl-*-a
#
# Tests used in this regression.

use lib "..";
use rdriver;
use strict;

my @Tests = (
	     # Basic par block test.
	     {
	      cmd     => "./par1",
	      checker => \&check_par1,
	     },
	     # Looping par block test.
	     {
	      cmd     => "./par2",
	      checker => \&check_par2,
	     },
	     # Looping par block test with structure as loop variable.
	     {
	      cmd     => "./par3",
	      checker => \&check_par3,
	     },
	     # Quicksort with parallel sorting of split elements.
	     {
	      cmd     => "./qsort",
	      checker => \&check_qsort,
	     },
	     # Channel test directly using C++ interface.
	     {
	      cmd     => "./chan1",
	      checker => \&check_chan1,
	     },
	     # Channel test using alt.
	     {
	      cmd     => "./chan2",
	      checker => \&check_chan2,
	     },
	    );

doTest(\@Tests);

# We make sure that we get the result values we expect, since this will
# ensure that we waited until the threads in the par block were finished.
# We also make sure that the block statements are interleavedd, to make sure
# that we're getting timeslicing.
sub check_par1 {
  my @lines = split /\n/,@_[0];
  my ($er1,$er2,$er3) = (69,200,1000);
  my ($r1,$r2,$r3) = (0,0,0);
  my $cb1 = 0;
  for (@lines) {
    if (/^Result1:\s+(\d+),\s+Result2:\s+(\d+),\s+Result3:\s+(\d+)/) {
      ($r1,$r2,$r3) = ($1,$2,$3);
    } elsif ( /^In block 1./ ) {
      ++$cb1;
      if ($cb1 >= 8) {
	die "Expected to find interleaved block statements but did not.\n";
      }
    } elsif ( /^In block 2./ ) {
      $cb1 = 0;
    }
  }
  if ($r1 != $er1) {
    die "Expected Result1 to be $er1, got $r1 instead.\n";
  }
  if ($r2 != $er2) {
    die "Expected Result2 to be $er2, got $r2 instead.\n";
  }
  if ($r3 != $er3) {
    die "Expected Result3 to be $er3, got $r3 instead.\n";
  }
}

# Pretty much the same as check_par1, except slightly different data is expected.
sub check_par2 {
  my @lines = split /\n/,@_[0];
  my @exp = (2000,1999,1998,1997,1996);
  my $expnb = 5;
  my @cb = (0) x 10;
  my $lb = -1;
  for (@lines) {
    if ( /^In block (\d+)./ ) {
      my $b = $1;
      if ($b != $lb) {
	$cb[$b] = 0;
      } else {
	$cb[$b]++;
      }
      if ($cb[$b] >= 8) {
	die "Expected to find interleaved block statements but did not.\n";
      }
      $lb = $b;
    } elsif ( /Num blocks:\s+(\d+)/) {
      if ($1 != $expnb) {
	die "Expected number of blocks answer to be $expnb.\n";
      }
    } elsif ( /^Result/ ) {
      my @res = ( /Result\[\d+\]:\s+(\d+)/g );
      for my $i (0..$#exp) {
	if ($res[$i] != $exp[$i]) {
	  die "Mismatch on result value $i (Found $res[$i], expected $exp[$i]).\n";
	}
      }
    }
  }
}

# Pretty much the same as check_par2, except slightly different data is expected.
sub check_par3 {
  my @lines = split /\n/,@_[0];
  my $start = 101;
  for (@lines) {
    if ( /^Result/ ) {
      my @res = ( /Result\[\d+\]:\s+(\d+.\d+)/g );
      for my $i (0..$#res) {
	if ($res[$i] != $start) {
	  die "Mismatch on result value $i (Found $res[$i], expected $start).\n";
	}
	$start += 2;
      }
    }
  }
}

# Just make sure that we got the right number of messages.
# The checking of the sorting is down by the program itself.
sub check_qsort {
  my @lines = split /\n/,@_[0];
  my $elc = 25;
  my $lc = 0;
  for (@lines) {
    ++$lc if ( /^Sorting with size/);
  }
  if ($lc != $elc) {
    die "Expected to have $elc sorts done, found only $lc.\n";
  }
}

sub check_chan1 {
  my @data = ([10,10],[100,10],[1000,10],[10000,10]);
  check_channel (@_[0],"Data read from channel (\\d+):\\s+(\\d+)",\@data,5);
}

sub check_chan2 {
  my @data = ([10,10],[100,10],[1000,10],[10000,10]);
  check_channel (@_[0],"Got a value from port c(\\d+):\\s+(\\d+)",\@data,5);
}

# Make sure that all expected integers are received.  These should
# be four sets of ten integers starting at 10, 100, 1000, and 10000.
sub check_channel {
  my ($input,$regex,$data,$expNumFinish) = (shift,shift,shift,shift);
  my @lines = split /\n/,$input;
  my $max = 10;
  my $numFinish = 0;
  dprint "Regex:  $regex\n";
  for (@lines) {
    dprint "Line:  $_\n";
    if ( /$regex/ ) {
      my $chan = $1;
      my $val = $2;
      dprint "Read $val from channel $chan.\n";
      if ($val >= $data->[$chan]->[0] && $val < ($data->[$chan]->[0]+$max)) {
	--($data->[$chan]->[1]);
      } else {
	print "Data out of bound for channel $chan:  Got $val, expected value in [",
	  $data->[$chan]->[0],":",($data->[$chan]->[0]+$max),").\n";
	die;
      }
    } elsif ( /(Producer|Consumer) done./ ) {
      ++$numFinish;
    }
  }
  if ($numFinish != $expNumFinish) {
    print "Expected $expNumFinish threads to finish, found only $numFinish.\n";
    die;
  }
  for my $i (0..(scalar @{$data} - 1)) {
    if ($data->[$i]->[1]) {
      print "Not all data was found for channel $i.\n";
      die;
    }
  }
}

