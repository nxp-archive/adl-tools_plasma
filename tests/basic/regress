#!/usr/bin/env perl 
# -- -*-perl-*-a
#
# Tests used in this regression.

use lib "..";
use rdriver;
use strict;

my @Tests = (
	  # Basic par block test.
	  {
	   cmd     => "par1",
	   checker => \&check_par1,
	  },
	  # Looping par block test.
	  {
	   cmd     => "par2",
	   checker => \&check_par2,
	  },
	  # Looping par block test with structure as loop variable.
	  {
	   cmd     => "par3",
	   checker => \&check_par3,
	  },
	  # Quicksort with parallel sorting of split elements.
	  {
	   cmd     => "qsort",
	   checker => \&check_qsort,
	  },
	 );

doTest(\@Tests);

# We make sure that we get the result values we expect, since this will
# ensure that we waited until the threads in the par block were finished.
# We also make sure that the block statements are interleavedd, to make sure
# that we're getting timeslicing.
sub check_par1 {
  my @lines = split /\n/,@_[0];
  my ($er1,$er2,$er3) = (69,200,1000);
  my ($r1,$r2,$r3) = (0,0,0);
  my $cb1 = 0;
  for (@lines) {
    if (/^Result1:\s+(\d+),\s+Result2:\s+(\d+),\s+Result3:\s+(\d+)/) {
      ($r1,$r2,$r3) = ($1,$2,$3);
    } elsif ( /^In block 1./ ) {
      ++$cb1;
      if ($cb1 >= 8) {
	die "Expected to find interleaved block statements but did not.\n";
      }
    } elsif ( /^In block 2./ ) {
      $cb1 = 0;
    }
  }
  if ($r1 != $er1) {
    die "Expected Result1 to be $er1, got $r1 instead.\n";
  }
  if ($r2 != $er2) {
    die "Expected Result2 to be $er2, got $r2 instead.\n";
  }
  if ($r3 != $er3) {
    die "Expected Result3 to be $er3, got $r3 instead.\n";
  }
}

# Pretty much the same as check_par1, except slightly different data is expected.
sub check_par2 {
  my @lines = split /\n/,@_[0];
  my @exp = (2000,1999,1998,1997,1996);
  my $expnb = 5;
  my @cb = (0) x 10;
  my $lb = -1;
  for (@lines) {
    if ( /^In block (\d+)./ ) {
      my $b = $1;
      if ($b != $lb) {
	$cb[$b] = 0;
      } else {
	$cb[$b]++;
      }
      if ($cb[$b] >= 8) {
	die "Expected to find interleaved block statements but did not.\n";
      }
      $lb = $b;
    } elsif ( /Num blocks:\s+(\d+)/) {
      if ($1 != $expnb) {
	die "Expected number of blocks answer to be $expnb.\n";
      }
    } elsif ( /^Result/ ) {
      my @res = ( /Result\[\d+\]:\s+(\d+)/g );
      for my $i (0..$#exp) {
	if ($res[$i] != $exp[$i]) {
	  die "Mismatch on result value $i (Found $res[$i], expected $exp[$i]).\n";
	}
      }
    }
  }
}

# Pretty much the same as check_par2, except slightly different data is expected.
sub check_par3 {
  my @lines = split /\n/,@_[0];
  my $start = 101;
  for (@lines) {
    if ( /^Result/ ) {
      my @res = ( /Result\[\d+\]:\s+(\d+.\d+)/g );
      for my $i (0..$#res) {
	if ($res[$i] != $start) {
	  die "Mismatch on result value $i (Found $res[$i], expected $start).\n";
	}
	$start += 2;
      }
    }
  }
}

# Just make sure that we got the right number of messages.
# The checking of the sorting is down by the program itself.
sub check_qsort {
  my @lines = split /\n/,@_[0];
  my $elc = 25;
  my $lc = 0;
  for (@lines) {
    ++$lc if ( /^Sorting with size/);
  }
  if ($lc != $elc) {
    die "Expected to have $elc sorts done, found only $lc.\n";
  }
}
