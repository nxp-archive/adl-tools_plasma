#!/usr/bin/env perl 
# -- -*-perl-*-a
#
# Tests used in this regression.

use lib "..";
use rdriver;
use regress_utils;
use strict;
use Data::Dumper;

my @Tests = (
	     # Basic par block test.
	     {
	      cmd     => "./par1",
	      checker => \&check_par1,
	     },
	     # Looping par block test.
	     {
	      cmd     => "./par2",
	      checker => \&check_par2,
	     },
	     # Looping par block test with structure as loop variable.
	     {
	      cmd     => "./par3",
	      checker => \&check_par3,
	     },
	     # Check of code generation w/classes.
	     {
	      cmd     => "./par4",
	      checker => \&check_par1,
	     },
	     # Check that nested pars work.
	     {
	      cmd     => "./par5",
	      checker => \&check_par5,
	     },
	     # Check that nested pars and pfors work.
	     {
	      cmd     => "./par6",
	      checker => \&check_par6,
	     },
	     # Check that nested pars and pfors work w/on blocks.
	     {
	      cmd     => "./par7",
	      checker => \&check_par6,
	     },
	     # Check that pars work with explicit method calls.
	     {
	      cmd     => "./par8",
	      checker => \&check_par8,
	     },
	     # Check that pars work with implicit method calls.
	     {
	      cmd     => "./par9",
	      checker => \&check_par8,
	     },
	     # Quicksort with parallel sorting of split elements.
	     {
	      cmd     => "./qsort",
	      checker => \&check_qsort,
	     },
	     # Channel test directly using C++ interface.
	     {
	      cmd     => "./chan1",
	      checker => \&check_chan1,
	     },
	     # Channel test using alt.
	     {
	      cmd     => "./chan2",
	      checker => \&check_chan2,
	     },
	     # Channel test using alt with a default block.
	     {
	      cmd     => "./chan3",
	      checker => \&check_chan3,
	     },
	     # Channel test using afor.
	     {
	      cmd     => "./chan4",
	      checker => \&check_chan4,
	     },
	     # Channel test using afor and a non-integer iterator.
	     {
	      cmd     => "./chan5",
	      checker => \&check_chan5,
	     },
	     # Channel test using afor and a default block.
	     {
	      cmd     => "./chan6",
	      checker => \&check_chan6,
	     },
	     # Channel test using afor, non-integer iterator, and a default block.
	     {
	      cmd     => "./chan7",
	      checker => \&check_chan7,
	     },
	     # Channel test using a queued channel.
	     {
	      cmd     => "./chan8",
	      checker => \&check_chan8,
	     },
	     # Channel test using a queued channel with a fixed size.
	     {
	      cmd     => "./chan9",
	      checker => \&check_chan9,
	     },
	     # Channel test w/multiple afor and alts in an alt.
	     {
	      cmd     => "./chan10",
	      checker => \&check_chan10,
	     },
	     # Channel test w/multiple afor and alts in an alt and a default block
	     {
	      cmd     => "./chan11",
	      checker => \&check_chan11,
	     },
	     # Channel test w/a timeout channel.
	     {
	      cmd     => "./chan12",
	      checker => \&check_chan12,
	     },
	     # Channel test par blocks.
	     {
	      cmd     => "./chan13",
	      checker => \&check_chan13,
	     },
	     # Channel test w/multiple processors.
	     {
	      cmd     => "./chan14",
	      checker => \&check_chan14,
	     },
	     # Channel test w/value not required in port body.
	     {
	      cmd     => "./chan15",
	      checker => \&check_chan15,
	     },
	     # Channel test w/afor and value not required in port body.
	     {
	      cmd     => "./chan16",
	      checker => \&check_chan16,
	     },
	     # Channel test w/multiple producers using a simple channel.
	     {
	      cmd     => "./chan17",
	      checker => \&check_chan17,
	     },
	     # Spawn test- C++ only.
	     {
	      cmd     => "./spawn1",
	      checker => \&check_spawn1,
	     },
	     # Spawn test with spawn operator.
	     {
	      cmd     => "./spawn2",
	      checker => \&check_spawn2,
	     },
	     # Spawn test with member calls.
	     {
	      cmd     => "./spawn3",
	      checker => \&check_spawn3,
	     },
	     # Spawn test with alt.
	     {
	      cmd     => "./spawn4",
	      checker => \&check_spawn4,
	     },
	     # Mutex test w/shared data structure.
	     {
	      cmd     => "./mutex1",
	      checker => \&check_mutex1,
	     },
	     # Test of priorities.
	     {
	      cmd     => "./pri1",
	      checker => \&check_pri1,
	     },
	     # Test of priorities.
	     {
	      cmd     => "./pri2",
	      checker => \&check_pri2,
	     },
	     # Test of priorities.
	     {
	      cmd     => "./pri3",
	      checker => \&check_pri3,
	     },
	     # Test of priorities.
	     {
	      cmd     => "./pri4",
	      checker => \&check_pri4,
	     },
	     # Test of priorities.
	     {
	      cmd     => "./pri5",
	      checker => \&check_pri5,
	     },
	     # Test of priorities.
	     {
	      cmd     => "./pri6",
	      checker => \&check_pri6,
	     },
	     # C++-only processor test.
	     {
	      cmd     => "./proc1",
	      checker => \&check_proc1,
	     },
	     # Processor test w/on-blocks.
	     {
	      cmd     => "./proc2",
	      checker => \&check_proc2,
	     },
	     # Processor test spawn.
	     {
	      cmd     => "./proc3",
	      checker => \&check_proc3,
	     },
	     # Multiple processors w/busy.
	     {
	      cmd     => "./proc4",
	      checker => \&check_proc4,
	     },
	     # Multiple processors w/delay.
	     {
	      cmd     => "./proc5",
	      checker => \&check_proc5,
	     },
	     # Time w/invalid busy.
	     {
	      cmd     => "./time1",
	      fail    => 1,
	     },
	     # Time w/delay.
	     {
	      cmd     => "./time2",
	      checker => \&check_time2,
	     },
	     # Time w/busy.
	     {
	      cmd     => "./time3",
	      checker => \&check_time3,
	     },
	     # Time w/timeslicing.
	     {
	      cmd     => "./time4",
	      checker => \&check_time4,
	     },
	     # Time w/a single thread on its own processor.
	     {
	      cmd     => "./time5",
	      checker => \&check_time5,
	     },
	    );

doTest(\@Tests);

##
## Place test routines here.
## <TESTS>
##

# We make sure that we get the result values we expect, since this will
# ensure that we waited until the threads in the par block were finished.
# We also make sure that the block statements are interleavedd, to make sure
# that we're getting timeslicing.
sub check_par1 {
  my @lines = split /\n/,@_[0];
  my ($er1,$er2,$er3) = (69,200,1000);
  my ($r1,$r2,$r3) = (0,0,0);
  my $cb1 = 0;
  for (@lines) {
    if (/^Result1:\s+(\d+),\s+Result2:\s+(\d+),\s+Result3:\s+(\d+)/) {
      ($r1,$r2,$r3) = ($1,$2,$3);
    } elsif ( /^In block 1./ ) {
      ++$cb1;
      if ($cb1 >= 8) {
	die "Expected to find interleaved block statements but did not.\n";
      }
    } elsif ( /^In block 2./ ) {
      $cb1 = 0;
    }
  }
  if ($r1 != $er1) {
    die "Expected Result1 to be $er1, got $r1 instead.\n";
  }
  if ($r2 != $er2) {
    die "Expected Result2 to be $er2, got $r2 instead.\n";
  }
  if ($r3 != $er3) {
    die "Expected Result3 to be $er3, got $r3 instead.\n";
  }
}

# Pretty much the same as check_par1, except slightly different data is expected.
sub check_par2 {
  my @lines = split /\n/,@_[0];
  my @exp = (2000,1999,1998,1997,1996);
  my $expnb = 5;
  my @cb = (0) x 10;
  my $lb = -1;
  for (@lines) {
    if ( /^In block (\d+)./ ) {
      my $b = $1;
      if ($b != $lb) {
	$cb[$b] = 0;
      } else {
	$cb[$b]++;
      }
      if ($cb[$b] >= 8) {
	die "Expected to find interleaved block statements but did not.\n";
      }
      $lb = $b;
    } elsif ( /Num blocks:\s+(\d+)/) {
      if ($1 != $expnb) {
	die "Expected number of blocks answer to be $expnb.\n";
      }
    } elsif ( /^Result/ ) {
      my @res = ( /Result\[\d+\]:\s+(\d+)/g );
      for my $i (0..$#exp) {
	if ($res[$i] != $exp[$i]) {
	  die "Mismatch on result value $i (Found $res[$i], expected $exp[$i]).\n";
	}
      }
    }
  }
}

# Pretty much the same as check_par2, except slightly different data is expected.
sub check_par3 {
  my @lines = split /\n/,@_[0];
  my $start = 101;
  for (@lines) {
    if ( /^Result/ ) {
      my @res = ( /Result\[\d+\]:\s+(\d+.\d+)/g );
      for my $i (0..$#res) {
	if ($res[$i] != $start) {
	  die "Mismatch on result value $i (Found $res[$i], expected $start).\n";
	}
	$start += 2;
      }
    }
  }
}

# Test of nested pars.
sub check_par5 {
  my %count = (
	       1.1 => 0,
	       1.21 => 0, 
	       1.22 => 0,
	       1.3  => 0,
	       2.0 => 0,
	       3.0 => 0,
	       10.1 => 0,
	       10.2 => 0,
	       10.3 => 0,
	       20 => 0,
	       30 => 0,
	      );
  check_sequence(@_[0],0,\%count);

  my @exp1 = ( 1.1, 1.2, 1.3, 4, 5 );
  my @exp2 = ( 10, 20, 30, 40, 50);
  check_spawn($_[0], \@exp1, \@exp2 );
}

# Checks that nested pfor/pars work.
sub check_par6 {
  my @exp1 = ( 10, 12.5, 20, 25, 30, 37.5, 40, 50, 50, 62.5 );
  my @exp2 = ( 10, 16.8, 20, 33.6, 30, 50.4, 40, 67.2, 50, 84, );
  check_spawn($_[0], \@exp1, \@exp2);
}

# Checks that explicit method calls work, i.e. this->xx().
sub check_par8 {
  my @exp1 = ( 1 );
  my @exp2 = ( 2 );
  my @exp3 = ( 3 );
  my @exp4 = ( 4 );
  my @exp5 = ( 5 );
  my @exp6 = ( 6 );
  check_spawn($_[0], \@exp1, \@exp2, \@exp3, \@exp4, \@exp5, \@exp6);
}

# Just make sure that we got the right number of messages.
# The checking of the sorting is down by the program itself.
sub check_qsort {
  my @lines = split /\n/,@_[0];
  my $elc = 25;
  my $lc = 0;
  for (@lines) {
    ++$lc if ( /^Sorting with size/);
  }
  if ($lc != $elc) {
    die "Expected to have $elc sorts done, found only $lc.\n";
  }
}


sub check_chan1 {
  my @data = ([10..19],[100..109],[1000..1009],[10000..10009]);
  check_channel (@_[0],"Data read from channel (\\d+):\\s+(\\d+)",\@data,5);
}

sub check_chan2 {
  my @data = ([10..19],[100..109],[1000..1009],[10000..10009]);
  check_channel (@_[0],"Got a value from port c(\\d+):\\s+(\\d+)",\@data,5);
}

sub check_chan3 {
  my @data = ([10..19]);
  check_channel (@_[0],"Got a value from port c(\\d+):\\s+(\\d+)",\@data,2,[ "No value present."]);
}

sub check_chan4 {
  my @data = ([20..29],[200..209],[2000..2009],[20000..20009],[200000..200009],[2000000..2000009]);
  check_channel (@_[0],"Got a value from port (\\d+):\\s+(\\d+)",\@data,7);
}

sub check_chan5 {
  my @data = ([30..39],[300..309],[3000..3009],[30000..30009],[300000..300009],[3000000..3000009]);
  check_channel (@_[0],"Got a value from port (\\d+):\\s+(\\d+)",\@data,7);
}

sub check_chan6 {
  my @data = ([20..29],[200..209]);
  check_channel (@_[0],"Got a value from port (\\d+):\\s+(\\d+)",\@data,3,[ "No value present."]);
}

sub check_chan7 {
  my @data = ([30..39],[300..309],[3000..3009]);
  check_channel (@_[0],"Got a value from port (\\d+):\\s+(\\d+)",\@data,4,[ "No value present."]);
}

sub check_chan8 {
  my @data = ([10..19],[100..109],[1000..1009],[10000..10009]);
  check_qchannel (@_[0],"Read a value:\\s+(\\d+)",\@data,5);
}

sub check_chan9 {
  my @data = ([10..19],[100..109],[1000..1009],[10000..10009]);
  check_qchannel (@_[0],"Read a value:\\s+(\\d+)",\@data,5,"Queue size:\\s+(\\d+)",3);
}

sub check_chan10 {
  my @data = ([60..69],
	      [20..29],
	      [200..209],
	      [2000..2009],
	      [20000..20009],
	      [200000..200009],
	      [2000000..2000009],
	      [2.3, 3.3, 4.3, 5.3, 6.3, 7.3, 8.3, 9.3, 10.3, 11.3 ],
	      [3.45, 4.45, 5.45, 6.45, 7.45, 8.45, 9.45, 10.45, 11.45, 12.45],
	      [5.175, 6.175, 7.175, 8.175, 9.175, 10.175, 11.175, 12.175, 13.175, 14.175],
	      [7.7625, 8.7625, 9.7625, 10.7625, 11.7625, 12.7625, 13.7625, 14.7625, 15.7625, 16.7625]
	      );
  check_channel (@_[0],"Got a value from port (\\d+):\\s+(\\d+\.?\\d*)",\@data,12);
}

sub check_chan11 {
  my @data = ([60..69],
	      [20..29],
	      [200..209],
	      [2000..2009],
	      [20000..20009],
	      [200000..200009],
	      [2000000..2000009],
	      [2.3, 3.3, 4.3, 5.3, 6.3, 7.3, 8.3, 9.3, 10.3, 11.3 ],
	      [3.45, 4.45, 5.45, 6.45, 7.45, 8.45, 9.45, 10.45, 11.45, 12.45],
	      [5.175, 6.175, 7.175, 8.175, 9.175, 10.175, 11.175, 12.175, 13.175, 14.175],
	      [7.7625, 8.7625, 9.7625, 10.7625, 11.7625, 12.7625, 13.7625, 14.7625, 15.7625, 16.7625]
	      );
  check_channel (@_[0],"Got a value from port (\\d+):\\s+(\\d+\.?\\d*)",\@data,12,["No value present."]);
}

sub check_chan12 {
  # Check that the correct data is communicated.
  str_rdiff(@_[0],[
		   "Got value from channel:  100 at time 0",
		   "Got value from channel:  200 at time 5",
		   "Got timeout at time 25",
		   "Got value from channel:  300 at time 30",
		   "Got value from channel:  400 at time 30",
		   "Got timeout at time 50",
		   "Got timeout at time 70",
		   "Got timeout at time 90",
		   "Got timeout at time 110",
		   "Got timeout at time 130",
		  ]);
  # Check that everybody finishes.  Note that a slight tweak to the scheduler
  # means that the exact ordering of the done messages could change, so that's
  # why it's separated out here.
  str_rdiff(@_[0],[
		   "Producer done.",
		   "Consumer done.",
		   "Done.",
		   ]);
}

sub check_chan13 {
  my @data = (
	      [1..3],
	      [4..6],
	      [7..9],
	      [10..12],
	     );
  check_channel (@_[0],"Data from port (\\d+):\\s+(\\d+)",\@data);
}

sub check_chan14 {
  my @data = (
	      [10..19],
	     );
  check_channel (@_[0],"Got a value from port c(\\d+):\\s+(\\d+)",\@data);
}

sub check_chan15 {

  # Verify consumer gets its data.
  my @data = (
	      [0..9],
	     );
  check_channel (@_[0],"Got a value from port c(\\d+):\\s+count is (\\d+)",\@data,2);

  # Verify that producer publishes all data.
  str_rdiff(@_[0],[
		   "Producer wrote 0.",
		   "Producer wrote 1.",
		   "Producer wrote 2.",
		   "Producer wrote 3.",
		   "Producer wrote 4.",
		   "Producer wrote 5.",
		   "Producer wrote 6.",
		   "Producer wrote 7.",
		   "Producer wrote 8.",
		   "Producer wrote 9.",
		   ]);
}

sub check_chan16 {

  # Verify consumer gets its data.
  my @data = (
	      [0..9],
	      [0..9],
	     );
  check_channel (@_[0],"Got a value from port c(\\d+):\\s+count is (\\d+)",\@data,3);

  # Verify that producer publishes all data.
  str_rdiff(@_[0],[
		   "Producer 0 wrote 0.",
		   "Producer 0 wrote 1.",
		   "Producer 0 wrote 2.",
		   "Producer 0 wrote 3.",
		   "Producer 0 wrote 4.",
		   "Producer 0 wrote 5.",
		   "Producer 0 wrote 6.",
		   "Producer 0 wrote 7.",
		   "Producer 0 wrote 8.",
		   "Producer 0 wrote 9.",
		   ]);
  str_rdiff(@_[0],[
		   "Producer 1 wrote 0.",
		   "Producer 1 wrote 1.",
		   "Producer 1 wrote 2.",
		   "Producer 1 wrote 3.",
		   "Producer 1 wrote 4.",
		   "Producer 1 wrote 5.",
		   "Producer 1 wrote 6.",
		   "Producer 1 wrote 7.",
		   "Producer 1 wrote 8.",
		   "Producer 1 wrote 9.",
		   ]);

}

sub check_chan17 {
  # Verify consumer gets its data.
  my @data1 = (
	       [1..50],
	      );
  check_channel (@_[0],"Comm (\\d+):\\s+Chan Num=\\d+,\\s+item \\d+\\s+Rcvd msg num=(\\d+)",\@data1,6);

  # Verify producers wrote data.
  my @data2 = (
	      [1..10],
	      [1..10],
	      [1..10],
	      [1..10],
	      [1..10],
	     );
  check_channel (@_[0],"Producer (\\d+):\\s+Sending msg num=(\\d+)",\@data2);
}

sub check_spawn1 {
  my @exp = ( 6.05, 103.33, 10103.1 );
  check_spawn($_[0], \@exp);
}

sub check_spawn2 {
  my @exp1 = ( 6.05, 103.33, 10103.1, 3.14159 );
  my @exp2 = ( 10204.4, 3.14159 );
  my @exp3 = ( 0 );
  check_spawn($_[0], \@exp1, \@exp2, \@exp3 );
}

sub check_spawn3 {
  my @exp1 = ( 6.05, 103.33, 10103.0906, 3.14159 );
  my @exp2 = ( 25, 50100.05, 4905, 6961.16 );
  my @exp3 = ( 2.718282, 2.718282, 3.141590, 2.718282, 2.718282 );
  check_spawn($_[0], \@exp1,\@exp2,\@exp3);
}

sub check_spawn2 {
  my @exp1 = ( 6.05, 103.33, 10103.1, 3.14159 );
  my @exp2 = ( 10204.4, 3.14159 );
  my @exp3 = ( 0 );
  check_spawn($_[0], \@exp1, \@exp2, \@exp3 );
}

sub check_spawn4 {
  my @data = (6.05,15.73,216);
  my @lines = split /\n/,shift;
  my ($expected,$found) = (3,0);
  for (@lines) {
    if (/r(\d+):\s+(\d+\.?\d*)/) {
      my ($p,$d) = (eval $1,eval $2);
      ++$found;
      if ( $data[$p] != $d ) {
	die "Expected $data[$p] for channel $p, got instead $d.\n";
      }
    }
  }
  if ($found != $expected) {
    die "Expected $expected items, found $found.\n";
  }
}

# We check to make sure that each number is only received once and that we get
# all expected numbers.
sub check_mutex1 {
  my @lines = split /\n/,shift;
  my %data;
  my %done = ( "Producer"  => 0,
	       "Consumer" => 0,
	       "pMain" => 0 );
  @data{0..999} = (0) x 1000;
  for (@lines) {
    if ( /Q result:\s+(\d+)/ ) {
      ++$data{$1};
    } elsif ( /(\S+)\s+done/ ) {
      ++$done{$1};
    }
  }
  for my $i (keys (%data)) {
    if ($data{$i} != 1) {
      die "Bad data count for item $i:  $data{$i}.\n";
    }
  }
  for my $i (keys (%done)) {
    if ($done{$i} != 1) {
      die "Bad done count for item $i:  $done{$i}.\n";
    }
  }
}

# Test priority sequence.
sub check_pri1 {
  my $seq = "(1 )+(1\\.1 )+(1\\.2 )+(2 )+(2\\.1 )+(2\\.2 )+(4 |3 )+(3\\.1 )+(4 )*";;
  my %count = (
	       1.0 => 20, 
	       1.1 => 4, 
	       1.2 => 4,
	       2.0 => 20,
	       2.1 => 4,
	       2.2 => 4,
	       3.0 => 10,
	       3.1 => 10,
	       4.0 => 15 
	      );
  check_sequence(@_[0],$seq,\%count);
}

# Test priority sequence.
sub check_pri2 {
  my $seq = "(1 |3 |4 )+(2 )+(1 |3 |4 )+";;
  my %count = (
	       1.0 => 10, 
	       2.0 => 30,
	       3.0 => 10,
	       4.0 => 10,
	      );
  check_sequence(@_[0],$seq,\%count);
};

# Test priority sequence.
sub check_pri3 {
  my @exp1 = ( 6.05, 103.33, 10103.1, 103.33, 3.14159 );
  my @exp2 = ( 3, 2, 20, 1, 4 );
  check_spawn($_[0], \@exp1, \@exp2 );
};

# Test priority sequence.
sub check_pri4 {
  my $seq = "(1 )+(3 )+(2 )+(4 )+";;
  my %count = (
	       1.0 => 10, 
	       2.0 => 10,
	       3.0 => 10,
	       4.0 => 10,
	      );
  check_sequence(@_[0],$seq,\%count);
};

sub check_pri5 {
  str_rdiff(@_[0],[
		   "Priorities...",
		   "Low Starting",
		   "Low switching to priority 7",
		   "Low computing at 0",
		   "Low completed at 1000",
		   "High Starting",
		   "High switching to priority 4",
		   "High computing at 1000",
		   "High computed until 1100",
		   "High computing at 1200",
		   "High computed until 1300",
		   "High completed at 1400",
		  ]);
}

sub check_pri6 {
  str_rdiff(@_[0],[
		   "Priorities...",
		   "High Starting",
		   "High switching to priority 4",
		   "High computing at 0",
		   "High computed until 100",
		   "Low Starting",
		   "Low switching to priority 7",
		   "Low computing at 100",
		   "High computing at 200",
		   "High computed until 300",
		   "High completed at 400",
		   "Low completed at 1200",
		   ]);
}

# C++-only processor test.
sub check_proc1 {
  my $seq = "(1 )+(2 |3 )+(4 |5 )+";
  my %count = (
	       1.0 => 10, 
	       2.0 => 10,
	       3.0 => 10,
	       4.0 => 20,
	       5.0 => 10,
	      );
  check_sequence(@_[0],$seq,\%count);
};

# Processor test w/on-blocks.
sub check_proc2 {
  my $seq = "(1 )+(2 |3 )+(4 |5 )+";
  my %count = (
	       1.0 => 10, 
	       2.0 => 10,
	       3.0 => 10,
	       4.0 => 20,
	       5.0 => 10,
	      );
  check_sequence(@_[0],$seq,\%count);

  # Check that processor naming works.
  str_rdiff(@_[0],[
		   "P1's name:  Proc1",
		   "P2's name:  Proc2",
		   "P2 is a P2!",
		   ]);  
};

# Processor test w/spawn.
sub check_proc3 {
  my @exp1 = ( 6.05, 103.33, 10103.1, 3.14159 );
  check_spawn($_[0], \@exp1 );
}

# Busy w/multiple procs.
sub check_proc4 {
  my %diff = (
 	      0 => [0,0],
 	      1 => [0,10],
 	      2 => [0,20],
 	      3 => [0,30],
 	      4 => [0,40],
 	      5 => [0,50],
 	      6 => [0,60],
 	      7 => [0,70],
 	      8 => [0,80],
 	      9 => [0,90],
 	     );
  check_times($_[0],\%diff);
}

# Delay w/multiple procs.
sub check_proc5 {
  my %diff = (
 	      0 => [0,0],
 	      1 => [0,20],
 	      2 => [0,40],
 	      3 => [0,60],
 	      4 => [0,80],
 	      5 => [0,100],
 	      6 => [0,120],
 	      7 => [0,140],
 	      8 => [0,160],
 	      9 => [0,180],
 	     );
  check_times($_[0],\%diff);
}

# Time model w/delay.
sub check_time2 {
  my %seq = (
	      1 => [ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90 ],
	      2 => [ 0, 20, 40, 60, 80, 100, 120, 140, 160, 180 ],
	      );
  check_time_seq($_[0],\%seq);

  my %diff = (
 	      3 => 50,
 	     );
  check_times($_[0],\%diff);
}

# Time model w/busy.
sub check_time3 {
  my %seq = (
	      1 => [ 0, 20, 40, 60, 80, 100, 120, 140, 160, 180 ],
	      2 => [ 10, 30, 50, 70, 90, 110, 130, 150, 170, 190 ],
	      );
  check_time_seq($_[0],\%seq);

  my %diff = (
 	      3 => 50,
	      4 => 70,
 	     );
  check_times($_[0],\%diff);
}

# Busy w/timeslicing.
sub check_time4 {
  my %diff = (
 	      1 => [0,80],
	      2 => [10,80],
 	      3 => [20,100],
	      4 => [30,100],
 	     );
  check_times($_[0],\%diff);
}

sub check_time5 {
  str_rdiff(@_[0],[
		   "Start of foo.",
		   "End of foo at 1000.",
		   "Done.",
		   ]);
}

##
## </TESTS>
##
