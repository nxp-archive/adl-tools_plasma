#!/usr/bin/env perl 
# -- -*-perl-*-a
#
# Tests used in this regression.

use lib "..";
use rdriver;
use strict;

my @Tests = (
	     # Basic par block test.
	     {
	      cmd     => "./par1",
	      checker => \&check_par1,
	     },
	     # Looping par block test.
	     {
	      cmd     => "./par2",
	      checker => \&check_par2,
	     },
	     # Looping par block test with structure as loop variable.
	     {
	      cmd     => "./par3",
	      checker => \&check_par3,
	     },
	     # Quicksort with parallel sorting of split elements.
	     {
	      cmd     => "./qsort",
	      checker => \&check_qsort,
	     },
	     # Channel test directly using C++ interface.
	     {
	      cmd     => "./chan1",
	      checker => \&check_chan1,
	     },
	     # Channel test using alt.
	     {
	      cmd     => "./chan2",
	      checker => \&check_chan2,
	     },
	     # Channel test using alt with a default block.
	     {
	      cmd     => "./chan3",
	      checker => \&check_chan3,
	     },
	     # Channel test using afor.
	     {
	      cmd     => "./chan4",
	      checker => \&check_chan4,
	     },
	     # Channel test using afor and a non-integer iterator.
	     {
	      cmd     => "./chan5",
	      checker => \&check_chan5,
	     },
	     # Channel test using afor and a default block.
	     {
	      cmd     => "./chan6",
	      checker => \&check_chan6,
	     },
	     # Channel test using afor, non-integer iterator, and a default block.
	     {
	      cmd     => "./chan7",
	      checker => \&check_chan7,
	     },
	     # Spawn test- C++ only.
	     {
	      cmd     => "./spawn1",
	      checker => \&check_spawn1,
	     },
	     # Spawn test with spawn operator.
	     {
	      cmd     => "./spawn2",
	      checker => \&check_spawn2,
	     },
	     # Spawn test with member calls.
	     {
	      cmd     => "./spawn3",
	      checker => \&check_spawn3,
	     },
	    );

doTest(\@Tests);

# We make sure that we get the result values we expect, since this will
# ensure that we waited until the threads in the par block were finished.
# We also make sure that the block statements are interleavedd, to make sure
# that we're getting timeslicing.
sub check_par1 {
  my @lines = split /\n/,@_[0];
  my ($er1,$er2,$er3) = (69,200,1000);
  my ($r1,$r2,$r3) = (0,0,0);
  my $cb1 = 0;
  for (@lines) {
    if (/^Result1:\s+(\d+),\s+Result2:\s+(\d+),\s+Result3:\s+(\d+)/) {
      ($r1,$r2,$r3) = ($1,$2,$3);
    } elsif ( /^In block 1./ ) {
      ++$cb1;
      if ($cb1 >= 8) {
	die "Expected to find interleaved block statements but did not.\n";
      }
    } elsif ( /^In block 2./ ) {
      $cb1 = 0;
    }
  }
  if ($r1 != $er1) {
    die "Expected Result1 to be $er1, got $r1 instead.\n";
  }
  if ($r2 != $er2) {
    die "Expected Result2 to be $er2, got $r2 instead.\n";
  }
  if ($r3 != $er3) {
    die "Expected Result3 to be $er3, got $r3 instead.\n";
  }
}

# Pretty much the same as check_par1, except slightly different data is expected.
sub check_par2 {
  my @lines = split /\n/,@_[0];
  my @exp = (2000,1999,1998,1997,1996);
  my $expnb = 5;
  my @cb = (0) x 10;
  my $lb = -1;
  for (@lines) {
    if ( /^In block (\d+)./ ) {
      my $b = $1;
      if ($b != $lb) {
	$cb[$b] = 0;
      } else {
	$cb[$b]++;
      }
      if ($cb[$b] >= 8) {
	die "Expected to find interleaved block statements but did not.\n";
      }
      $lb = $b;
    } elsif ( /Num blocks:\s+(\d+)/) {
      if ($1 != $expnb) {
	die "Expected number of blocks answer to be $expnb.\n";
      }
    } elsif ( /^Result/ ) {
      my @res = ( /Result\[\d+\]:\s+(\d+)/g );
      for my $i (0..$#exp) {
	if ($res[$i] != $exp[$i]) {
	  die "Mismatch on result value $i (Found $res[$i], expected $exp[$i]).\n";
	}
      }
    }
  }
}

# Pretty much the same as check_par2, except slightly different data is expected.
sub check_par3 {
  my @lines = split /\n/,@_[0];
  my $start = 101;
  for (@lines) {
    if ( /^Result/ ) {
      my @res = ( /Result\[\d+\]:\s+(\d+.\d+)/g );
      for my $i (0..$#res) {
	if ($res[$i] != $start) {
	  die "Mismatch on result value $i (Found $res[$i], expected $start).\n";
	}
	$start += 2;
      }
    }
  }
}

# Just make sure that we got the right number of messages.
# The checking of the sorting is down by the program itself.
sub check_qsort {
  my @lines = split /\n/,@_[0];
  my $elc = 25;
  my $lc = 0;
  for (@lines) {
    ++$lc if ( /^Sorting with size/);
  }
  if ($lc != $elc) {
    die "Expected to have $elc sorts done, found only $lc.\n";
  }
}

sub check_chan1 {
  my @data = ([10,10],[100,10],[1000,10],[10000,10]);
  check_channel (@_[0],"Data read from channel (\\d+):\\s+(\\d+)",\@data,5);
}

sub check_chan2 {
  my @data = ([10,10],[100,10],[1000,10],[10000,10]);
  check_channel (@_[0],"Got a value from port c(\\d+):\\s+(\\d+)",\@data,5);
}

sub check_chan3 {
  my @data = ([10,10]);
  check_channel (@_[0],"Got a value from port c(\\d+):\\s+(\\d+)",\@data,2,[ "No value present."]);
}

sub check_chan4 {
  my @data = ([20,10],[200,10],[2000,10],[20000,10],[200000,10],[2000000,10]);
  check_channel (@_[0],"Got a value from port (\\d+):\\s+(\\d+)",\@data,7);
}

sub check_chan5 {
  my @data = ([30,10],[300,10],[3000,10],[30000,10],[300000,10],[3000000,10]);
  check_channel (@_[0],"Got a value from port (\\d+):\\s+(\\d+)",\@data,7);
}

sub check_chan6 {
  my @data = ([20,10],[200,10]);
  check_channel (@_[0],"Got a value from port (\\d+):\\s+(\\d+)",\@data,3,[ "No value present."]);
}

sub check_chan7 {
  my @data = ([30,10],[300,10],[3000,10]);
  check_channel (@_[0],"Got a value from port (\\d+):\\s+(\\d+)",\@data,4,[ "No value present."]);
}

# Make sure that all expected integers are received.  These should
# be four sets of ten integers starting at 10, 100, 1000, and 10000.
sub check_channel {
  my ($input,$regex,$data,$expNumFinish,$expstr) = (shift,shift,shift,shift,shift);
  my %exphash = ();
  for my $i ( @{ $expstr } ) {
    $exphash{$i} = 0;
  }
  my @lines = split /\n/,$input;
  my $max = 10;
  my $numFinish = 0;
  dprint "Regex:  $regex\n";
  for (@lines) {
    dprint "Line:  $_\n";
    if ( /$regex/ ) {
      my $chan = $1;
      my $val = $2;
      dprint "Read $val from channel $chan.\n";
      if ($val >= $data->[$chan]->[0] && $val < ($data->[$chan]->[0]+$max)) {
	--($data->[$chan]->[1]);
      } else {
	print "Data out of bound for channel $chan:  Got $val, expected value in [",
	  $data->[$chan]->[0],":",($data->[$chan]->[0]+$max),").\n";
	die;
      }
    } elsif ( /(Producer|Consumer) done./ ) {
      ++$numFinish;
    }
    for my $k (keys %exphash ) {
      if ( /$k/ ) {
	++$exphash{$k};
      }
    }
  }
  if ($numFinish != $expNumFinish) {
    print "Expected $expNumFinish threads to finish, found only $numFinish.\n";
    die;
  }
  for my $i (0..(scalar @{$data} - 1)) {
    if ($data->[$i]->[1]) {
      print "Not all data was found for channel $i.\n";
      die;
    }
  }
  for my $i (keys %exphash) {
    if (!$exphash{$i}) {
      print "Expected to find an occurrance of \"$i\" but did not.\n";
      die;
    }
  }
}

# Makes sure expected results are found.
sub check_spawn {
  my @lines = split /\n/,shift;
  my @parms = @_;
  my $expcount = scalar(@parms);
  my $ix = 0;
  for (@lines) {
    if ( /^Result is:/ ) {
      my @res = ( /(\d+.\d+)/g );
      my $exp = $parms[$ix];
      for my $i (0..scalar(@{$exp})-1) {
	if ($res[$i] != $exp->[$i]) {
	  die "Mismatch on result value $i (Found $res[$i], expected $exp->[$i]).\n";
	}
      }
      ++$ix;
    }
  }
  if ($ix != $expcount) {
    die "Expected $expcount result lines, found $ix.\n";
  }
}

sub check_spawn1 {
  my @exp = ( 6.05, 103.33, 10103.1 );
  check_spawn($_[0], \@exp);
}

sub check_spawn2 {
  my @exp = ( 6.05, 103.33, 10103.1, 3.14159 );
  check_spawn($_[0], \@exp);
}

sub check_spawn3 {
  my @exp1 = ( 6.05, 103.33, 10103.0906, 3.14159 );
  my @exp2 = ( 25, 50100.05, 3.14159 );
  check_spawn($_[0], \@exp1,\@exp2);
}
