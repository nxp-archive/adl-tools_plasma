#!/usr/bin/env perl 
# -- -*-perl-*-a
#
# Tests used in this regression.

use lib "..";
use rdriver;
use strict;
use Data::Dumper;

my @Tests = (
	     # Basic par block test.
	     {
	      cmd     => "./par1",
	      checker => \&check_par1,
	     },
	     # Looping par block test.
	     {
	      cmd     => "./par2",
	      checker => \&check_par2,
	     },
	     # Looping par block test with structure as loop variable.
	     {
	      cmd     => "./par3",
	      checker => \&check_par3,
	     },
	     # Quicksort with parallel sorting of split elements.
	     {
	      cmd     => "./qsort",
	      checker => \&check_qsort,
	     },
	     # Channel test directly using C++ interface.
	     {
	      cmd     => "./chan1",
	      checker => \&check_chan1,
	     },
	     # Channel test using alt.
	     {
	      cmd     => "./chan2",
	      checker => \&check_chan2,
	     },
	     # Channel test using alt with a default block.
	     {
	      cmd     => "./chan3",
	      checker => \&check_chan3,
	     },
	     # Channel test using afor.
	     {
	      cmd     => "./chan4",
	      checker => \&check_chan4,
	     },
	     # Channel test using afor and a non-integer iterator.
	     {
	      cmd     => "./chan5",
	      checker => \&check_chan5,
	     },
	     # Channel test using afor and a default block.
	     {
	      cmd     => "./chan6",
	      checker => \&check_chan6,
	     },
	     # Channel test using afor, non-integer iterator, and a default block.
	     {
	      cmd     => "./chan7",
	      checker => \&check_chan7,
	     },
	     # Channel test using a queued channel.
	     {
	      cmd     => "./chan8",
	      checker => \&check_chan8,
	     },
	     # Channel test using a queued channel with a fixed size.
	     {
	      cmd     => "./chan9",
	      checker => \&check_chan9,
	     },
	     # Channel test w/multiple afor and alts in an alt.
	     {
	      cmd     => "./chan10",
	      checker => \&check_chan10,
	     },
	     # Channel test w/multiple afor and alts in an alt and a default block
	     {
	      cmd     => "./chan11",
	      checker => \&check_chan11,
	     },
	     # Spawn test- C++ only.
	     {
	      cmd     => "./spawn1",
	      checker => \&check_spawn1,
	     },
	     # Spawn test with spawn operator.
	     {
	      cmd     => "./spawn2",
	      checker => \&check_spawn2,
	     },
	     # Spawn test with member calls.
	     {
	      cmd     => "./spawn3",
	      checker => \&check_spawn3,
	     },
	     # Spawn test with alt.
	     {
	      cmd     => "./spawn4",
	      checker => \&check_spawn4,
	     },
	     # Mutex test w/shared data structure.
	     {
	      cmd     => "./mutex1",
	      checker => \&check_mutex1,
	     },
	     # Test of priorities.
	     {
	      cmd     => "./pri1",
	      checker => \&check_pri1,
	     },
	     # Test of priorities.
	     {
	      cmd     => "./pri2",
	      checker => \&check_pri2,
	     },
	    );

doTest(\@Tests);

# We make sure that we get the result values we expect, since this will
# ensure that we waited until the threads in the par block were finished.
# We also make sure that the block statements are interleavedd, to make sure
# that we're getting timeslicing.
sub check_par1 {
  my @lines = split /\n/,@_[0];
  my ($er1,$er2,$er3) = (69,200,1000);
  my ($r1,$r2,$r3) = (0,0,0);
  my $cb1 = 0;
  for (@lines) {
    if (/^Result1:\s+(\d+),\s+Result2:\s+(\d+),\s+Result3:\s+(\d+)/) {
      ($r1,$r2,$r3) = ($1,$2,$3);
    } elsif ( /^In block 1./ ) {
      ++$cb1;
      if ($cb1 >= 8) {
	die "Expected to find interleaved block statements but did not.\n";
      }
    } elsif ( /^In block 2./ ) {
      $cb1 = 0;
    }
  }
  if ($r1 != $er1) {
    die "Expected Result1 to be $er1, got $r1 instead.\n";
  }
  if ($r2 != $er2) {
    die "Expected Result2 to be $er2, got $r2 instead.\n";
  }
  if ($r3 != $er3) {
    die "Expected Result3 to be $er3, got $r3 instead.\n";
  }
}

# Pretty much the same as check_par1, except slightly different data is expected.
sub check_par2 {
  my @lines = split /\n/,@_[0];
  my @exp = (2000,1999,1998,1997,1996);
  my $expnb = 5;
  my @cb = (0) x 10;
  my $lb = -1;
  for (@lines) {
    if ( /^In block (\d+)./ ) {
      my $b = $1;
      if ($b != $lb) {
	$cb[$b] = 0;
      } else {
	$cb[$b]++;
      }
      if ($cb[$b] >= 8) {
	die "Expected to find interleaved block statements but did not.\n";
      }
      $lb = $b;
    } elsif ( /Num blocks:\s+(\d+)/) {
      if ($1 != $expnb) {
	die "Expected number of blocks answer to be $expnb.\n";
      }
    } elsif ( /^Result/ ) {
      my @res = ( /Result\[\d+\]:\s+(\d+)/g );
      for my $i (0..$#exp) {
	if ($res[$i] != $exp[$i]) {
	  die "Mismatch on result value $i (Found $res[$i], expected $exp[$i]).\n";
	}
      }
    }
  }
}

# Pretty much the same as check_par2, except slightly different data is expected.
sub check_par3 {
  my @lines = split /\n/,@_[0];
  my $start = 101;
  for (@lines) {
    if ( /^Result/ ) {
      my @res = ( /Result\[\d+\]:\s+(\d+.\d+)/g );
      for my $i (0..$#res) {
	if ($res[$i] != $start) {
	  die "Mismatch on result value $i (Found $res[$i], expected $start).\n";
	}
	$start += 2;
      }
    }
  }
}

# Just make sure that we got the right number of messages.
# The checking of the sorting is down by the program itself.
sub check_qsort {
  my @lines = split /\n/,@_[0];
  my $elc = 25;
  my $lc = 0;
  for (@lines) {
    ++$lc if ( /^Sorting with size/);
  }
  if ($lc != $elc) {
    die "Expected to have $elc sorts done, found only $lc.\n";
  }
}

# Make sure that all expected integers are received.
sub check_channel {
  my ($input,$regex,$odata,$expNumFinish,$expstr) = (shift,shift,shift,shift,shift);
  # Store expected expressions in a hash.
  my %exphash;
  if ($expstr) {
    @exphash{@$expstr} = (0) x @$expstr;
  }
  # Convert array of arrays into an array of hashes.
  my @data;
  for my $i ( @{ $odata } ) {
    my %hash;
    @hash{@$i} = (1) x @$i;
    push @data,\%hash;
  }
  dprint "Expected data:  ",Dumper(\@data),"\n";
  my @lines = split /\n/,$input;
  my $max = 10;
  my $numFinish = 0;
  dprint "Regex:  $regex\n";
  for (@lines) {
    dprint "Line:  $_\n";
    if ( /$regex/ ) {
      my ($chan,$val) = (eval $1,eval $2);
      dprint "Read $val from channel $chan.\n";
      if ( exists $data[$chan]->{$val} ) {
	delete $data[$chan]->{$val};
      } else {
	print "Data out of bound for channel $chan:  Got $val, expected data left:  ",
	  join(',',keys(%{ $data[$chan] })),"\n";
	die;
      }
    } elsif ( /(Producer|Consumer) done./ ) {
      ++$numFinish;
    }
    for my $k (keys %exphash ) {
      if ( /$k/ ) {
	++$exphash{$k};
      }
    }
  }
  if ($expNumFinish) {
    if ($numFinish != $expNumFinish) {
      print "Expected $expNumFinish threads to finish, found only $numFinish.\n";
      die;
    }
  }
  for my $i (0..$#data) {
    if (keys(%{$data[$i]})) {
      print "Not all data was found for channel $i:  ",join(',',keys(%{ $data[$i] })),"\n";
      die;
    }
  }
  for my $i (keys %exphash) {
    if (!$exphash{$i}) {
      print "Expected to find an occurrance of \"$i\" but did not.\n";
      die;
    }
  }
}

# Make sure that all expected integers are received.
sub check_qchannel {
  my ($input,$regex,$data,$expNumFinish,$expregex,$expmax) = (shift,shift,shift,shift,shift,shift);

  my %alldata = ();
  for my $i (@$data) {
    for my $j (@$i) {
      $alldata{$j} = 1;
    }
  }

  my @lines = split /\n/,$input;
  my $max = 10;
  my $numFinish = 0;
  my $exprcount = 0;
  dprint "Regex:  $regex\n";
  dprint "Check regex:  $expregex\n";
  dprint "Expected data:  ",join(' ',keys %alldata),"\n";
  for (@lines) {
    dprint "Line:  $_\n";
    if ( /$regex/ ) {
      my $val = eval $1;
      dprint "Read $val from channel.\n";
      if (!(exists $alldata{$val})) {
	print "Found unexpected data value $val.\n";
	die;
      }
      delete $alldata{$val};
    } elsif ( /(Producer|Consumer) done./ ) {
      ++$numFinish;
    } elsif ( $expregex && /$expregex/ ) {
      ++$exprcount;
      if ($1 > $expmax) {
	print "Exceeeded maximum check count of $expmax.\n";
	die;
      }
    }
  }
  if ($expNumFinish) {
    if ($numFinish != $expNumFinish) {
      print "Expected $expNumFinish threads to finish, found only $numFinish.\n";
      die;
    }
  }
  if (scalar(keys %alldata)) {
    die "Did not find all required data:  ",join(' ',keys %alldata),"\n";
  }
  if ($expregex && !$exprcount) {
    die "Found no occurrance of required check expression.\n";
  }
}

sub check_chan1 {
  my @data = ([10..19],[100..109],[1000..1009],[10000..10009]);
  check_channel (@_[0],"Data read from channel (\\d+):\\s+(\\d+)",\@data,5);
}

sub check_chan2 {
  my @data = ([10..19],[100..109],[1000..1009],[10000..10009]);
  check_channel (@_[0],"Got a value from port c(\\d+):\\s+(\\d+)",\@data,5);
}

sub check_chan3 {
  my @data = ([10..19]);
  check_channel (@_[0],"Got a value from port c(\\d+):\\s+(\\d+)",\@data,2,[ "No value present."]);
}

sub check_chan4 {
  my @data = ([20..29],[200..209],[2000..2009],[20000..20009],[200000..200009],[2000000..2000009]);
  check_channel (@_[0],"Got a value from port (\\d+):\\s+(\\d+)",\@data,7);
}

sub check_chan5 {
  my @data = ([30..39],[300..309],[3000..3009],[30000..30009],[300000..300009],[3000000..3000009]);
  check_channel (@_[0],"Got a value from port (\\d+):\\s+(\\d+)",\@data,7);
}

sub check_chan6 {
  my @data = ([20..29],[200..209]);
  check_channel (@_[0],"Got a value from port (\\d+):\\s+(\\d+)",\@data,3,[ "No value present."]);
}

sub check_chan7 {
  my @data = ([30..39],[300..309],[3000..3009]);
  check_channel (@_[0],"Got a value from port (\\d+):\\s+(\\d+)",\@data,4,[ "No value present."]);
}

sub check_chan8 {
  my @data = ([10..19],[100..109],[1000..1009],[10000..10009]);
  check_qchannel (@_[0],"Read a value:\\s+(\\d+)",\@data,5);
}

sub check_chan9 {
  my @data = ([10..19],[100..109],[1000..1009],[10000..10009]);
  check_qchannel (@_[0],"Read a value:\\s+(\\d+)",\@data,5,"Queue size:\\s+(\\d+)",3);
}

sub check_chan10 {
  my @data = ([60..69],
	      [20..29],
	      [200..209],
	      [2000..2009],
	      [20000..20009],
	      [200000..200009],
	      [2000000..2000009],
	      [2.3, 3.3, 4.3, 5.3, 6.3, 7.3, 8.3, 9.3, 10.3, 11.3 ],
	      [3.45, 4.45, 5.45, 6.45, 7.45, 8.45, 9.45, 10.45, 11.45, 12.45],
	      [5.175, 6.175, 7.175, 8.175, 9.175, 10.175, 11.175, 12.175, 13.175, 14.175],
	      [7.7625, 8.7625, 9.7625, 10.7625, 11.7625, 12.7625, 13.7625, 14.7625, 15.7625, 16.7625]
	      );
  check_channel (@_[0],"Got a value from port (\\d+):\\s+(\\d+\.?\\d*)",\@data,12);
}

sub check_chan11 {
  my @data = ([60..69],
	      [20..29],
	      [200..209],
	      [2000..2009],
	      [20000..20009],
	      [200000..200009],
	      [2000000..2000009],
	      [2.3, 3.3, 4.3, 5.3, 6.3, 7.3, 8.3, 9.3, 10.3, 11.3 ],
	      [3.45, 4.45, 5.45, 6.45, 7.45, 8.45, 9.45, 10.45, 11.45, 12.45],
	      [5.175, 6.175, 7.175, 8.175, 9.175, 10.175, 11.175, 12.175, 13.175, 14.175],
	      [7.7625, 8.7625, 9.7625, 10.7625, 11.7625, 12.7625, 13.7625, 14.7625, 15.7625, 16.7625]
	      );
  check_channel (@_[0],"Got a value from port (\\d+):\\s+(\\d+\.?\\d*)",\@data,12,["No value present."]);
}

# Makes sure expected results are found.
sub check_spawn {
  my @lines = split /\n/,shift;
  my @parms = @_;
  my $expcount = scalar(@parms);
  my $ix = 0;
  for (@lines) {
    if ( /^Result is:/ ) {
      my @res = ( /(\d+.\d+)/g );
      my $exp = $parms[$ix];
      for my $i (0..scalar(@{$exp})-1) {
	if ($res[$i] != $exp->[$i]) {
	  die "Mismatch on result value $i (Found $res[$i], expected $exp->[$i]).\n";
	}
      }
      ++$ix;
    }
  }
  if ($ix != $expcount) {
    die "Expected $expcount result lines, found $ix.\n";
  }
}

sub check_spawn1 {
  my @exp = ( 6.05, 103.33, 10103.1 );
  check_spawn($_[0], \@exp);
}

sub check_spawn2 {
  my @exp1 = ( 6.05, 103.33, 10103.1, 3.14159 );
  my @exp2 = ( 10204.4, 3.14159 );
  my @exp3 = ( 0 );
  check_spawn($_[0], \@exp1, \@exp2, \@exp3 );
}

sub check_spawn3 {
  my @exp1 = ( 6.05, 103.33, 10103.0906, 3.14159 );
  my @exp2 = ( 25, 50100.05, 4905, 6961.16 );
  my @exp3 = ( 2.718282, 2.718282, 3.141590, 2.718282, 2.718282 );
  check_spawn($_[0], \@exp1,\@exp2,\@exp3);
}

sub check_spawn2 {
  my @exp1 = ( 6.05, 103.33, 10103.1, 3.14159 );
  my @exp2 = ( 10204.4, 3.14159 );
  my @exp3 = ( 0 );
  check_spawn($_[0], \@exp1, \@exp2, \@exp3 );
}

sub check_spawn4 {
  my @data = (6.05,15.73,216);
  my @lines = split /\n/,shift;
  my ($expected,$found) = (3,0);
  for (@lines) {
    if (/r(\d+):\s+(\d+\.?\d*)/) {
      my ($p,$d) = (eval $1,eval $2);
      ++$found;
      if ( $data[$p] != $d ) {
	die "Expected $data[$p] for channel $p, got instead $d.\n";
      }
    }
  }
  if ($found != $expected) {
    die "Expected $expected items, found $found.\n";
  }
}

# We check to make sure that each number is only received once and that we get
# all expected numbers.
sub check_mutex1 {
  my @lines = split /\n/,shift;
  my %data;
  my %done = ( "Producer"  => 0,
	       "Consumer" => 0,
	       "pMain" => 0 );
  @data{0..999} = (0) x 1000;
  for (@lines) {
    if ( /Q result:\s+(\d+)/ ) {
      ++$data{$1};
    } elsif ( /(\S+)\s+done/ ) {
      ++$done{$1};
    }
  }
  for my $i (keys (%data)) {
    if ($data{$i} != 1) {
      die "Bad data count for item $i:  $data{$i}.\n";
    }
  }
  for my $i (keys (%done)) {
    if ($done{$i} != 1) {
      die "Bad done count for item $i:  $done{$i}.\n";
    }
  }
}

# Thread execution sequence checker.
sub check_sequence {
  my ($input,$seq,$count) = (shift,shift,shift);
  my @lines = split /\n/,$input;
  
  # In addition to counting the number of occurrances from
  # the count array, we make sure that each key has a corresponding
  # done line in the input.
  my %done;
  @done{keys(%$count)} = (1) x keys(%$count);

  my $iseq;
  for (@lines) {
    if ( /In block (\d+\.?\d*)/ ) {
      my $b = eval $1;
      $iseq .= "$b ";
      --($count->{$b});
    } elsif ( /Done with block (\d+\.?\d*)/ ) {
      my $b = eval $1;
      --$done{$b};
    }
  }

  if ( $iseq !~ $seq) {
    print "Error:  Bad sequence.  Expected '$seq', found '$iseq'.\n";
    die;
  }

  for my $i (keys(%done)) {
    if ($done{$i}) {
      print "Error:  Did not find a done message for block $i.\n";
      die;
    }
  }

  for my $i (keys(%$count)) {
    if ($count->{$i}) {
      print "Error:  Did not find a expected number of messages from block $i:  Expected $count->{$i} more.\n";
      die;
    }
  }

}

# Test priority sequence.
sub check_pri1 {
  my $seq = "(1 )+(1\\.1 )+(1\\.2 )+(2 )+(2\\.1 )+(2\\.2 )+(4 |3 )+(3\\.1 )+(4 )*";;
  my %count = (
	       1.0 => 20, 
	       1.1 => 4, 
	       1.2 => 4,
	       2.0 => 20,
	       2.1 => 4,
	       2.2 => 4,
	       3.0 => 10,
	       3.1 => 10,
	       4.0 => 15 
	      );
  check_sequence(@_[0],$seq,\%count);
}

# Test priority sequence.
sub check_pri2 {
  my $seq = "(1 |3 |4 )+(2 )+(1 |3 |4 )+";;
  my %count = (
	       1.0 => 10, 
	       2.0 => 30,
	       3.0 => 10,
	       4.0 => 10,
	      );
  check_sequence(@_[0],$seq,\%count);
};
