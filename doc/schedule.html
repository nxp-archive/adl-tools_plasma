<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="trip.prl release 1.2.2" />
<title>Plasma Development Schedule</title>
<meta name="author" content="Brian Kahne" />
<link rel="stylesheet" href="http://docutils.sourceforge.net/tools/stylesheets/default.css" type="text/css" />
</head>
<body>
<div class="document" id="plasma-development-schedule">
<h1 class="title">Plasma Development Schedule</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Brian Kahne</td></tr>
<tr><th class="docinfo-name">Contact:</th>
<td><a class="first last reference" href="mailto:bkahne&#64;freescale.com">bkahne&#64;freescale.com</a></td></tr>
<tr><th class="docinfo-name">Revision:</th>
<td><tt class="literal"><span class="pre">$Id$</span></tt></td></tr>
</tbody>
</table>
<p>This document describes PLASMA's development schedule.  It consists of a series
of entries, each representing a feature to be added.  A feature is considered
complete when its functionality, documentation, and corresponding regression
tests have been committed to CVS.  The list is in chronological order but this
order may change based upon external factors.</p>
<div class="contents topic" id="contents">
<p class="topic-title"><a name="contents">Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#par-block" id="id1" name="id1">Par Block</a></li>
<li><a class="reference" href="#pfor-block" id="id2" name="id2">Pfor block</a></li>
<li><a class="reference" href="#channels-basic-alt-block" id="id3" name="id3">Channels (Basic Alt block)</a></li>
<li><a class="reference" href="#looping-alt-block" id="id4" name="id4">Looping Alt Block</a></li>
<li><a class="reference" href="#garbage-collection" id="id5" name="id5">Garbage Collection</a></li>
<li><a class="reference" href="#spawn-operator" id="id6" name="id6">Spawn Operator</a></li>
<li><a class="reference" href="#shared-data-structures" id="id7" name="id7">Shared Data Structures</a></li>
<li><a class="reference" href="#time-model" id="id8" name="id8">Time Model</a></li>
<li><a class="reference" href="#kernel-threads" id="id9" name="id9">Kernel Threads</a></li>
</ul>
</div>
<div class="section" id="par-block">
<h1><a class="toc-backref" href="#id1" name="par-block">Par Block</a></h1>
<p>Status:</p>
<blockquote>
Completed 4/23/2004</blockquote>
<p>Description:</p>
<blockquote>
A par block launches each of its constituent expressions as separate
threads.  It proceeds only when all threads are finished.</blockquote>
<p>Implementation:</p>
<blockquote>
<ol class="arabic simple">
<li>The block will be converted such that each expression becomes its own
subroutine.  The parameter passed in will be a structure whose members
are pointers to any variables used by the expression.</li>
<li>Each thread will be launched via a call to pCreate.  Then a call to
pWait will exist for each thread.</li>
</ol>
</blockquote>
<p>Dependencies:</p>
<blockquote>
<ol class="arabic simple">
<li>Thread library.</li>
<li>Parser is able to parse &quot;plain&quot; block structures.</li>
</ol>
</blockquote>
<p>Regressions:</p>
<blockquote>
<ol class="arabic simple">
<li>basic/par1.pa</li>
<li>basic/qsort.pa</li>
</ol>
</blockquote>
</div>
<div class="section" id="pfor-block">
<h1><a class="toc-backref" href="#id2" name="pfor-block">Pfor block</a></h1>
<p>Status:</p>
<blockquote>
Completed 4/29/2004</blockquote>
<p>Description:</p>
<blockquote>
For-loop syntax, where body of the loop is launched as a thread.  Construct
blocks until all threads are finished.</blockquote>
<p>Implementation:</p>
<blockquote>
Same as for par block, except that the argument structure is allocated on
the thread's stack structure.  Each variable declared in loop's guard is
passed by value, while everything else is passed by reference.</blockquote>
<p>Dependencies:</p>
<blockquote>
<ol class="arabic simple">
<li>Thread library.</li>
<li>Parser is able to parse &quot;plain&quot; block structures.</li>
</ol>
</blockquote>
<p>Regressions:</p>
<blockquote>
<ol class="arabic simple">
<li>basic/par2.pa</li>
<li>basic/par3.pa</li>
</ol>
</blockquote>
</div>
<div class="section" id="channels-basic-alt-block">
<h1><a class="toc-backref" href="#id3" name="channels-basic-alt-block">Channels (Basic Alt block)</a></h1>
<p>Status:</p>
<blockquote>
Scheduled for 5/14/2004</blockquote>
<p>Description:</p>
<blockquote>
<p>Define channel interface and implement basic alt block.  The alt block is
like a case statement, except that each condition is a channel variable and
a variable to map the channel's return value to.  The block blocks until one
of the channels has data.  It then reads that data, maps it to the variable,
and executes the code associated with that guard.</p>
<p>Basic syntax is:</p>
<pre class="literal-block">
alt {
  with(chan1,x): ....
  with(chan2,x): ....
}
</pre>
</blockquote>
<p>Implementation:</p>
<blockquote>
<p>A channel will be any type that has the required interface.  This is
compile-time polymorphism, similar to how templates work.  The required
interface is as follows.  For a channel of type T:</p>
<ol class="arabic">
<li><dl class="first">
<dt><tt class="literal"><span class="pre">T</span> <span class="pre">read()</span></tt>:  Returns a value read from the channel.  Blocks if no value is</dt>
<dd>present.  Returns the last value read, until clear_ready() is called.</dd>
</dl>
</li>
<li><dl class="first">
<dt><tt class="literal"><span class="pre">T</span> <span class="pre">get()</span></tt>:  Returns a value from the channel.  Blocks if no value is</dt>
<dd>present.  Always fetches a new value.  After a call to this, read() will
return this same value.</dd>
</dl>
</li>
<li><dl class="first">
<dt><tt class="literal"><span class="pre">void</span> <span class="pre">write(T)</span></tt>:  Writes a value to the channel.  May block, depending</dt>
<dd>upon the channel definition.</dd>
</dl>
</li>
<li><p class="first"><tt class="literal"><span class="pre">bool</span> <span class="pre">ready()</span> <span class="pre">const</span></tt>:  Returns true if the channel has a value.</p>
</li>
<li><dl class="first">
<dt><tt class="literal"><span class="pre">void</span> <span class="pre">clear_ready()</span></tt>:  Clears the ready status, forcing the fetch of a new</dt>
<dd>value.</dd>
</dl>
</li>
<li><dl class="first">
<dt><tt class="literal"><span class="pre">set_notify(Thread</span> <span class="pre">*t,int</span> <span class="pre">handle)</span></tt>:  Stores the thread and handle.  When</dt>
<dd>the channel gets a value, it will wake this thread, giving it the handle.</dd>
</dl>
</li>
<li><dl class="first">
<dt><tt class="literal"><span class="pre">clear_notify()</span></tt>:  Clears the stored thread so that no notification will</dt>
<dd>take place if a value is written to the channel.</dd>
</dl>
</li>
</ol>
<p>Some details about channel implementation:</p>
<ol class="arabic">
<li><dl class="first">
<dt>Call pSleep() to block.  You must have stored a handle to the current</dt>
<dd>thread somewhere else before this call, e.g. storing it in a channel
member variable.</dd>
</dl>
</li>
<li><dl class="first">
<dt>Call pWake() to awaken a thread.  The general protocol is that the waker</dt>
<dd>clears the thread member variable of the channel and it does this
<em>before</em> the call to pWake.</dd>
</dl>
</li>
<li><dl class="first">
<dt>Call pAddReady() to add a thread to the ready queue, but not make it</dt>
<dd>active.  No switching occurs (assuming processor is locked to avoid
preemption).</dd>
</dl>
</li>
<li><dl class="first">
<dt>A call to read() or get() should clear any notification.  Thus, with an</dt>
<dd>alt block, only the channels that had set_notify() called need to have
clear_notify() called if a ready channel is found.  The actual ready
channel should not have clear_notify() called, since there could be a
blocked writer waiting to go.</dd>
</dl>
</li>
</ol>
<p>Code conversion for the alt block will be:</p>
<ol class="arabic">
<li><p class="first">Shutdown preemption.</p>
</li>
<li><dl class="first">
<dt>Loop through all channels- if anything is ready, save handle and exit</dt>
<dd>loop.  Else, call set_notify with current thread and handle (integer
index of loop).</dd>
</dl>
</li>
<li><p class="first">If nothing ready, sleep.</p>
</li>
<li><dl class="first">
<dt>Case statement on return value of sleep, or index value from loop in</dt>
<dd>(2).  Execute relevant code.</dd>
</dl>
</li>
<li><dl class="first">
<dt>Call clear_notify on all threads.  Do this within a catch(...) block,</dt>
<dd>too.</dd>
</dl>
</li>
<li><p class="first">Alt blocks consume values, i.e. they call get().</p>
</li>
</ol>
</blockquote>
<p>Dependencies:</p>
<blockquote>
<ol class="arabic">
<li><p class="first">Need channel definition</p>
</li>
<li><dl class="first">
<dt>Add <tt class="literal"><span class="pre">int</span> <span class="pre">pSleep()</span></tt>: Puts the thread to sleep.  Returns integer when thread</dt>
<dd>wakes.</dd>
</dl>
</li>
<li><p class="first">Add <tt class="literal"><span class="pre">void</span> <span class="pre">pWake(Thread</span> <span class="pre">*t,int</span> <span class="pre">h)</span></tt>:  Wakes thread, giving it h.</p>
</li>
</ol>
</blockquote>
<p>Regressions:</p>
<blockquote>
TBD</blockquote>
</div>
<div class="section" id="looping-alt-block">
<h1><a class="toc-backref" href="#id4" name="looping-alt-block">Looping Alt Block</a></h1>
<p>Status:</p>
<blockquote>
TBD</blockquote>
<p>Description:</p>
<blockquote>
TBD</blockquote>
<p>Implementation:</p>
<blockquote>
TBD</blockquote>
<p>Dependencies:</p>
<blockquote>
TBD</blockquote>
<p>Regressions:</p>
<blockquote>
TBD</blockquote>
</div>
<div class="section" id="garbage-collection">
<h1><a class="toc-backref" href="#id5" name="garbage-collection">Garbage Collection</a></h1>
<p>Status:</p>
<blockquote>
TBD</blockquote>
<p>Description:</p>
<blockquote>
Plasma is going to have a lot of producer/consumer type code, where the
ownership of a particular piece of memory will be hard to track.  Garbage
collection will make the code much easier to understand and less error-prone.</blockquote>
<p>Implementation:</p>
<blockquote>
Boehm garbage collector.</blockquote>
<p>Dependencies:</p>
<blockquote>
The main issue is getting it to handle user-threads.  It handles kernel
threads and should be able to handle user-threads, but I don't know how to
do it yet.</blockquote>
<p>Regressions:</p>
<blockquote>
TBD</blockquote>
</div>
<div class="section" id="spawn-operator">
<h1><a class="toc-backref" href="#id6" name="spawn-operator">Spawn Operator</a></h1>
<p>Status:</p>
<blockquote>
TBD</blockquote>
<p>Description:</p>
<blockquote>
<p>Thread creation w/o synchronization, e.g.:</p>
<pre class="literal-block">
spawn foo(1,2,3);
</pre>
<p>Evaluates the argument (must resolve to a function or an object's member
invocation).  The argument is launched as a thread.  The return value is an
object which meets the specifications of a channel.  It will also have
additional operators for thread control:</p>
<ol class="arabic simple">
<li>wait():  Wait for thread to finish.</li>
<li>kill():  Kill thread.</li>
</ol>
<p>The object will be a special type of channel, so you can use it in an alt
block and attempts to fetch the value before the thread is finished will
result in a block.  Unlike other channels, it will only ever have a single
value, so calls to clear_ready() will be ignored.</p>
</blockquote>
<p>Implementation:</p>
<blockquote>
TBD</blockquote>
<p>Dependencies:</p>
<blockquote>
TBD</blockquote>
<p>Regressions:</p>
<blockquote>
TBD</blockquote>
</div>
<div class="section" id="shared-data-structures">
<h1><a class="toc-backref" href="#id7" name="shared-data-structures">Shared Data Structures</a></h1>
<p>Status:</p>
<blockquote>
TBD</blockquote>
<p>Description:</p>
<blockquote>
Shared data structures will allow serialized access to data, i.e. mutexes
will wrap the actual data access, ensuring safe use between threads.</blockquote>
<p>Implementation:</p>
<blockquote>
TBD</blockquote>
<p>Dependencies:</p>
<blockquote>
TBD</blockquote>
<p>Regressions:</p>
<blockquote>
TBD</blockquote>
</div>
<div class="section" id="time-model">
<h1><a class="toc-backref" href="#id8" name="time-model">Time Model</a></h1>
<p>Refer to twiki page for now.</p>
</div>
<div class="section" id="kernel-threads">
<h1><a class="toc-backref" href="#id9" name="kernel-threads">Kernel Threads</a></h1>
<p>Status:</p>
<blockquote>
TBD</blockquote>
<p>Description:</p>
<blockquote>
Expand underlying RTOS to an M:N model, i.e. M kernel threads, each running
N user threads.  Add a placement specifier to par so that threads may be
dispatched to different kernel threads.  These kernel threads will be
identified using a pCluster object.</blockquote>
<p>Implementation:</p>
<blockquote>
<ol class="arabic">
<li><dl class="first">
<dt>Expand RTOS to handle kernel threads.  Probably use LinuxThreads.  The</dt>
<dd>RTOS code will need mutexes around critical areas.</dd>
</dl>
</li>
<li><p class="first">Create pCluster object.  Add code to spawn new kernel threads.</p>
</li>
<li><p class="first">Expand par blocks to add placement specifier, e.g.:</p>
<pre class="literal-block">
par {
  on (cluster1) { ... }
  on (cluster2) { ... }
}

The ``on (&lt;cluster name&gt;)`` block specifies a target cluster.  The
brace-delimited code is launched as the thread.
</pre>
</li>
<li><p class="first">Retrofit shared data structures with mutexes.</p>
</li>
</ol>
</blockquote>
<p>Dependencies:</p>
<blockquote>
<ol class="arabic">
<li><dl class="first">
<dt>Garbage collector needs to work with the kernel threadss.  This</dt>
<dd>shouldn't be a problem, as the Boehm collector currently supports
LinuxThreads.</dd>
</dl>
</li>
</ol>
</blockquote>
<p>Regressions:</p>
<blockquote>
TBD</blockquote>
</div>
</div>
<hr class="footer"/>
<div class="footer">
<a class="reference" href="schedule.rst">View document source</a>.
Generated on: 2004/05/07 13:37:43 CDT.
Generated by trip.prl release 1.2.2 from <a class="reference" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.
</div>
</body>
</html>
