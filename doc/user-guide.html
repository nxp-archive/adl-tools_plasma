<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="trip.prl release 1.2.2" />
<title>Plasma User's Guide</title>
<meta name="author" content="Brian Kahne" />
<link rel="stylesheet" href="http://docutils.sourceforge.net/tools/stylesheets/default.css" type="text/css" />
</head>
<body>
<div class="document" id="plasma-user-s-guide">
<h1 class="title">Plasma User's Guide</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Brian Kahne</td></tr>
<tr><th class="docinfo-name">Contact:</th>
<td><a class="first last reference" href="mailto:bkahne&#64;freescale.com">bkahne&#64;freescale.com</a></td></tr>
<tr><th class="docinfo-name">Revision:</th>
<td>user-guide.rst</td></tr>
</tbody>
</table>
<p>This document describes PLASMA (Parallel LAnguage for System Modeling and
Analysis).  It is a superset of C++ which adds concurrency constructs, a concept
of simulation time for discrete, and various safety features.</p>
<div class="contents topic" id="contents">
<p class="topic-title"><a name="contents">Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#concurrency" id="id1" name="id1">Concurrency</a><ul class="simple">
<li><a class="reference" href="#thread-creation" id="id2" name="id2">Thread Creation</a><ul class="simple">
<li><a class="reference" href="#par-block" id="id3" name="id3">Par Block</a></li>
<li><a class="reference" href="#pfor-loop" id="id4" name="id4">PFor Loop</a></li>
<li><a class="reference" href="#spawn-operator" id="id5" name="id5">Spawn Operator</a></li>
</ul>
</li>
<li><a class="reference" href="#thread-control" id="id6" name="id6">Thread Control</a></li>
<li><a class="reference" href="#the-time-model" id="id7" name="id7">The Time Model</a></li>
<li><a class="reference" href="#priorities" id="id8" name="id8">Priorities</a></li>
<li><a class="reference" href="#thread-communication" id="id9" name="id9">Thread Communication</a><ul class="simple">
<li><a class="reference" href="#channels" id="id10" name="id10">Channels</a></li>
<li><a class="reference" href="#alt-blocks" id="id11" name="id11">Alt Blocks</a></li>
<li><a class="reference" href="#afor-blocks" id="id12" name="id12">Afor Blocks</a></li>
<li><a class="reference" href="#shared-data-structures" id="id13" name="id13">Shared Data Structures</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#garbage-collection" id="id14" name="id14">Garbage Collection</a></li>
<li><a class="reference" href="#additional-language-constructs" id="id15" name="id15">Additional Language Constructs</a><ul class="simple">
<li><a class="reference" href="#let-blocks" id="id16" name="id16">Let Blocks</a></li>
<li><a class="reference" href="#lambda-functions" id="id17" name="id17">Lambda Functions</a></li>
</ul>
</li>
<li><a class="reference" href="#future-work" id="id18" name="id18">Future Work</a></li>
</ul>
</div>
<div class="section" id="concurrency">
<h1><a class="toc-backref" href="#id1" name="concurrency">Concurrency</a></h1>
<p>This section discusses the new language features added in order to support
concurrency.  These fall into two main categories: Thread creation and thread
communication.</p>
<div class="section" id="thread-creation">
<h2><a class="toc-backref" href="#id2" name="thread-creation">Thread Creation</a></h2>
<div class="section" id="par-block">
<h3><a class="toc-backref" href="#id3" name="par-block">Par Block</a></h3>
<p>The <strong>par</strong> block executes each statement in parallel, waiting until all child
threads are finished before proceeding.  For example:</p>
<pre class="literal-block">
int x,y,z;
par {
  x = sub1();
  y = sub2();
}
z = sub3();
</pre>
<p>In the above example, the statement &quot;x = sub1()&quot; and the statement &quot;y = sub2()&quot;
will execute in parallel.  Both will complete before the statement &quot;z = sub3()&quot;
is executed.  To create a more complex in-line operation, simply use a
brace-delineated block, e.g.:</p>
<pre class="literal-block">
par {
  {
    &lt;sequence of statements&gt;
  }
  {
    &lt;sequence of statements&gt;
  }
}
</pre>
</div>
<div class="section" id="pfor-loop">
<h3><a class="toc-backref" href="#id4" name="pfor-loop">PFor Loop</a></h3>
<p>The <strong>pfor</strong> loop acts like a for-loop, except that for each loop iteration, its
body is launched as a separate thread.  All threads must then complete before
execution continues past the loop.  For example:</p>
<pre class="literal-block">
const int Max = 10;
int results[Max];
pfor (int i = 0; i != Max ++i)  {
  results[i] = sub(i);
}
</pre>
<p>In this example, ten threads will be launched.  Each will return a result which
is stored into an element of the <em>results</em> array.</p>
<p>An important feature of the <strong>pfor</strong> loop is that variables declared in the loop
condition are passed by value to each thread, while all other variables are
passed by reference, and thus may be modified.  Thus, each thread contains a
copy of the index variable <strong>i</strong> but may directly modify <strong>results</strong>.</p>
</div>
<div class="section" id="spawn-operator">
<h3><a class="toc-backref" href="#id5" name="spawn-operator">Spawn Operator</a></h3>
<p>The <strong>spawn</strong> operator creates a thread and returns a handle object which allows
the result of the thread to be retrieved.  <strong>spawn</strong> takes a single argument
which must be some sort of function invocation.  This might be an actual
function, a method call, etc.  The list of supported types is:</p>
<ol class="arabic simple">
<li>Literal function call: <tt class="literal"><span class="pre">spawn(foo());</span></tt></li>
<li>Function pointer call: <tt class="literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">foo;</span> <span class="pre">spawn(p());</span></tt></li>
<li>Method call w/reference: <tt class="literal"><span class="pre">spawn(a.b());</span></tt></li>
<li>Method call w/pointer: <tt class="literal"><span class="pre">spawn(a-&gt;b());</span></tt></li>
<li>Static method call: <tt class="literal"><span class="pre">spawn(A::b());</span></tt></li>
<li>Method pointer w/reference: <tt class="literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">&amp;A::b;</span> <span class="pre">spawn(a.*p());</span></tt></li>
<li>Method pointer w/pointer:  <tt class="literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">&amp;A::b;</span> <span class="pre">spawn(a-&gt;*p());</span></tt></li>
</ol>
<p>The function's arguments are evaluated immediately; a thread is then launched
of the function with its arguments.  The function itself must return some type
of value; void functions are not allowed.  In addition, the result type must
have a default constructor.</p>
<p>The <strong>spawn</strong> operator returns an object of type <strong>Result&lt;T&gt;</strong>, where <strong>T</strong> is
the return type of the invoked function.  Calling the <em>value()</em> method returns
the result of the thread; if the thread is not yet finished, it will block.
Calling <em>wait()</em> will wait until the thread is finished and calling <em>kill()</em>
will termminate the thread.  In the latter case, the result of the thread will
be the default constructor value of the return type.</p>
<p>A simple example is:</p>
<pre class="literal-block">
double foo(double a,double b)
{
  int xx = 0;
  for (int i = 0; i != 100000000; ++i) {
    xx += 1;
  }
  return a*a + b*b;
}

int pMain(int argc,const char *argv[])
{ 
  Result&lt;double&gt; r1 = spawn(foo(1.1,2.2));
  Result&lt;double&gt; r2 = spawn(foo(2.7,9.8));
  cout &lt;&lt; &quot;Result is:  &quot; &lt;&lt; r1.value() &lt;&lt; &quot;, &quot; &lt;&lt; r2.value() &lt;&lt; endl;
  return 0;
}
</pre>
</div>
</div>
<div class="section" id="thread-control">
<h2><a class="toc-backref" href="#id6" name="thread-control">Thread Control</a></h2>
<p>The following functions provide control over threads.  These are declared in
<tt class="literal"><span class="pre">plasma-interface.h</span></tt> which is implicitly included in all plasma (.pa) files.</p>
<ol class="arabic simple">
<li><tt class="literal"><span class="pre">THandle</span> <span class="pre">pCurThread()</span></tt>:  Return a handle to the current thread.</li>
<li><tt class="literal"><span class="pre">pWait(THandle)</span></tt>:  Wait until the specified thread is finished.</li>
<li><tt class="literal"><span class="pre">pYield()</span></tt>:  Have the current thread swap to the next ready thread.</li>
<li><tt class="literal"><span class="pre">pTerminate()</span></tt>:  Kill the current thread.</li>
<li><tt class="literal"><span class="pre">pLock()</span></tt>:  Turn off time-slicing.</li>
<li><tt class="literal"><span class="pre">pUnlock()</span></tt>:  Turn on time-slicing.</li>
</ol>
<ol class="arabic" start="5">
<li><p class="first"><tt class="literal"><span class="pre">pExit(int</span> <span class="pre">code)</span></tt>:  Terminate the program with the specified exit code.</p>
</li>
<li><p class="first"><tt class="literal"><span class="pre">pAbort(char</span> <span class="pre">*)</span></tt>:  Abort the program gracefully with error message and
return exit code -1.</p>
</li>
<li><dl class="first">
<dt><tt class="literal"><span class="pre">pPanic(char</span> <span class="pre">*)</span></tt>:  Abort program immediately with error message and return</dt>
<dd>exit code -1.</dd>
</dl>
</li>
</ol>
</div>
<div class="section" id="the-time-model">
<h2><a class="toc-backref" href="#id7" name="the-time-model">The Time Model</a></h2>
<p>Plasma implements a time model so that users may experiment with mapping an
algorithm to a possible hardware configuration.  The model works along the lines
of a discrete event simulator:  A thread may delay itself, in which case it
stays idle until a specified amount of time has passed, or it may explicitly
consume time.  In other words, actual work done by the thread takes zero time
but to model algorithmic complexity, explicit calls may be made to simulate a
piece of hardware doing real work.</p>
<p>Time in plasma consists of discrete time ticks, but no unit is associated with
the time.  The main time type is a 64-bit integer.</p>
<p>There are three main functions for the time mode:</p>
<ol class="arabic">
<li><dl class="first">
<dt><tt class="literal"><span class="pre">pDelay(x)</span></tt>:  Delay for <strong>x</strong> time units.  The thread will be idle for</dt>
<dd>this period of time.</dd>
</dl>
</li>
<li><dl class="first">
<dt><tt class="literal"><span class="pre">pBusy(x)</span></tt>: Consume <strong>x</strong> time units.  This means that the processor is</dt>
<dd><p class="first">&quot;busy&quot; for this long.  In order to use <tt class="literal"><span class="pre">pBusy()</span></tt>, you must set
<tt class="literal"><span class="pre">ConfigParms::_busyokay</span></tt> to true.  If not, a runtime error will occur when
the function is called.  If you are in the busy-mode then preemption is
disabled; the only thread switches will be during alt, wait, delay, or busy
commands.</p>
<p class="last">Lowest priority threads are timesliced.  The time slice value is set by
setting <tt class="literal"><span class="pre">ConfigParms::_simtimeslice</span></tt> in <tt class="literal"><span class="pre">pSetup()</span></tt>.  What this means is
that a busy command will be divided up until these timeslices, allowing the
same processor to squeeze in work from other threads.</p>
</dd>
</dl>
</li>
<li><p class="first"><tt class="literal"><span class="pre">pTime()</span></tt>:  Returns the current system time.</p>
</li>
</ol>
<p>The user may declare multiple processors by declaring a <strong>Processor</strong> object,
e.g.:</p>
<pre class="literal-block">
Processor a;
</pre>
<p>A thread may be started on another processor using two different methods:</p>
<ol class="arabic">
<li><p class="first">With a <strong>par</strong> or <strong>pfor</strong> block, using an <strong>on</strong> block:</p>
<pre class="literal-block">
par {
   on (&lt;proc name&gt;) { ... }
   ...
}
</pre>
</li>
<li><p class="first">With the spawn command:</p>
<pre class="literal-block">
&lt;proc name&gt;.spawn(&lt;command&gt;);
</pre>
</li>
</ol>
<p>Each <strong>Processor</strong> may be given a name by passing a <tt class="literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></tt> to the
constructor or the <strong>setName</strong> method.  This pointer is unmanaged by the
<strong>Processor</strong> as is simply stored as-is.  This means that you can compare it
against another pointer for quick identification purposes.</p>
</div>
<div class="section" id="priorities">
<h2><a class="toc-backref" href="#id8" name="priorities">Priorities</a></h2>
<p>Threads in Plasma have priorities.  By default, a thread's priority is the same
as its parent's priority, with <tt class="literal"><span class="pre">pMain()</span></tt> starting at the lowest priority.
Priorities are specified as an integer, where 0 is the highest.  The number of
priorities may be set by the configuration parameter
<tt class="literal"><span class="pre">ConfigParms::_numpriorities</span></tt>.  The default value is 32.</p>
<p>Priorities may be specified using a functional API or as optional arguments to
<tt class="literal"><span class="pre">spawn</span></tt> or <tt class="literal"><span class="pre">on</span></tt>:</p>
<ol class="arabic simple">
<li><tt class="literal"><span class="pre">pSetPriority(int)</span></tt>: Set current thread's priority.</li>
<li><tt class="literal"><span class="pre">pGetPriorities()</span></tt>:  Return current thread's priority.</li>
<li><tt class="literal"><span class="pre">pLowestPriority()</span></tt>:  Return the lowest priority (timeslice queue).</li>
</ol>
<ol class="arabic simple" start="5">
<li>Optional second argument to spawn of a priority, e.g. <tt class="literal"><span class="pre">spawn(foo(),0);</span></tt></li>
<li>Optional second argument to on block of a priority, e.g. <tt class="literal"><span class="pre">on(p1,0)</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></tt></li>
</ol>
<p>For any given processor, threads execute in priority order, with timeslicing
only for the lowest priority thread.  Of course, if a higher priority waits on
another thread or enters an alt block, there is the possibility that a lower
priority thread may execute.  In other words, given the following code
fragment:</p>
<pre class="literal-block">
par {
  on (pCurProc(),0) { /* thread 1 */ }
  on (pCurProc(),1) { /* thread 2 */ }
  { /* thread 3 */ }
  { /* thread 4 */ }
}
</pre>
<p>Thread 1 will execute first and complete before thread 2, which will also
execute to completion before threads 3 and 4.  Threads 3 and 4 will execute in a
time-sliced fashion.  Note the use of <tt class="literal"><span class="pre">pCurProc()</span></tt>:  The only way to set a
priority with the <tt class="literal"><span class="pre">on</span></tt> block is to use two arguments.  If you want the thread
to execute on the current processor, you must call <tt class="literal"><span class="pre">pCurProc()</span></tt> to return the
current processor.</p>
</div>
<div class="section" id="thread-communication">
<h2><a class="toc-backref" href="#id9" name="thread-communication">Thread Communication</a></h2>
<div class="section" id="channels">
<h3><a class="toc-backref" href="#id10" name="channels">Channels</a></h3>
<p>One method for threads to communicate among themselves is to use a channel.
This is simply a data structure which allows one thread to write a value to it
and another thread to read this value.  It is up to the channel to make sure
that these operations are safe and to ensure proper flow control.  Any class may
be a channel as long as it has a specific interface.  This interface is required
in order to use the <strong>alt</strong> and <strong>afor</strong> constructs.</p>
<p>The required interface for a channel of type T is:</p>
<ol class="arabic simple">
<li><tt class="literal"><span class="pre">T</span> <span class="pre">read()</span></tt>: Returns a value read from the channel.  Blocks if no value is
present.  Returns the last value read, until clear_ready() is called.</li>
<li><tt class="literal"><span class="pre">T</span> <span class="pre">get()</span></tt>: Returns a value from the channel.  Blocks if no value is
present.  Always fetches a new value.  After a call to this, read() will
return this same value.</li>
<li><tt class="literal"><span class="pre">void</span> <span class="pre">write(T)</span></tt>: Writes a value to the channel.  May block, depending
upon the channel definition.</li>
<li><tt class="literal"><span class="pre">bool</span> <span class="pre">ready()</span> <span class="pre">const</span></tt>: Returns true if the channel has a value.</li>
<li><tt class="literal"><span class="pre">void</span> <span class="pre">clear_ready()</span></tt>:  Clears the ready status, forcing the fetch of a new
value.</li>
<li><tt class="literal"><span class="pre">set_notify(Thread</span> <span class="pre">*t,int</span> <span class="pre">handle)</span></tt>: Stores the thread and handle.  When the
channel gets a value, it will wake this thread, giving it the handle.</li>
<li><tt class="literal"><span class="pre">clear_notify()</span></tt>:  Clears the stored thread so that no notification will
take place if a value is written to the channel.  It must be possible to
call clear_notify() safely, e.g. this should not affect the behavior of
a blocked writing thread.</li>
</ol>
<p>Note that write(), read(), and clear_ready() are technically not required by <strong>alt</strong>
and <strong>afor</strong>.  Thus, it's possible to have a read-only channel.</p>
<p>Currently, Plasma contains the following channels.  These are declared in <tt class="literal"><span class="pre">plasma.h</span></tt>.</p>
<ol class="arabic">
<li><p class="first"><tt class="literal"><span class="pre">Channel&lt;class</span> <span class="pre">Data&gt;</span></tt>:  This is a typed channel which reads and writes an
object of type <em>Data</em>.  It contains only a single copy of this object; a
second write will block if the first write's data has not been read.  It may
be used with multiple producers, but only a single consumer is allowed.</p>
</li>
<li><p class="first"><tt class="literal"><span class="pre">QueueChan&lt;class</span> <span class="pre">Data&gt;</span></tt>: This is a typed queued channel: It allows for
multiple producers and requires a single consumer.  By default, the queue
size is not fixed, but the user may set a maximum size by specifying it as
the constructor argument.</p>
</li>
<li><p class="first"><tt class="literal"><span class="pre">Timeout</span></tt>:  Use this to break out of an alt block after a specified amount
of simulation time.  It uses <tt class="literal"><span class="pre">pDelay()</span></tt> to block for a given amount of
time.  If nothing else has awakened the alt block thread before then, this
will.  It does not return a useful value, so it is generally used with an
empty port statement, e.g.:</p>
<pre class="literal-block">
Timeout t(20);
alt {
  c0.port(...) { ... }
  c1.port(...) { ... }
  t.port() { cout &lt;&lt; &quot;Got a timeout!&quot; &lt;&lt; endl; }
}
</pre>
<p>In the above example, a <strong>Timeout</strong> object is created which will awaken an
alt block after 20 time units.</p>
</li>
<li><p class="first"><tt class="literal"><span class="pre">ResChan&lt;class</span> <span class="pre">Data&gt;</span></tt>: The <strong>spawn</strong> operator may be interfaced to an
<strong>alt</strong> construct by using this class.  This is a read-only channel which
will return the result value of the spawned thread.  For example:</p>
<pre class="literal-block">
double foo(double a,double b)
{
  int xx = 0;
  for (int i = 0; i != 100000000; ++i) {
    xx += 1;
  }
  return a*a + b*b;
}

int bar(int a)
{
  return a * a * a;
}

void check(ResChan&lt;double&gt; &amp;a,ResChan&lt;int&gt; &amp;b)
{
  for (int i = 0; i != 2; ++i) {
    alt {
      a.port(double x) {
        cout &lt;&lt; &quot;x:  &quot; &lt;&lt; x &lt;&lt; endl;
      }
      b.port (int y) {
        cout &lt;&lt; &quot;y:  &quot; &lt;&lt; y &lt;&lt; endl;        
      }
    }
  }
}

int pMain(int argc,const char *argv[])
{ 
  ResChan&lt;double&gt; r1 = spawn(foo(1.1,2.2));
  ResChan&lt;int&gt; r2 = spawn(bar(123));
  check(r1,r2);
  return 0;
}
</pre>
</li>
</ol>
</div>
<div class="section" id="alt-blocks">
<h3><a class="toc-backref" href="#id11" name="alt-blocks">Alt Blocks</a></h3>
<p>An <strong>alt</strong> block allows for unordered selection of data from channels.  Its
syntax is:</p>
<pre class="literal-block">
alt {
  &lt;channel expr&gt; [ . | -&gt; ] port (&lt;value decl&gt;) { &lt;body&gt; }
  [ alt { ... } ]
  [ afor { ... } ]
  [ { &lt;default block&gt; } ]
}
</pre>
<p>Each <strong>port</strong> statement specifies a channel to be read (the channel expression) and
an optional declaration which will receive the channel value.  The <strong>port</strong> body
has access to this value.  If no value declaration is specified, the channel's
data is not accessible.  This is useful for channels whose data is simply a
boolean state, such as a time-out channel.</p>
<p>Upon entry to the <strong>alt</strong> block, all channels are checked for data.  If a
channel has data, the body of the corresponding <strong>port</strong> statement is executed.
If more than one channel is ready, a single port statement is selected
non-deterministically.  If no channels are ready, the thread will sleep until a
channel has data.</p>
<p>If a default block is specified, the <strong>alt</strong> block will never cause the thread
to sleep.  Instead, if no channels have data, the default block will be
executed.</p>
<p><strong>alt</strong> and <strong>afor</strong> (explained below) blocks may be nested within <strong>alt</strong>
blocks.  This allows the user to block on multiple collections of channels, or a
collection of channels plus one or more single channels, etc.</p>
</div>
<div class="section" id="afor-blocks">
<h3><a class="toc-backref" href="#id12" name="afor-blocks">Afor Blocks</a></h3>
<p>An <strong>afor</strong> block is similar to an <strong>alt</strong> block, except that it allows the user
to loop over a data structure of channels.  Its syntax is:</p>
<pre class="literal-block">
afor ( &lt;s1&gt; ; &lt;s2&gt; ; &lt;s3&gt; ) {
  &lt;channel expr&gt; [. | -&gt; ] port (&lt;value decl&gt;) { &lt;body&gt; }
  [ { &lt;default block&gt; } ]
}
</pre>
<p>Only a single <strong>port</strong> statement is allowed.  The <strong>afor</strong> block is treated as a
for-loop, looping over all channels specified by the channel expression.  An
iterator variable must be declared in <em>s1</em>; its value is accessible to the
channel expression and the <strong>port</strong>'s body.</p>
<p>For example, the following code loops over an array of channels.  As in the
<strong>alt</strong> block, the thread will sleep if no channels are ready and there is not a
default block.:</p>
<pre class="literal-block">
afor (int i = 0; i != (int)channels.size(); ++i) {
  channels[i].port (int v) {
    printf (&quot;Got a value from port %d:  %d\n&quot;,i,v);
    if (v &lt; 0) ++donecount;
  }
}
</pre>
<p>Plasma allows for non-integer index variables but this requires the creation of
an auxiliary data structure, so performance might be a little slower, e.g. using
an iterator rather than an integer as an index.</p>
<p>There are a few restrictions to follow for the <strong>afor</strong> block:</p>
<ol class="arabic">
<li><dl class="first">
<dt>You must declare the loop iterator in the first statement of the <strong>afor</strong></dt>
<dd>block.</dd>
</dl>
</li>
<li><dl class="first">
<dt>The loop will occur multiple times, so make sure that there are no</dt>
<dd>side-effects.</dd>
</dl>
</li>
<li><dl class="first">
<dt>You only have access, within the <strong>port</strong> body, to the first loop iterator</dt>
<dd>variable.  Therefore, avoid fancy <strong>afor</strong> loops which declare multiple
variables in the first statement or update multiple variables in the third
statement.</dd>
</dl>
</li>
</ol>
<p>As noted above, an <strong>afor</strong> block may be nested within an <strong>alt</strong> block.  This
allows you to block on one or more collections and/or to block on a collection
plus one or more single channels.  For example, thhe following code will block
on a collection and an override channel::</p>
<pre class="literal-block">
alt {
  afor (int i = 0; i != (int)channels.size(); ++i) {
    channels[i].port (int v) {
      printf (&quot;Got a value from port %d:  %d\n&quot;,i,v);
      if (v &lt; 0) ++donecount;
    }
  }
  stopchan.port (bool b) {
    if (b) {
      printf (&quot;Got a stop command!\n&quot;);
    }
  }
}
</pre>
</div>
<div class="section" id="shared-data-structures">
<h3><a class="toc-backref" href="#id13" name="shared-data-structures">Shared Data Structures</a></h3>
<p>Threads may also commmunicate using shared data structures whose access methods
are protected by special synchronization primitives.  There are two means to do
this.  The easiest is to declare a class as being a mutex class:</p>
<pre class="literal-block">
pMutex class X { };
</pre>
<p>This will wrap all public methods of class <strong>X</strong>, except for constructors and
its destructor, with serialization code.  To prevent this on a per-method basis,
use the modifier <em>pNoMutex</em>:</p>
<pre class="literal-block">
pMutex class Foo {
public:
  // Not protected.
  Foo();
  ~Foo();
  // Protected.
  int a();
  // Not protected.
  pNoMutex int b();
private:
  // Not protected.
  int c();
};    
</pre>
<p>Be careful with using <em>pNoMutex</em>:  Since it disables serialization, it is
inherently dangerous.  It is useful, though, when you have a constant method
whose return value would not be affected by a thread preemption.  For example, a
method which returns a constant which is only initialized at construction time.</p>
<p>The other method for creating a shared data structure is to directly use the
<tt class="literal"><span class="pre">pLock()</span></tt> and <tt class="literal"><span class="pre">pUnlock()</span></tt> primitives.  This is more error prone than using
<em>pMutex</em> but might be necessary in some cases, such as for protecting a plain function:</p>
<pre class="literal-block">
void msg(const char *fmt, ...) {
  pLock();
  va_list ap;
  va_start(ap,fmt);
  vprintf(fmt,ap);
  va_end(ap);
  pUnlock();
}
</pre>
</div>
</div>
</div>
<div class="section" id="garbage-collection">
<h1><a class="toc-backref" href="#id14" name="garbage-collection">Garbage Collection</a></h1>
<p>Plasma is equipped with a garbage collector.  This means that heap-allocated
objects do not need to be explicitly freed; they will be collected when no more
pointers to the object remain.  This implicitly managed memory (referred to as
simply <em>managed</em> from now on) may be used alongside explicitly managed memory,
where a call to delete is required.</p>
<p>By default, allocations using <strong>new</strong> are explicitly managed.  To allocate
managed memory, you may derive an object from <strong>gc</strong> or <strong>gc_cleanup</strong> or
allocate using the <strong>GC</strong> placement attribute.</p>
<p>For example, the following class will be managed when allocated using <strong>new</strong>:</p>
<pre class="literal-block">
class A : public gc { };
</pre>
<p>However, its destructor will not be called.  If you derive from <strong>gc_cleanup</strong>,
the class's destructor will be called when the object is collected.</p>
<p>An example of using the <strong>GC</strong> placement attribute is:</p>
<pre class="literal-block">
int *x = new (GC) int[1000];
</pre>
<p>This will allocate a block of memory that is managed by the collector.</p>
<p>You may delete memory that is managed, but this is generally discouraged, since
the collector will collect it when it is safe to do so.</p>
</div>
<div class="section" id="additional-language-constructs">
<h1><a class="toc-backref" href="#id15" name="additional-language-constructs">Additional Language Constructs</a></h1>
<div class="section" id="let-blocks">
<h2><a class="toc-backref" href="#id16" name="let-blocks">Let Blocks</a></h2>
<p>TBD</p>
</div>
<div class="section" id="lambda-functions">
<h2><a class="toc-backref" href="#id17" name="lambda-functions">Lambda Functions</a></h2>
<p>TBD</p>
</div>
</div>
<div class="section" id="future-work">
<h1><a class="toc-backref" href="#id18" name="future-work">Future Work</a></h1>
<p>TBD</p>
</div>
</div>
<hr class="footer"/>
<div class="footer">
<a class="reference" href="user-guide.rst">View document source</a>.
Generated on: 2004/07/09 11:23:30 CDT.
Generated by trip.prl release 1.2.2 from <a class="reference" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.
</div>
</body>
</html>
