<!-- 95% W3C COMPLIANT, 95% CSS FREE, RAW HTML -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=ISO-8859-1">
<title>The Plasma Language</title>
 <style type="text/css">
  <!--
  pre { font-family: monospace }
  tt { font-family: monospace }
  code { font-family: monospace }
  p.flushright { text-align: right }
  p.flushleft { text-align: left }
  span.sc { font-variant: small-caps }
  span.sf { font-family: sans-serif }
  span.skribetitle { font-family: sans-serif; font-weight: bolder; font-size: x-large; }
  -->
 </style>
</head>

<body class="chapter" bgcolor="#ffffff">
<table width="100%" class="skribetitle" cellspacing="0" cellpadding="0"><tbody>
<tr><td align="center" bgcolor="#8381de"><div class="skribetitle"><strong><big><big><big>1. The Plasma Language -- Plasma User's Guide</big></big></big></strong></div><center>
</center>
</td></tr></tbody></table>
<table cellpadding="3" cellspacing="0" width="100%" class="skribe-margins"><tr>
<td align="left" valign="top" class="skribe-left-margin" width="20%" bgcolor="#dedeff"><div class="skribe-left-margin">
<br/><center><table width="97%" border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse;" frame="box" rules="none"><tbody>
<tr bgcolor="#8381de"><th align="center" colspan="1"><font color="#ffffff"><strong>main page</strong></font></th></tr>
<tr bgcolor="#ffffff"><td align="center" colspan="1"><table width="100%" border="0" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="left" valign="top" colspan="1"><strong>top:</strong></td><td align="right" valign="top" colspan="1"><a href="index.html#The-Plasma-Language" class="inbound">The Plasma Language</a></td></tr>
</tbody></table>
</td></tr>
</tbody></table>
</center>
<br/><br/><center><table width="97%" border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse;" frame="box" rules="none"><tbody>
<tr bgcolor="#8381de"><th align="center" colspan="1"><font color="#ffffff"><strong>Plasma User's Guide</strong></font></th></tr>
<tr bgcolor="#ffffff"><td align="center" colspan="1"><table cellspacing="1" cellpadding="1" width="100%" class="toc">
<tbody>
 <tr><td valign="top" align="left">1.1</td><td colspan="4" width="100%"><a href="index-1.html#Usage">Usage</a></td></tr>
 <tr><td valign="top" align="left">1.2</td><td colspan="4" width="100%"><a href="index-1.html#Concurrency">Concurrency</a></td></tr>
 <tr><td></td><td valign="top" align="left">1.2.1</td><td colspan="3" width="100%"><a href="index-1.html#Thread-Creation">Thread Creation</a></td></tr>
 <tr><td></td><td valign="top" align="left">1.2.2</td><td colspan="3" width="100%"><a href="index-1.html#Thread-Control">Thread Control</a></td></tr>
 <tr><td></td><td valign="top" align="left">1.2.3</td><td colspan="3" width="100%"><a href="index-1.html#The-Time-Model">The Time Model</a></td></tr>
 <tr><td></td><td valign="top" align="left">1.2.4</td><td colspan="3" width="100%"><a href="index-1.html#Priorities">Priorities</a></td></tr>
 <tr><td></td><td valign="top" align="left">1.2.5</td><td colspan="3" width="100%"><a href="index-1.html#Thread-Communication">Thread Communication</a></td></tr>
 <tr><td valign="top" align="left">1.3</td><td colspan="4" width="100%"><a href="index-1.html#Power-Modeling">Power Modeling</a></td></tr>
 <tr><td valign="top" align="left">1.4</td><td colspan="4" width="100%"><a href="index-1.html#Resource-Modeling">Resource Modeling</a></td></tr>
 <tr><td valign="top" align="left">1.5</td><td colspan="4" width="100%"><a href="index-1.html#Garbage-Collection">Garbage Collection</a></td></tr>
 <tr><td valign="top" align="left">1.6</td><td colspan="4" width="100%"><a href="index-1.html#Miscellaneous-Language-Features">Miscellaneous Language Features</a></td></tr>
 <tr><td valign="top" align="left">1.7</td><td colspan="4" width="100%"><a href="index-1.html#Library-Features">Library Features</a></td></tr>
 <tr><td></td><td valign="top" align="left">1.7.1</td><td colspan="3" width="100%"><a href="index-1.html#I/O-Routines">I/O Routines</a></td></tr>
 <tr><td></td><td valign="top" align="left">1.7.2</td><td colspan="3" width="100%"><a href="index-1.html#String-Routines">String Routines</a></td></tr>
 <tr><td></td><td valign="top" align="left">1.7.3</td><td colspan="3" width="100%"><a href="index-1.html#Random-Number-Generation">Random Number Generation</a></td></tr>
</tbody>
</table>
</td></tr>
</tbody></table>
</center>
<br/><br/><center><table width="97%" border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse;" frame="box" rules="none"><tbody>
<tr bgcolor="#8381de"><th align="center" colspan="1"><font color="#ffffff"><strong>Chapters</strong></font></th></tr>
<tr bgcolor="#ffffff"><td align="center" colspan="1"><table cellspacing="1" cellpadding="1" width="100%" class="toc">
<tbody>
 <tr><td valign="top" align="left">1</td><td colspan="4" width="100%"><a href="index-1.html#Plasma-User's-Guide">Plasma User's Guide</a></td></tr>
 <tr><td valign="top" align="left">2</td><td colspan="4" width="100%"><a href="index-2.html#Examples">Examples</a></td></tr>
 <tr><td valign="top" align="left">3</td><td colspan="4" width="100%"><a href="index-3.html#Implementation-Notes">Implementation Notes</a></td></tr>
 <tr><td valign="top" align="left">4</td><td colspan="4" width="100%"><a href="index-4.html#Future-Work">Future Work</a></td></tr>
 <tr><td valign="top" align="left">5</td><td colspan="4" width="100%"><a href="index-5.html#Plasma-Development-Schedule">Plasma Development Schedule</a></td></tr>
</tbody>
</table>
</td></tr>
</tbody></table>
</center>
</div></td>
<td align="left" valign="top" class="skribe-body"><div class="skribe-body">
<p>This document describes PLASMA (Parallel LAnguage for System Modeling and
Analysis).  It is a superset of C++ which adds concurrency constructs, a concept
of simulation time for discrete, and various safety features.</p><!-- Usage -->
<a name="Usage"></a>
<div class="skribesectiontitle"><table width="100%"><tr><td bgcolor="#dedeff"><h3><font color="black">1.1 Usage</font>
</h3></td></tr></table>
</div><div class="section">
<p>Plasma is currently implemented as a front-end which converts a PLASMA
program into C++, then invokes g++ to compile this into either an executable or
into an object file.  As such, its options are basically those of g++.  General
usage is:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"> 
plasma &lt;options&gt; &lt;input file&gt; 
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>An input file has an extension of <code>.pa</code>.</p><p>For example, to create an executable from a single Plasma file:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"> 
plasma -g -Wall -O3 foo.pa -o foo  
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>To create an object file, use the <strong>-c</strong> option:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"> 
plasma -g -Wall -O3 -c foo.pa -o foo.o 
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>To link, use <strong>ld</strong> or <strong>g++</strong>.  The script <strong>plasma-config</strong> exists to supply the
required link line.  For example:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"> 
plasma -c -o a.o a.pa
plasma -c -o b.o b.pa
g++ -o prog a.o b.o `plasma-config --libs`
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>Within a <em>makefile</em>, use <code>$(shell plasma-config --libs)</code> to generate the link line.</p></div><br>
<!-- Concurrency -->
<a name="Concurrency"></a>
<div class="skribesectiontitle"><table width="100%"><tr><td bgcolor="#dedeff"><h3><font color="black">1.2 Concurrency</font>
</h3></td></tr></table>
</div><div class="section">
<p>This section discusses the new language features added in order to support
concurrency.  These fall into two main categories: Thread creation and thread
communication.</p><!-- Thread Creation -->
<a name="Thread-Creation"></a>
<div class="skribesubsectiontitle"><table width="100%"><tr><td bgcolor="#ffffff"><h3><font color="#8381de">1.2.1 Thread Creation</font>
</h3></td></tr></table>
</div><div class="subsection">
<!-- Par Block -->
<a name="Par-Block"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">1.2.1.1 Par Block</font>
</h4></div><div class="subsubsection">
<p>The <strong>par</strong> block executes each statement in parallel, waiting until all
child threads are finished before proceeding.  For example:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"> 
int x,y,z;
par <font color="red"><strong>{</strong></font>
  x = sub1();
  y = sub2();
<font color="red"><strong>}</strong></font>
z = sub3();
 
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>In the above example, the statement <code>x = sub1()</code> and the statement
<code>y = sub2()</code> will execute in parallel.  Both will complete before the
statement <code>z = sub3()</code> is executed.  To create a more complex in-line
operation, simply use a brace-delineated block, e.g.:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"> 
par <font color="red"><strong>{</strong></font>
  <font color="red"><strong>{</strong></font>
    &lt;sequence of statements&gt;
  <font color="red"><strong>}</strong></font>
  <font color="red"><strong>{</strong></font>
    &lt;sequence of statements&gt;
  <font color="red"><strong>}</strong></font>
<font color="red"><strong>}</strong></font>
 
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
<!-- PFor Loop -->
<a name="PFor-Loop"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">1.2.1.2 PFor Loop</font>
</h4></div><div class="subsubsection">
<p>The <strong>pfor</strong> loop acts like a for-loop, except that for each loop
iteration, its body is launched as a separate thread.  All threads must then
complete before execution continues past the loop.  For example:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"> 
const int Max = 10;
int results[Max];
pfor (int i = 0; i != Max ++i)  <font color="red"><strong>{</strong></font>
  results[i] = sub(i);
<font color="red"><strong>}</strong></font>
 
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>In this example, ten threads will be launched.  Each will return a result which
is stored into an element of the <em>results</em> array.</p><p>An important feature of the <strong>pfor</strong> loop is that variables declared in the loop
condition are passed by value to each thread, while all other variables are
passed by reference, and thus may be modified.  Thus, each thread contains a
copy of the index variable <strong>i</strong> but may directly modify <strong>results</strong>.</p></div>
<!-- Spawn Operator -->
<a name="Spawn-Operator"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">1.2.1.3 Spawn Operator</font>
</h4></div><div class="subsubsection">
<p>The <strong>spawn</strong> operator creates a thread and returns a handle object which allows
the result of the thread to be retrieved.  <strong>spawn</strong> takes a single argument
which must be some sort of function invocation.  This might be an actual
function, a method call, etc.  The list of supported types is:</p><ul class="itemize"><li>Literal function call: <code>spawn(foo());</code></li>
<li>Function pointer call: <code>p = foo; spawn(p());</code></li>
<li>Method call w/reference: <code>spawn(a.b());</code></li>
<li>Method call w/pointer: <code>spawn(a-&gt;b());</code></li>
<li>Static method call: <code>spawn(A::b());</code></li>
<li>Method pointer w/reference: <code>p = &amp;A::b; spawn(a.*p());</code></li>
<li>Method pointer w/pointer:  <code>p = &amp;A::b; spawn(a-&gt;*p());</code></li>
</ul><p>The function's arguments are evaluated immediately; a thread is then
launched of the function with its arguments.  The <strong>spawn</strong> operator returns
an object of type <code>Result&lt;T&gt;</code>, where <strong>T</strong> is the return type of the
invoked function.  Calling the <code>value()</code> method returns the result of
the thread; if the thread is not yet finished, it will block.  Calling <code>wait()</code> will wait until the thread is finished and calling <code>kill()</code>
will terminate the thread.  In the latter case, the result of the thread will be
the default constructor value of the return type.</p><p>Note that in order for a function to be used with <code>spawn</code>, its
return type must have a default constructor.</p><p>A simple example is:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"> 
double foo(double a,double b)
<font color="red"><strong>{</strong></font>
  int xx = 0;
  <strong>for</strong> (int i = 0; i != 100000000; ++i) <font color="red"><strong>{</strong></font>
    xx += 1;
  <font color="red"><strong>}</strong></font>
  <strong>return</strong> a*a + b*b;
<font color="red"><strong>}</strong></font>

int pMain(int argc,const char *argv[])
<font color="red"><strong>{</strong></font> 
  Result&lt;double&gt; r1 = spawn(foo(1.1,2.2));
  Result&lt;double&gt; r2 = spawn(foo(2.7,9.8));
  cout &lt;&lt; <font color="red">&quot;Result is:  &quot;</font> &lt;&lt; r1.value() 
       &lt;&lt; &quot;, &quot; &lt;&lt; r2.value() &lt;&lt; endl;
  <strong>return</strong> 0;
<font color="red"><strong>}</strong></font>
 
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>If the spawned function has a void return type, then the <code>Result</code> type will be
an integer and will always be 0.  Since <code>int</code> is the default type for
<code>Result</code>, you can declare an object in this manner:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog">void foo();

Result&lt;&gt; r = spawn(foo());

</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
<a name="ResultCheck" class="mark"></a><p>A common use of the <strong>spawn</strong> operator is to launch a series of threads,
push their <strong>Result</strong> objects into a container, then iterate over that
container, testing each value with a predicate.  This act causes the parent (the
thread that is doing the iteration) to wait until all threads are done, acting
as a synchronization point.</p><p>Plasma provides templates for doing this.  The most general case is called
<code>ResultCheck&lt;typename R,typename Pred&gt;</code>, where <code>R</code> is the type
returned by the spawned functions and <code>Pred</code> is a predicate function.
The user can then call <code>ResultCheck::check()</code> to perform the iteration.
If the predicate fails (returns false), <code>check()</code> stops and returns
false.</p><p>Frequently, <code>ResultCheck</code> is used to check that all threads return
an expected value, e.g. true.  The <code>ValueCheck&lt;T&gt;</code> class will do this.
It accepts the expected value as a constructor argument.  A helper function
<code>make_valuecheck()</code> simplifies the creation of the object.</p><p>For instance:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"> 
ValueCheckGen&lt;Foo&gt; results(make_valuecheck(foo));
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>where <strong>Foo</strong> is a type and <strong>foo</strong> is an instance of the type,
e.g. <code>bool</code> and <code>true</code>.  You then add threads like this:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog">     
results.push_back(spawn(myfunc(1,2,3)));
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>And check the results like this:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog">   
<strong>if</strong> (!results.check()) <font color="red"><strong>{</strong></font> <strong>return</strong> false; <font color="red"><strong>}</strong></font>;
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>You can reuse it by calling clear:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"> 
results.clear();
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>Since a boolean is frequently used, a typedef is provided, called <code>BoolCheck</code>.  Use this to capture and test the result of spawned functions
which return booleans.</p></div>
<!-- Thread Control -->
<a name="Thread-Control"></a>
<div class="skribesubsectiontitle"><table width="100%"><tr><td bgcolor="#ffffff"><h3><font color="#8381de">1.2.2 Thread Control</font>
</h3></td></tr></table>
</div><div class="subsection">
<p>The following functions provide control over threads.  These are declared in
<code>plasma-interface.h</code> which is implicitly included in all plasma (.pa) files.</p><ul class="itemize"><li><code>THandle pCurThread()</code>:  Return a handle to the current thread.</li>
<li><code>pWait(THandle)</code>:  Wait until the specified thread is finished.</li>
<li><code>pYield()</code>:  Have the current thread swap to the next ready thread.</li>
<li><code>pTerminate()</code>:  Kill the current thread.</li>
<li><code>pLock()</code>:  Turn off time-slicing.</li>
<li><code>pUnlock()</code>:  Turn on time-slicing.</li>
<li><code>pExit(int code)</code>:  Terminate the program with the specified exit code.</li>
<li><code>pAbort(char *)</code>: Abort the program gracefully with error message
and return exit code -1.</li>
<li><code>pPanic(char *)</code>:  Abort program immediately with error message and return
    exit code -1.</li>
</ul></div>
<!-- The Time Model -->
<a name="The-Time-Model"></a>
<div class="skribesubsectiontitle"><table width="100%"><tr><td bgcolor="#ffffff"><h3><font color="#8381de">1.2.3 The Time Model</font>
</h3></td></tr></table>
</div><div class="subsection">
<p>Plasma implements a time model so that users may experiment with mapping an
algorithm to a possible hardware configuration.  The model works along the lines
of a discrete event simulator:  A thread may delay itself, in which case it
stays idle until a specified amount of time has passed, or it may explicitly
consume time.  In other words, actual work done by the thread takes zero time
but to model algorithmic complexity, explicit calls may be made to simulate a
piece of hardware doing real work.</p><p>Time in plasma consists of discrete time ticks, but no unit is associated with
the time.  The main time type is a 64-bit integer.</p><p>There are three main functions for the time mode:</p><ul class="itemize"><li><code>pDelay(x)</code>:  Delay for <strong>x</strong> time units.  The thread will be idle for
this period of time.</li>
<li><p><code>pBusy(x)</code>: Consume <strong>x</strong> time units.  This means that the
processor is &quot;busy&quot; for this long.  In order to use <code>pBusy()</code>, you must set
<code>ConfigParms::_busyokay</code> to true.  If not, a runtime error will occur when the
function is called.  If you are in the busy-mode then preemption is disabled;
the only thread switches will be during alt, wait, delay, or busy commands.</p><p>Lowest priority threads are time-sliced.  The time slice value is set by
setting <code>ConfigParms::_simtimeslice</code> in <code>pSetup()</code>.  What this means is that
a busy command will be divided up into these timeslices, allowing the same
processor to squeeze in work from other threads.</p></li>
<li><code>pTime()</code>:  Returns the current system time.</li>
</ul><p>The user may declare multiple processors by declaring a <strong>Processor</strong> object,
e.g.:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"> 
Processor a;
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>To create a vector of Processors, use the <code>Processors</code> data
structure:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"> 
Processors procs(10);
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>New threads will be launched on their parent's processor unless one of the
following mechanisms is used:</p><ul class="itemize"><li><p>With a <strong>par</strong> or <strong>pfor</strong> block, using an <strong>on</strong> block:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"> 
par <font color="red"><strong>{</strong></font>
   on (&lt;proc name&gt;) <font color="red"><strong>{</strong></font> ... <font color="red"><strong>}</strong></font>
   ...
<font color="red"><strong>}</strong></font>
 
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></li>
<li><p>With the spawn command:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"> 
&lt;proc name&gt;.spawn(&lt;command&gt;);
 
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></li>
</ul><p>Each <strong>Processor</strong> may be given a name by passing a <code>const char *</code> to the
constructor or the <strong>setName</strong> method.  This pointer is unmanaged by the
<strong>Processor</strong> and is simply stored as-is.  This means that you can compare it
against another pointer for quick identification purposes.</p><p>By default, each processor has its own issue queue and threads must
be explicitly launched on another processor.  However, Plasma has support for allowing a
group of processors to share a common issue queue.  This allows for the modeling
of SMP systems.  To do this, the user either creates a new processor using the
<code>make_sharedproc()</code> function, or creates an array of processors by
specifying <em>true</em> for the third argument of the <code>Processors</code>
constructor:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"> 
Processor a = make_sharedproc(pCurProc());

Processors procs(10,&quot;terminals&quot;,true);
 
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>In the above code, processor <code>a</code> shares its ready queue with the
current processor and the ten processors declared by <code>procs</code> all share
the same ready queue.</p><p>In the following example, even though all of the threads are launched on the
same processor (element 0 of the <code>procs</code> array), they all finish in 50
time units.  This is because the other nine processors share the same ready
queue and are able to schedule these threads.</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"> 
Processors procs(10,&quot;processors&quot;,true);

pfor (int i = 0; i != 10; ++i) <font color="red"><strong>{</strong></font>
  on (procs[0]) <font color="red"><strong>{</strong></font>
    cout &lt;&lt; <font color="red">&quot;Block &quot;</font> &lt;&lt; i &lt;&lt; <font color="red">&quot; start:  &quot;</font> &lt;&lt; pTime() &lt;&lt; endl;
    pBusy(50);
    cout &lt;&lt; <font color="red">&quot;Block &quot;</font> &lt;&lt; i &lt;&lt; <font color="red">&quot; done:  &quot;</font> &lt;&lt; pTime() &lt;&lt; endl;      
  <font color="red"><strong>}</strong></font>
<font color="red"><strong>}</strong></font>
 
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>The output from this program fragment is:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"> 
Block 0 start:  0
Block 1 start:  0
Block 2 start:  0
Block 3 start:  0
Block 4 start:  0
Block 5 start:  0
Block 6 start:  0
Block 7 start:  0
Block 8 start:  0
Block 9 start:  0
Block 0 done:  50
Block 8 done:  50
Block 1 done:  50
Block 9 done:  50
Block 7 done:  50
Block 5 done:  50
Block 2 done:  50
Block 6 done:  50
Block 4 done:  50
Block 3 done:  50
 
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
<!-- Priorities -->
<a name="Priorities"></a>
<div class="skribesubsectiontitle"><table width="100%"><tr><td bgcolor="#ffffff"><h3><font color="#8381de">1.2.4 Priorities</font>
</h3></td></tr></table>
</div><div class="subsection">
<p>Threads in Plasma have priorities.  By default, a thread's priority is the
same as its parent's priority, with <code>pMain()</code> starting at the lowest
priority.  Priorities are specified as an integer, where 0 is the highest.  The
number of priorities may be set by the configuration parameter <code>ConfigParms::_numpriorities</code>.  The default value is 32.</p><p>Priorities may be specified using a functional API or as optional arguments to
<strong>spawn</strong> or <strong>on</strong>:</p><ul class="itemize"><li><code>pSetPriority(int)</code>: Set current thread's priority.</li>
<li><code>pGetPriorities()</code>:  Return current thread's priority.</li>
<li><code>pLowestPriority()</code>:  Return the lowest priority (timeslice queue).</li>
<li>Optional second argument to <strong>spawn</strong> of a priority, e.g. <code>spawn(foo(),0);</code></li>
<li>Optional second argument to <strong>on</strong> block of a priority, e.g. <code>on(p1,0) { ... }</code></li>
</ul><p>For any given processor, threads execute in priority order, with timeslicing
only for the lowest priority thread.  Of course, if a higher priority waits on
another thread or enters an alt block, there is the possibility that a lower
priority thread may execute.  In other words, given the following code
fragment:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"> 
par <font color="red"><strong>{</strong></font>
  on (pCurProc(),0) <font color="red"><strong>{</strong></font> <font color="#ffa600"><strong>/* thread 1 */</strong></font> <font color="red"><strong>}</strong></font>
  on (pCurProc(),1) <font color="red"><strong>{</strong></font> <font color="#ffa600"><strong>/* thread 2 */</strong></font> <font color="red"><strong>}</strong></font>
  <font color="red"><strong>{</strong></font> <font color="#ffa600"><strong>/* thread 3 */</strong></font> <font color="red"><strong>}</strong></font>
  <font color="red"><strong>{</strong></font> <font color="#ffa600"><strong>/* thread 4 */</strong></font> <font color="red"><strong>}</strong></font>
<font color="red"><strong>}</strong></font>
 
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>Thread 1 will execute first and complete before thread 2, which will also
execute to completion before threads 3 and 4.  Threads 3 and 4 will execute in a
time-sliced fashion.  Note the use of <code>pCurProc()</code>:  The only way to set a
priority with the <strong>on</strong> block is to use two arguments.  If you want the thread
to execute on the current processor, you must call <code>pCurProc()</code> to return the
current processor.</p></div>
<!-- Thread Communication -->
<a name="Thread-Communication"></a>
<div class="skribesubsectiontitle"><table width="100%"><tr><td bgcolor="#ffffff"><h3><font color="#8381de">1.2.5 Thread Communication</font>
</h3></td></tr></table>
</div><div class="subsection">
<!-- Channels -->
<a name="Channels"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">1.2.5.1 Channels</font>
</h4></div><div class="subsubsection">
<p>One method for threads to communicate among themselves is to use a channel.
This is simply a data structure which allows one thread to write a value to it
and another thread to read this value.  It is up to the channel to make sure
that these operations are safe and to ensure proper flow control.  Any class may
be a channel as long as it has a specific interface.  This interface is required
in order to use the <strong>alt</strong> and <strong>afor</strong> constructs.</p><p>The required interface for a channel of type <strong>T</strong> is:</p><ul class="itemize"><li><code>T read()</code>: Returns a value read from the channel.  Blocks if no value is
   present.  Returns the last value read, until clear_ready() is called.</li>
<li><code>T get()</code>: Returns a value from the channel.  Blocks if no value
is present.  Always fetches a new value.  After a call to this, <code>read()</code> will
return this same value.</li>
<li><code>void write(T)</code>: Writes a value to the channel.  May block,
depending upon the channel definition.</li>
<li><code>bool ready() const</code>: Returns true if the channel has a value.</li>
<li><code>bool full() const</code>: Returns true if the channel would block if
written to.</li>
<li><code>void clear_ready()</code>: Clears the ready status, forcing the fetch
of a new value.</li>
<li><code>set_notify(Thread *t,int handle)</code>: Stores the thread and handle.
When the channel gets a value, it will wake this thread, giving it the handle.</li>
<li><code>clear_notify()</code>: Clears the stored thread so that no
notification will take place if a value is written to the channel.  It must be
possible to call <code>clear_notify()</code> safely, e.g. this should not affect
the behavior of a blocked writing thread.</li>
<li><code>value_type</code>: A typedef for the data type of the channel.</li>
</ul><p>Note that <code>write()</code>, <code>read()</code>, <code>clear_ready()</code>, and
<code>full()</code> are technically not required by <strong>alt</strong> and <strong>afor</strong>.
Thus, it is possible to have a read-only channel.</p><p>Currently, Plasma contains the following channels.  These are declared in
<code>plasma/plasma.h</code>.</p><ul class="itemize"><li><code>Channel&lt;class Data,class Base = SingleConsumerChannel&gt;</code>: This is
a typed channel which reads and writes an object of type <em>Data</em>.  It
contains only a single copy of this object; a second write will block if the
first write's data has not been read.  It may be used with multiple producers.
By default, only a single consumer is allowed.  To enable multiple consumers,
specify <code>MultiConsumerChannel</code> for the second template argument <em>Base</em>.</li>
<li><code>BusyChan Data,class Base = SingleConsumerChannel&gt;</code>: This channel
is similar to <code>Channel</code>, except that if a read blocks, it places the
thread's processor into a busy state.  This can be used for when waiting on a
resource holds up a task, e.g. a processor waiting on a load cannot do something
else.  The user can specify a timeslice value in the constructor, or specify 0
to mean no timeslicing.</li>
<li><code>QueueChan&lt;class Data,class Base = SingleConsumerChannel&gt;</code>: This
is a typed queued channel: It allows for multiple producers and supports
multiple consumers if the <em>Base</em> argument is set to <code>MultiConsumerChannel</code>.  By default, the queue size is not fixed, but the user
may set a maximum size by specifying it as the constructor argument.</li>
<li><p><code>Timeout</code>: Use this to break out of an <strong>alt</strong> block after
a specified amount of simulation time.  It uses <code>pDelay()</code> to block for
a given amount of time.  If nothing else has awakened the alt block thread
before then, this will.  It does not return a useful value, so it is generally
used with an empty port statement, e.g.:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"> 
Timeout t(20);
alt <font color="red"><strong>{</strong></font>
  c0.port(...) <font color="red"><strong>{</strong></font> ... <font color="red"><strong>}</strong></font>
  c1.port(...) <font color="red"><strong>{</strong></font> ... <font color="red"><strong>}</strong></font>
  t.port() <font color="red"><strong>{</strong></font> cout &lt;&lt; <font color="red">&quot;Got a timeout!&quot;</font> &lt;&lt; endl; <font color="red"><strong>}</strong></font>
<font color="red"><strong>}</strong></font>
 
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>In the above example, a <strong>Timeout</strong> object is created which will awaken an
alt block after 20 time units.</p></li>
<li><a name="clocked-chan" class="mark"></a><p><code>ClockChan&lt;class Data,,class Base =
SingleConsumerClockChannel,class Container = list&lt;Data&gt; &gt;</code>: Clocked channels
allow for the easy modeling of clocked hardware.  The basic idea is that data
may be written at any time, but the channel may only be read at certain
intervals.  This interval is specified by the constructor.  For instance, a
clocked channel with a period of 10 will block until the time is a multiple of
10.  This class can be used in a queued or non-queued manner, also specified by
a constructor argument.  The third template parameter allows the user to
specify an alternate container to hold the queued data.</p><p>The basic idea of clocked channels is to let the channel worry about time,
rather than the user's code.  In other words, to model a pipeline, each pipeline
stage acts as a consumer of data from the prior stage and a producer for the
next stage.  The communication occurs through clocked channels so that the
timing is invisible to each stage, and is instead coordinated solely by the
channels.</p><p>Multiple producers are supported.  Multiple consumers may be allowed by
specifying <code>MultiConsumerClockChannel</code> for the second template
argument.</p><p>If the clock period is set to 0, the behavior is the same as an unclocked
channel.  This allows the user to switch between having a channel be clocked or
unclocked by simply modifying a constructor argument, rather than changing the
channel's type.</p></li>
<li><p><code>ResChan&lt;class Data&gt;</code>: The <strong>spawn</strong> operator may be
interfaced to an <strong>alt</strong> construct by using this class.  This is a read-only
channel which will return the result value of the spawned thread.  For example:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"> 
double foo(double a,double b)
<font color="red"><strong>{</strong></font>
  int xx = 0;
  <strong>for</strong> (int i = 0; i != 100000000; ++i) <font color="red"><strong>{</strong></font>
    xx += 1;
  <font color="red"><strong>}</strong></font>
  <strong>return</strong> a*a + b*b;
<font color="red"><strong>}</strong></font>

int bar(int a)
<font color="red"><strong>{</strong></font>
  <strong>return</strong> a * a * a;
<font color="red"><strong>}</strong></font>

void check(ResChan&lt;double&gt; &amp;a,ResChan&lt;int&gt; &amp;b)
<font color="red"><strong>{</strong></font>
  <strong>for</strong> (int i = 0; i != 2; ++i) <font color="red"><strong>{</strong></font>
    alt <font color="red"><strong>{</strong></font>
      a.port(double x) <font color="red"><strong>{</strong></font>
        cout &lt;&lt; <font color="red">&quot;x:  &quot;</font> &lt;&lt; x &lt;&lt; endl;
      <font color="red"><strong>}</strong></font>
      b.port (int y) <font color="red"><strong>{</strong></font>
        cout &lt;&lt; <font color="red">&quot;y:  &quot;</font> &lt;&lt; y &lt;&lt; endl;        
      <font color="red"><strong>}</strong></font>
    <font color="red"><strong>}</strong></font>
  <font color="red"><strong>}</strong></font>
<font color="red"><strong>}</strong></font>

int pMain(int argc,const char *argv[])
<font color="red"><strong>{</strong></font> 
  ResChan&lt;double&gt; r1 = spawn(foo(1.1,2.2));
  ResChan&lt;int&gt; r2 = spawn(bar(123));
  check(r1,r2);
  <strong>return</strong> 0;
<font color="red"><strong>}</strong></font>
 
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></li>
</ul></div>
<!-- Multiple Consumers -->
<a name="Multiple-Consumers"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">1.2.5.2 Multiple Consumers</font>
</h4></div><div class="subsubsection">
<p>The basic Plasma channels all expect there to be a single consumer of
data unless explicitly configured to support multiple consumers.  In such a
case, only one consumer will receive the data.  This is useful in a situation,
for example, where a group of consumers waits for the next available job.
However, it does not allow for the broadcasting of information to a group of
consumers all at once.  Instead, the <code>Broadcaster</code> class exists.  It is
an object which has an input channel and one or more output channels:  Any data
sent to the input is reflected to the output.  It is templated on both its input
and output channel types.  Another class, <code>ClkBroadcaster</code>, specializes
<code>Broadcaster</code> to work with clocked systems.</p><p>For example, you might use this in the following way:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><strong>typedef</strong> Channel&lt;int&gt; IntChan;
<strong>typedef</strong> Broadcaster&lt;IntChan,IntChan&gt; IntBroadcaster;

int pMain(int argc,const char *argv[])
<font color="red"><strong>{</strong></font> 
  const int Num = 5;
  IntBroadcaster ib;

  par <font color="red"><strong>{</strong></font>
    producer(10,ib.get_source());
    pfor (int i = 0; i != Num; ++i) <font color="red"><strong>{</strong></font>
      consumer(i,ib.get_sink());
    <font color="red"><strong>}</strong></font>
  <font color="red"><strong>}</strong></font>
  plasma::mprintf (&quot;Done.\n&quot;);
  <strong>return</strong> 0;
<font color="red"><strong>}</strong></font>
 
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>Calling <code>get_source()</code> returns the input channel, which is of type
<code>Broadcaster::input_channel</code>.  Calling <code>get_sink()</code> adds a new
output channel to the broadcast object and returns a reference to it.  This
channel is of type <code>Broadcaster::output_channel</code>.  Each time that the
producer writes data to the input channel, it is broadcast to all of the consumers.</p><p>On the other hand, this only works if data may be replicated.  If this is
not valid, e.g. a transaction should not be copied but instead should be
consumed by any of several listening consumers, then it is necessary to
configure a channel to allow multiple consumers.  This is done by specifying
<code>MultiConsumerChannel</code> for the <em>Base</em> template parameter of
non-clocked channels and <code>MultiConsumerClockChannel</code> for clocked
channels.  This does impose some slight overhead for bookkeeping, so it is
generally recommended to keep a channel as single-consumer only unless otherwise
necessary.</p><p>When a channel is configured as allowing multiple consumers, more than one
thread may do a <em>get</em> from that channel, or use it in an <em>alt</em> statement.  For
example:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><strong>typedef</strong> ClockChan&lt;int,MultiConsumerClockChannel&gt; IntChan;

void producer(int id,int val,IntChan &amp;chan) 
<font color="red"><strong>{</strong></font>
  <strong>for</strong> (int i = 0; i != 10; ++i) <font color="red"><strong>{</strong></font>
    chan.write(val+i);
  <font color="red"><strong>}</strong></font>
  plasma::mprintf (&quot;Done.
&quot;);
<font color="red"><strong>}</strong></font>

void consumer(int id,IntChan &amp;c0,IntChan &amp;c1)
<font color="red"><strong>{</strong></font>
  int foo = 10;

  <strong>while</strong> (true) <font color="red"><strong>{</strong></font>
    alt <font color="red"><strong>{</strong></font>
      c0.port(int d) <font color="red"><strong>{</strong></font>
        cout &lt;&lt; id &lt;&lt; &quot;:  Port 0, Time <font color="red">&quot; &lt;&lt; pTime() &lt;&lt; &quot;</font>:  Got <font color="red">&quot; &lt;&lt; d &lt;&lt; endl;</font>
<font color="red">      }</font>
<font color="red">      c1.port(int d) {</font>
<font color="red">        cout &lt;&lt; id &lt;&lt; &quot;</font>:  Port 1, Time <font color="red">&quot; &lt;&lt; pTime() &lt;&lt; &quot;</font>:  Got &quot; &lt;&lt; d &lt;&lt; endl;
      <font color="red"><strong>}</strong></font>
    <font color="red"><strong>}</strong></font>
    pDelay(20);
  <font color="red"><strong>}</strong></font>
<font color="red"><strong>}</strong></font>

int pMain(int argc,const char *argv[])
<font color="red"><strong>{</strong></font> 
  IntChan chan0(5), chan1(5);

  par <font color="red"><strong>{</strong></font>
    producer(0,10,chan0);
    producer(1,100,chan1);
    consumer(0,chan0,chan1);
    consumer(1,chan0,chan1);
  <font color="red"><strong>}</strong></font>
  <strong>return</strong> 0;
<font color="red"><strong>}</strong></font>

</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>In the above example, two producers feed to two consumers.  Both consumers
read from these channels.  This means that if the first consumer reads from
<code>c0</code>, then the second consumer will then read from<code>c1</code>.</p></div>
<!-- Alt Blocks -->
<a name="Alt-Blocks"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">1.2.5.3 Alt Blocks</font>
</h4></div><div class="subsubsection">
<p>An <strong>alt</strong> block allows for unordered selection of data from channels.  Its
syntax is:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"> 
alt <font color="red"><strong>{</strong></font>
  &lt;channel expr&gt; [ . | -&gt; ] port (&lt;value decl&gt;) <font color="red"><strong>{</strong></font> &lt;body&gt; <font color="red"><strong>}</strong></font>
  [ alt <font color="red"><strong>{</strong></font> ... <font color="red"><strong>}</strong></font> ]
  [ afor <font color="red"><strong>{</strong></font> ... <font color="red"><strong>}</strong></font> ]
  [ <font color="red"><strong>{</strong></font> &lt;<strong>default</strong> block&gt; <font color="red"><strong>}</strong></font> ]
<font color="red"><strong>}</strong></font>
 
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>Each <strong>port</strong> statement specifies a channel to be read (the channel expression) and
an optional declaration which will receive the channel value.  The <strong>port</strong> body
has access to this value.  If no value declaration is specified, the channel's
data is not accessible.  This is useful for channels whose data is simply a
boolean state, such as a time-out channel.</p><p>Upon entry to the <strong>alt</strong> block, all channels are checked for data.  If a
channel has data, the body of the corresponding <strong>port</strong> statement is
executed.  If no channels are ready, the thread will sleep until a channel has
data.  If more than one channel is ready, a single port statement is selected
non-deterministically.  </p><p>The <strong>prialt</strong> block should be used when the order of the channels is
important.  For example, use <strong>prialt</strong> when a <em>stop</em> channel should
have a higher priority than the normal data channels.  The syntax is exactly the
same; the only difference is that the channels are guaranteed to be scanned
sequentially, from the top down, when determining if any are ready.</p><p>If a default block is specified, the <strong>alt</strong> block will never cause the thread
to sleep.  Instead, if no channels have data, the default block will be
executed.</p><p><strong>alt</strong> and <strong>afor</strong> (explained below) blocks may be nested within <strong>alt</strong>
blocks.  This allows the user to block on multiple collections of channels, or a
collection of channels plus one or more single channels, etc.</p></div>
<!-- Afor Blocks -->
<a name="Afor-Blocks"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">1.2.5.4 Afor Blocks</font>
</h4></div><div class="subsubsection">
<p>An <strong>afor</strong> block is similar to an <strong>alt</strong> block, except that it allows the user
to loop over a data structure of channels.  Its syntax is:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"> 
afor ( &lt;s1&gt; ; &lt;s2&gt; ; &lt;s3&gt; ) <font color="red"><strong>{</strong></font>
  &lt;channel expr&gt; [ . | -&gt; ] port (&lt;value decl&gt;) <font color="red"><strong>{</strong></font> &lt;body&gt; <font color="red"><strong>}</strong></font>
  [ <font color="red"><strong>{</strong></font> &lt;<strong>default</strong> block&gt; <font color="red"><strong>}</strong></font> ]
<font color="red"><strong>}</strong></font>
 
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>Only a single <strong>port</strong> statement is allowed.  The <strong>afor</strong> block is treated as a
for-loop, looping over all channels specified by the channel expression.  An
iterator variable must be declared in <em>s1</em>; its value is accessible to the
channel expression and the <strong>port</strong>'s body.</p><p>For example, the following code loops over an array of channels.  As in the
<strong>alt</strong> block, the thread will sleep if no channels are ready and there is not a
default block.:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"> 
afor (int i = 0; i != (int)channels.size(); ++i) <font color="red"><strong>{</strong></font>
  channels[i].port (int v) <font color="red"><strong>{</strong></font>
    printf (&quot;Got a value from port %d:  %d\n&quot;,i,v);
    <strong>if</strong> (v &lt; 0) ++donecount;
  <font color="red"><strong>}</strong></font>
<font color="red"><strong>}</strong></font>
 
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>Plasma allows for non-integer index variables but this requires the creation of
an auxiliary data structure, so performance might be a little slower, e.g. using
an iterator rather than an integer as an index.</p><p>There are a few restrictions to follow for the <strong>afor</strong> block:</p><ul class="itemize"><li>You must declare the loop iterator in the first statement of the <strong>afor</strong>
block.</li>
<li>The loop will occur multiple times, so make sure that there are no
side-effects.</li>
<li>You only have access, within the <strong>port</strong> body, to the first loop
iterator variable.  Therefore, avoid fancy <strong>afor</strong> loops which declare multiple
variables in the first statement or update multiple variables in the third
statement.</li>
</ul><p>As noted above, an <strong>afor</strong> block may be nested within an <strong>alt</strong> block.  This
allows you to block on one or more collections and/or to block on a collection
plus one or more single channels.  For example, the following code will block
on a collection and an override channel:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"> 
alt <font color="red"><strong>{</strong></font>
  afor (int i = 0; i != (int)channels.size(); ++i) <font color="red"><strong>{</strong></font>
    channels[i].port (int v) <font color="red"><strong>{</strong></font>
      printf (&quot;Got a value from port %d:  %d\n&quot;,i,v);
      <strong>if</strong> (v &lt; 0) ++donecount;
    <font color="red"><strong>}</strong></font>
  <font color="red"><strong>}</strong></font>
  stopchan.port (bool b) <font color="red"><strong>{</strong></font>
    <strong>if</strong> (b) <font color="red"><strong>{</strong></font>
      printf (&quot;Got a stop command!\n&quot;);
    <font color="red"><strong>}</strong></font>
  <font color="red"><strong>}</strong></font>
<font color="red"><strong>}</strong></font>
 
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>A prioritized version of <strong>afor</strong> exists and is called <strong>priafor</strong>.
This guarantees that the channels will be scanned sequentially.  In general, the
<strong>afor</strong> and <strong>priafor</strong> will behave identically.  However, if the
compiler can determine that the loop is constant, it may choose to unroll an <strong>afor</strong> and then re-order the channel querying.</p></div>
<!-- Shared Data Structures -->
<a name="Shared-Data-Structures"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">1.2.5.5 Shared Data Structures</font>
</h4></div><div class="subsubsection">
<p>Threads may also communicate using shared data structures whose access methods
are protected by special synchronization primitives.  There are two means to do
this.  The easiest is to declare a class as being a mutex class:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog">  pMutex <strong>class</strong> X <font color="red"><strong>{</strong></font> <font color="red"><strong>}</strong></font>;

</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>This will wrap all public methods of class <strong>X</strong>, except for constructors and
its destructor, with serialization code.  To prevent this on a per-method basis,
use the modifier <em>pNoMutex</em>:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"> 
pMutex <strong>class</strong> Foo <font color="red"><strong>{</strong></font>
public:
  <font color="#ffa600"><em>// Not protected.</em></font>
  Foo();
  ~Foo();
  <font color="#ffa600"><em>// Protected.</em></font>
  int a();
  <font color="#ffa600"><em>// Not protected.</em></font>
  pNoMutex int b();
private:
  <font color="#ffa600"><em>// Not protected.</em></font>
  int c();
<font color="red"><strong>}</strong></font>;    
 
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>Be careful with using <em>pNoMutex</em>:  Since it disables serialization, it is
inherently dangerous.  It is useful, though, when you have a constant method
whose return value would not be affected by a thread preemption.  For example, a
method which returns a constant which is only initialized at construction time.</p><p>The other method for creating a shared data structure is to directly use the
<code>pLock()</code> and <code>pUnlock()</code> primitives.  This is more error prone than using
<em>pMutex</em> but might be necessary in some cases, such as for protecting a plain function:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"> 
void msg(const char *fmt, ...) <font color="red"><strong>{</strong></font>
  pLock();
  va_list ap;
  va_start(ap,fmt);
  vprintf(fmt,ap);
  va_end(ap);
  pUnlock();
<font color="red"><strong>}</strong></font>
 
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
</div>
</div><br>
<!-- Power Modeling -->
<a name="Power-Modeling"></a>
<div class="skribesectiontitle"><table width="100%"><tr><td bgcolor="#dedeff"><h3><font color="black">1.3 Power Modeling</font>
</h3></td></tr></table>
</div><div class="section">
<p>Plasma has some simple hooks for supporting power modeling.  The concept is
similar to the way in which time is handled:  A user annotates a model with
explicit energy-consumption information, which is stored on a per-processor
basis.  To obtain power, a thread can be created which regularly queries a
processor for its energy consumption and divides by the sample period.</p><p>The power API is:</p><ul class="itemize"><li><code>energy_t</code>: The basic energy type.  Currently defined as a <code>double</code></li>
<li><code>void pEnergy(energy_t)</code>:  Adds the argument to the current
processor's energy consumption value.</li>
<li><code>energy_t pGetEnergy(Processor p)</code>:  Returns the specified
processor's energy consumption value.  This clears the value.</li>
<li><code>energy_t pReadEnergy(Processor p)</code>:  Returns the specified
processor's energy consumption value.  This does not clear the value.</li>
</ul><p>A reporting thread might look something like:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"> 
void power(int period)
<font color="red"><strong>{</strong></font>
  <strong>while</strong> (1) <font color="red"><strong>{</strong></font>
    cout &lt;&lt; pTime() &lt;&lt; <font color="red">&quot;:  current power:&quot;</font> 
         &lt;&lt; (pGetEnergy(pCurProc())/period) &lt;&lt; <font color="red">&quot;mW&quot;</font> &lt;&lt; endl;
    pDelay(period);
  <font color="red"><strong>}</strong></font>
<font color="red"><strong>}</strong></font>
 
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>Interspersed throughout the code would be calls to record energy usage:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"> 
...
pEnergy(ops * ScaleValue);
...
 
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>A more sophisticated approach might construct a power-model by scaling
energy values by the clock frequency.  Thus, the model might not call <code>pEnergy</code> directly but would instead call a helper function, e.g. <code>myEnergy</code>, which would scale the energy argument and actually call <code>pEnergy</code>.  Other possibilities might include constructing a special channel
class that remembers a previous value and records energy usage based upon the
hamming distance between the previous and current value, or have a very
low-priority thread which adds energy when a processor is idle, attempting to
model leakage current.</p><p>Of course, the power modeling API can be thought of as a specific instance
of the more general concept of storing a value with a particular processor.  In
fact, this is exactly what is done:  The power and energy API is based upon the
<code>ProcValue</code> class, which lets the user hash a value against a
processor.  Its API is:</p><a name="ProcValue" class="mark"></a><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog">  <strong>template</strong> &lt;typename Data&gt;
  <strong>struct</strong> ProcValue : public hash_map&lt;Processor,Data,HashProc&gt; <font color="red"><strong>{</strong></font> 
    <font color="#ffa600"><em>// This adds to the value for the specified processor.</em></font>
    Data add(Processor p,Data d);
    <font color="#ffa600"><em>// This adds to the current processor.</em></font>
    Data add(Data d);
    <font color="#ffa600"><em>// This gets the processor's value and clears the value.</em></font>
    <font color="#ffa600"><em>// Returns Data() if the item is not there.</em></font>
    Data get(Processor p);
    <font color="#ffa600"><em>// Reads the value, </em></font>returns Data() <strong>if</strong> item is not there.
    Data read(Processor p) const;
  <font color="red"><strong>}</strong></font>;

</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>This is a template so that any kind of value can be stored.  The <code>add</code> functions add their argument to the existing value associated with the
specified processor and return this result.  The <code>get</code> routine returns
the current value and clears it in the hash, while the <code>read</code> routine
returns the value without modifying the hash.</p></div><br>
<!-- Resource Modeling -->
<a name="Resource-Modeling"></a>
<div class="skribesectiontitle"><table width="100%"><tr><td bgcolor="#dedeff"><h3><font color="black">1.4 Resource Modeling</font>
</h3></td></tr></table>
</div><div class="section">
<p>The need to model an object with limited resources frequently arises.  For
example, a memory controller has a specific, fixed bandwidth.  Plasma provides a
class, called <code>Quantity</code>, to help with this task.  It works as follows:
The user declares an instance of the class and specifies a timeslice as a
constructor argument.  The timeslice refers to the time it takes to do one
request, e.g. for a memory controller, a single read may take 10 time units.</p><p>Once declared, threads may request an amount <em>n</em>, which will correspond
to <em>n</em> requests.  A thread will busy its processor until the request is
satisfied.  The <code>Quantity</code> class uses a round-robin scheme to satisfy
all in-bound requests: For each thread, it decrements the request by one and
delays by the specified timeslice.  The busy processor is time-sliced so that
higher-priority threads may gain some processing time.</p><p>The interface is:</p><ul class="itemize"><li><code>Quantity::Quantity(int timeslice)</code>:  Declare an instance and
specify the timeslice amount.</li>
<li><code>Quantity::request(int amount)</code>:  Request a specific amount.  If
there are no other requests, then this can be satisfied in <em>(timeslice *
amount)</em> time units, but other requests will stretch this out.</li>
</ul></div><br>
<!-- Garbage Collection -->
<a name="Garbage-Collection"></a>
<div class="skribesectiontitle"><table width="100%"><tr><td bgcolor="#dedeff"><h3><font color="black">1.5 Garbage Collection</font>
</h3></td></tr></table>
</div><div class="section">
<p>Plasma is equipped with a garbage collector.  This means that heap-allocated
objects do not need to be explicitly freed; they will be collected when no more
pointers to the object remain.  This implicitly managed memory (referred to as
simply <em>managed</em> from now on) may be used alongside explicitly managed memory,
where a call to delete is required.</p><p>By default, allocations using <strong>new</strong> are explicitly managed.  To allocate
managed memory, you may derive an object from <strong>gc</strong> or <strong>gc_cleanup</strong> or
allocate using the <strong>GC</strong> or <strong>UseGC</strong> placement attribute.</p><p>For example, the following class will be managed when allocated using <strong>new</strong>:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"> 
<strong>class</strong> A : public gc <font color="red"><strong>{</strong></font> <font color="red"><strong>}</strong></font>;
 
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>However, its destructor will not be called.  If you derive from <strong>gc_cleanup</strong>,
the class's destructor will be called when the object is collected.</p><p>An example of using the <strong>GC</strong> placement attribute is:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"> 
int *x = new (GC) int[1000];
 
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>This will allocate a block of memory that is managed by the collector.</p><p>You may delete memory that is managed, but this is generally discouraged, since
the collector will collect it when it is safe to do so.</p></div><br>
<!-- Miscellaneous Language Features -->
<a name="Miscellaneous-Language-Features"></a>
<div class="skribesectiontitle"><table width="100%"><tr><td bgcolor="#dedeff"><h3><font color="black">1.6 Miscellaneous Language Features</font>
</h3></td></tr></table>
</div><div class="section">
<p>Plasma has a <code>let</code> block which performs simple type inferencing.  The
format of the block is:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog">let (&lt;decl&gt; [,&lt;decl&gt;]) <font color="red"><strong>{</strong></font> 
  &lt;block&gt;
<font color="red"><strong>}</strong></font>

</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>where <code>&lt;decl&gt;</code> may be either a variable declaration with a type, e.g. <code>int result = 2</code>, or without a type.  If a type is not present, the type will
be inferred from the type of the initializing expression.</p><p>A simple example is:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog">let (a = 1, b = 2.2, c = foo()) <font color="red"><strong>{</strong></font>
   ...
<font color="red"><strong>}</strong></font>

</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>In the above example, <code>a</code> will have a type of <code>int</code>, <code>b</code> will
have a type of <code>double</code>, and <code>c</code>'s type will be that of the return
type of <code>foo</code>.</p></div><br>
<!-- Library Features -->
<a name="Library-Features"></a>
<div class="skribesectiontitle"><table width="100%"><tr><td bgcolor="#dedeff"><h3><font color="black">1.7 Library Features</font>
</h3></td></tr></table>
</div><div class="section">
<p>This section describes functions and classes provided by the Plasma standard
library, <code>plasma/plasma.h</code>.</p><!-- I/O Routines -->
<a name="I/O-Routines"></a>
<div class="skribesubsectiontitle"><table width="100%"><tr><td bgcolor="#ffffff"><h3><font color="#8381de">1.7.1 I/O Routines</font>
</h3></td></tr></table>
</div><div class="subsection">
<p>A series of <strong>printf</strong>-style routines are provided which implement
mutex-protected I/O routines.  These are:</p><ul class="itemize"><li><code>int mprintf(const char *format, ... );</code></li>
<li><code>int mfprintf(FILE *,const char *format, ...);</code></li>
<li><code>int mvprintf(const char *format, va_list ap);</code></li>
<li><code>int mvfprintf(FILE *,const char *format,va_list ap);</code></li>
</ul><p>These behave just like the standard routines, except that they are protected
from preemption while they are executing.</p></div>
<!-- String Routines -->
<a name="String-Routines"></a>
<div class="skribesubsectiontitle"><table width="100%"><tr><td bgcolor="#ffffff"><h3><font color="#8381de">1.7.2 String Routines</font>
</h3></td></tr></table>
</div><div class="subsection">
<p>Strings, such as <strong>Processor</strong> names, are garbage collected in Plasma.  This may
interfere with using the C++ string class, since it generally manages its own
memory.  Thus, when passing a string to a <strong>Processor</strong> via <code>setName()</code> or a
constructor, if the string is not a constant, you should duplicate it using <code>gc_strdup()</code>.</p><ul class="itemize"><li><code>char *gc_strdup(const char *);</code></li>
<li><code>char *gc_strdup(const std::string &amp;s);</code></li>
</ul><p>Both of the above routines duplicate their argument using GC-allocated memory.</p></div>
<!-- Random Number Generation -->
<a name="Random-Number-Generation"></a>
<div class="skribesubsectiontitle"><table width="100%"><tr><td bgcolor="#ffffff"><h3><font color="#8381de">1.7.3 Random Number Generation</font>
</h3></td></tr></table>
</div><div class="subsection">
<p>The template <code>Random&lt;Gen&gt;</code> is provided for random number generation.  It takes
as a parameter a generator class, which does the actual work of generating
pseudo-random numbers.  The <em>Random</em> class wraps this generator and provides
various functionality, such as supporting <strong>N</strong> streams of independent
random number generation and the ability to read and write the state of these
generators using C++ streams.</p><p>Several different generators are provided:</p><ul class="itemize"><li><strong>LcgRand</strong>:  Linear-congruential generator with period of 2<sup>32</sup>.  This is a
reversible function.  Its state is stored in one 32-bit word.</li>
<li><strong>KissRand</strong>:  A combination of several generators, it has a period of 2<sup>127</sup>.
It is not reversible.  Its state is stored in 5 32-bit words.</li>
<li><strong>MtRand</strong>:  The Mersenne Twist random number generator has a period of
2<sup>19937</sup>-1.  It is reversible.  Its state is stored in 625 32-bit words.</li>
</ul><p>The default generator is <strong>KissRand</strong>.</p><p>The simplest way to use <strong>Random</strong> is to simply generate an unsigned integer by
calling <code>genrand()</code> or generate a double in the range of [0,1] by calling
<code>gendbl()</code>.  For example:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"> 
Random&lt;&gt; Rand;                <font color="#ffa600"><em>// Instantiate w/default generator.</em></font>

unsigned x = Rand.genrand();  <font color="#ffa600"><em>// Generate uint in </em></font>[0,0xffffffff].
double y = Rand.gendbl();     <font color="#ffa600"><em>// Generate double in </em></font>[0,1].
 
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>To create 3 independent generators with the Mersenne Twist algorithm:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"> 
Random&lt;MtRand&gt; Rand(3);

unsigned x = Rand.genrand(0); <font color="#ffa600"><em>// Generate using stream 0.</em></font>
unsigned y = Rand.genrand(1); <font color="#ffa600"><em>// Generate using stream 1.</em></font>
unsigned z = Rand.genrand(2); <font color="#ffa600"><em>// Generate using stream 2.</em></font>
 
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p>The class can then be saved to a stream, for example to checkpoint the current
state of a simulation:</p><table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"> 
ostringstream os;
Rand.save(os);                <font color="#ffa600"><em>// Save the generators' state.</em></font>

istringstream is(os.str());
Rand.load(is);                <font color="#ffa600"><em>// Load the generators' state.</em></font>
 
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table><p><strong>Random</strong> may also generate numbers using several distributions.
Currently, the distribution functions only support unsigned integers.  The
various distributions are shown below.  For each function, the first parameter
specifies which stream to use for generation.</p><ul class="itemize"><li><code>unsigned uniform(unsigned s,unsigned base,unsigned limit)</code>:
Generates a uniform random number in [<em>base</em>, <em>limit</em>].  The
<em>limit</em> must be greater than <em>base</em>.</li>
<li><code>unsigned triangle(unsigned s,unsigned l,unsigned mode,unsigned
u)</code>: Generates using a triangle distribution in [<em>l</em>, <em>u</em> \),
with the peak of the distribution specified by <em>mode</em>.  Upper must be
greater than lower.</li>
<li><code>unsigned exponential(unsigned s,unsigned scale,double lambda)</code>:
Generates an exponential distribution in [0, <em>scale</em> \) with <em>lambda</em> describing the fall-off rate.</li>
<li><code>unsigned normal(unsigned s,unsigned mean,double std_dev)</code>:
Generates a normal distribution with the curve centered around <em>mean</em>.</li>
</ul></div>
</div><br>
</div></td>
</tr></table><div class="skribe-ending">
<hr> 
<p class="ending"><font size="-1">
This <span class="sc">Html</span> page has been produced by 
<a href="http://www.inria.fr/mimosa/fp/Skribe" class="http">Skribe</a>.
<br/>
Last update <em>Wed Nov  9 18:15:18 2005</em>.</font></p></div>
</body>
</html>