<!-- 95% W3C COMPLIANT, 95% CSS FREE, RAW HTML -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=ISO-8859-1">
<title>Example Source Code</title>
 <style type="text/css">
  <!--
  pre { font-family: monospace }
  tt { font-family: monospace }
  code { font-family: monospace }
  p.flushright { text-align: right }
  p.flushleft { text-align: left }
  span.sc { font-variant: small-caps }
  span.sf { font-family: sans-serif }
  span.skribetitle { font-family: sans-serif; font-weight: bolder; font-size: x-large; }
  -->
 </style>
</head>

<body class="section" bgcolor="#ffffff">
<table width="100%" class="skribetitle" cellspacing="0" cellpadding="0"><tbody>
<tr><td align="center" bgcolor="#8381de"><div class="skribetitle"><strong><big><big><big>5 Example Source Code -- Desktop Application Example</big></big></big></strong></div><center>
</center>
</td></tr></tbody></table>
<table cellpadding="3" cellspacing="0" width="100%" class="skribe-margins"><tr>
<td align="left" valign="top" class="skribe-left-margin" width="20%" bgcolor="#dedeff"><div class="skribe-left-margin">
<br/><center><table width="97%" border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse;" frame="box" rules="none"><tbody>
<tr bgcolor="#8381de"><th align="center" colspan="1"><font color="#ffffff"><strong>main page</strong></font></th></tr>
<tr bgcolor="#ffffff"><td align="center" colspan="1"><table width="100%" border="0" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="left" valign="top" colspan="1"><strong>top:</strong></td><td align="right" valign="top" colspan="1"><a href="source-code.html#Example-Source-Code" class="inbound">Example Source Code</a></td></tr>
</tbody></table>
</td></tr>
</tbody></table>
</center>
<br/><br/><center><table width="97%" border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse;" frame="box" rules="none"><tbody>
<tr bgcolor="#8381de"><th align="center" colspan="1"><font color="#ffffff"><strong>Sections</strong></font></th></tr>
<tr bgcolor="#ffffff"><td align="center" colspan="1"><table cellspacing="1" cellpadding="1" width="100%" class="toc">
<tbody>
 <tr><td valign="top" align="left">1</td><td colspan="4" width="100%"><a href="source-code-1.html#RISC-Pipeline-Example">RISC Pipeline Example</a></td></tr>
 <tr><td></td><td valign="top" align="left">1.1</td><td colspan="3" width="100%"><a href="source-code-1.html#sw/pipe.pa">sw/pipe.pa</a></td></tr>
 <tr><td valign="top" align="left">2</td><td colspan="4" width="100%"><a href="source-code-2.html#RISC-Pipeline-Example-2">RISC Pipeline Example 2</a></td></tr>
 <tr><td></td><td valign="top" align="left">2.1</td><td colspan="3" width="100%"><a href="source-code-2.html#../doc/pipe2.pa">../doc/pipe2.pa</a></td></tr>
 <tr><td valign="top" align="left">3</td><td colspan="4" width="100%"><a href="source-code-3.html#Network-System-Example">Network System Example</a></td></tr>
 <tr><td></td><td valign="top" align="left">3.1</td><td colspan="3" width="100%"><a href="source-code-3.html#eav/eav.pa">eav/eav.pa</a></td></tr>
 <tr><td valign="top" align="left">4</td><td colspan="4" width="100%"><a href="source-code-4.html#Embedded-Application-Example">Embedded Application Example</a></td></tr>
 <tr><td></td><td valign="top" align="left">4.1</td><td colspan="3" width="100%"><a href="source-code-4.html#Header-Files">Header Files</a></td></tr>
 <tr><td></td><td valign="top" align="left">4.2</td><td colspan="3" width="100%"><a href="source-code-4.html#Implementation-Files">Implementation Files</a></td></tr>
 <tr><td valign="top" align="left">5</td><td colspan="4" width="100%"><a href="source-code-5.html#Desktop-Application-Example">Desktop Application Example</a></td></tr>
 <tr><td></td><td valign="top" align="left">5.1</td><td colspan="3" width="100%"><a href="source-code-5.html#Main-Program">Main Program</a></td></tr>
 <tr><td></td><td valign="top" align="left">5.2</td><td colspan="3" width="100%"><a href="source-code-5.html#Compiler-Driver">Compiler Driver</a></td></tr>
 <tr><td></td><td valign="top" align="left">5.3</td><td colspan="3" width="100%"><a href="source-code-5.html#Lexer">Lexer</a></td></tr>
 <tr><td></td><td valign="top" align="left">5.4</td><td colspan="3" width="100%"><a href="source-code-5.html#Parser">Parser</a></td></tr>
 <tr><td></td><td valign="top" align="left">5.5</td><td colspan="3" width="100%"><a href="source-code-5.html#"></a></td></tr>
 <tr><td></td><td valign="top" align="left">5.6</td><td colspan="3" width="100%"><a href="source-code-5.html#Symbol-Table">Symbol Table</a></td></tr>
 <tr><td></td><td valign="top" align="left">5.7</td><td colspan="3" width="100%"><a href="source-code-5.html#Code-Generation">Code Generation</a></td></tr>
 <tr><td></td><td valign="top" align="left">5.8</td><td colspan="3" width="100%"><a href="source-code-5.html#Register-Allocation">Register Allocation</a></td></tr>
 <tr><td></td><td valign="top" align="left">5.9</td><td colspan="3" width="100%"><a href="source-code-5.html#Assembly-Code-Writer">Assembly Code Writer</a></td></tr>
 <tr><td></td><td valign="top" align="left">5.10</td><td colspan="3" width="100%"><a href="source-code-5.html#String-Class">String Class</a></td></tr>
 <tr><td></td><td valign="top" align="left">5.11</td><td colspan="3" width="100%"><a href="source-code-5.html#Miscellaneous-Headers">Miscellaneous Headers</a></td></tr>
</tbody>
</table>
</td></tr>
</tbody></table>
</center>
</div></td>
<td align="left" valign="top" class="skribe-body"><div class="skribe-body">
<!-- Main Program -->
<a name="Main-Program"></a>
<div class="skribesubsectiontitle"><table width="100%"><tr><td bgcolor="#ffffff"><h3><font color="#8381de">5.1 Main Program</font>
</h3></td></tr></table>
</div><div class="subsection">
<!-- cc/main.pa -->
<a name="cc/main.pa"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">5.1.1 cc/main.pa</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em>  1: </em><font color="#ffa600"><em>//</em></font>
<em>  2: </em><font color="#ffa600"><em>// Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.</em></font>
<em>  3: </em><font color="#ffa600"><em>//</em></font>
<em>  4: </em><font color="#ffa600"><em>// You may distribute under the terms of the Artistic License, as specified in</em></font>
<em>  5: </em><font color="#ffa600"><em>// the COPYING file.</em></font>
<em>  6: </em><font color="#ffa600"><em>//</em></font>
<em>  7: </em>
<em>  8: </em><font color="#1919af"><strong>#include</strong></font> &lt;iostream&gt;
<em>  9: </em>
<em> 10: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;String.h&quot;</font>
<em> 11: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;CLexer.h&quot;</font>
<em> 12: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;CParser.h&quot;</font>
<em> 13: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;Channels.h&quot;</font>
<em> 14: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;Compiler.h&quot;</font>
<em> 15: </em>
<em> 16: </em>using namespace plasma;
<em> 17: </em>using namespace std;
<em> 18: </em>
<em> 19: </em>void tokenize(TokChan &amp;tc);
<em> 20: </em>void parse(TokChan &amp;tc);
<em> 21: </em>
<em> 22: </em><font color="#ffa600"><em>// Options singleton structure.</em></font>
<em> 23: </em><strong>struct</strong> Options <font color="red"><strong>{</strong></font>
<em> 24: </em>  bool                 _debug; <font color="#ffa600"><em>// Show parser debug info.</em></font>
<em> 25: </em>  bool                 _ast;   <font color="#ffa600"><em>// Generate AST.</em></font>
<em> 26: </em>  bool                 _syms;  <font color="#ffa600"><em>// Print AST + symbols.</em></font>
<em> 27: </em>  bool                 _check; <font color="#ffa600"><em>// Stop after checking phase.</em></font>
<em> 28: </em>  vector&lt;const char *&gt; _files; <font color="#ffa600"><em>// Files to parse.       </em></font>
<em> 29: </em>
<em> 30: </em>  Options() :
<em> 31: </em>    _debug(false),
<em> 32: </em>    _ast(false),
<em> 33: </em>    _syms(false),
<em> 34: </em>    _check(false)
<em> 35: </em>  <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em> 36: </em><font color="red"><strong>}</strong></font>;
<em> 37: </em>
<em> 38: </em>Options options;
<em> 39: </em>
<em> 40: </em>bool parseOptions(int argc,const char *argv[])
<em> 41: </em><font color="red"><strong>{</strong></font>
<em> 42: </em>  <strong>if</strong> (argc &lt; 2) <font color="red"><strong>{</strong></font>
<em> 43: </em>    <strong>return</strong> false;
<em> 44: </em>  <font color="red"><strong>}</strong></font>
<em> 45: </em>  <strong>for</strong> (int i = 1; i &lt; argc; ++i) <font color="red"><strong>{</strong></font>
<em> 46: </em>    <strong>if</strong> (!strcmp(argv[i],<font color="red">&quot;-ast&quot;</font>)) <font color="red"><strong>{</strong></font>
<em> 47: </em>      options._ast = true;
<em> 48: </em>    <font color="red"><strong>}</strong></font>
<em> 49: </em>    <strong>else</strong> <strong>if</strong> (!strcmp(argv[i],<font color="red">&quot;-syms&quot;</font>)) <font color="red"><strong>{</strong></font>
<em> 50: </em>      options._ast = true;
<em> 51: </em>      options._syms = true;
<em> 52: </em>    <font color="red"><strong>}</strong></font>
<em> 53: </em>    <strong>else</strong> <strong>if</strong> (!strcmp(argv[i],<font color="red">&quot;-check&quot;</font>)) <font color="red"><strong>{</strong></font>
<em> 54: </em>      options._check = true;
<em> 55: </em>    <font color="red"><strong>}</strong></font>
<em> 56: </em>    <strong>else</strong> <strong>if</strong> (!strcmp(argv[i],<font color="red">&quot;-d&quot;</font>)) <font color="red"><strong>{</strong></font>
<em> 57: </em>      options._debug = true;
<em> 58: </em>    <font color="red"><strong>}</strong></font>
<em> 59: </em>    <strong>else</strong> <font color="red"><strong>{</strong></font>
<em> 60: </em>      int len = strlen(argv[i]);
<em> 61: </em>      <strong>if</strong> (len &gt; 2 &amp;&amp; !strcmp(&amp;argv[i][len-2],<font color="red">&quot;.c&quot;</font>)) <font color="red"><strong>{</strong></font>
<em> 62: </em>        options._files.push_back(argv[i]);
<em> 63: </em>      <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em> 64: </em>        cerr &lt;&lt; <font color="red">&quot;Error:  Unknown option &quot;</font> &lt;&lt; argv[i] &lt;&lt; <font color="red">&quot;\n\n&quot;</font>;
<em> 65: </em>        <strong>return</strong> false;
<em> 66: </em>      <font color="red"><strong>}</strong></font>
<em> 67: </em>    <font color="red"><strong>}</strong></font>
<em> 68: </em>  <font color="red"><strong>}</strong></font>
<em> 69: </em>  <strong>if</strong> (options._files.empty()) <font color="red"><strong>{</strong></font>
<em> 70: </em>    cerr &lt;&lt; <font color="red">&quot;Error:  No input files were specified.\n\n&quot;</font>;
<em> 71: </em>    <strong>return</strong> false;
<em> 72: </em>  <font color="red"><strong>}</strong></font>
<em> 73: </em>  <strong>return</strong> true;
<em> 74: </em><font color="red"><strong>}</strong></font>
<em> 75: </em>
<em> 76: </em>int pMain(int argc,const char *argv[])
<em> 77: </em><font color="red"><strong>{</strong></font>
<em> 78: </em>  <strong>if</strong> (!parseOptions(argc,argv)) <font color="red"><strong>{</strong></font>
<em> 79: </em>    cerr &lt;&lt; <font color="red">&quot;Usage:  &quot;</font> &lt;&lt; argv[0] &lt;&lt; <font color="red">&quot; &lt;filename(s) | options&gt;...\n\n&quot;</font>
<em> 80: </em>         &lt;&lt; <font color="red">&quot;Options:\n&quot;</font>
<em> 81: </em>         &lt;&lt; <font color="red">&quot;  -ast     :  Print the AST to standard-out and exit.\n&quot;</font>
<em> 82: </em>         &lt;&lt; <font color="red">&quot;  -syms    :  Print the AST w/symbol information and exit.\n&quot;</font>
<em> 83: </em>         &lt;&lt; <font color="red">&quot;  -check   :  Perform checking steps, then exit.  Do not write any code.\n&quot;</font>
<em> 84: </em>         &lt;&lt; <font color="red">&quot;  -d       :  Enable debug parsing information.\n&quot;</font>
<em> 85: </em>         &lt;&lt; <font color="red">&quot;\n&quot;</font>;
<em> 86: </em>    <strong>return</strong> 1;
<em> 87: </em>  <font color="red"><strong>}</strong></font>
<em> 88: </em>
<em> 89: </em>  TokChan tc;
<em> 90: </em>
<em> 91: </em>  par <font color="red"><strong>{</strong></font>
<em> 92: </em>    tokenize(tc);
<em> 93: </em>    parse(tc);
<em> 94: </em>  <font color="red"><strong>}</strong></font>
<em> 95: </em>  cerr &lt;&lt; <font color="red">&quot;\nCompile succeeded.&quot;</font> &lt;&lt; endl;
<em> 96: </em>  <strong>return</strong> 0;
<em> 97: </em><font color="red"><strong>}</strong></font>
<em> 98: </em>
<em> 99: </em>void tokenize(TokChan &amp;tc)
<em>100: </em><font color="red"><strong>{</strong></font>
<em>101: </em>  <strong>try</strong> <font color="red"><strong>{</strong></font>
<em>102: </em>    CLexer cl(tc);
<em>103: </em>    <font color="#ffa600"><em>// Tokenize all files.</em></font>
<em>104: </em>    <strong>for</strong> (unsigned i = 0; i != options._files.size(); ++i) <font color="red"><strong>{</strong></font>
<em>105: </em>      cl.reset(options._files[i]);
<em>106: </em>      cl.yylex();
<em>107: </em>    <font color="red"><strong>}</strong></font>
<em>108: </em>    cl.send_alldone();
<em>109: </em>  <font color="red"><strong>}</strong></font>
<em>110: </em>  <strong>catch</strong> (exception &amp;err) <font color="red"><strong>{</strong></font>
<em>111: </em>    cerr &lt;&lt; err.what() &lt;&lt; endl;
<em>112: </em>    pExit(1);
<em>113: </em>  <font color="red"><strong>}</strong></font>
<em>114: </em><font color="red"><strong>}</strong></font>
<em>115: </em>
<em>116: </em>void parse(TokChan &amp;tc)
<em>117: </em><font color="red"><strong>{</strong></font>
<em>118: </em>  Compiler compiler;
<em>119: </em>  CParser parser(options._debug);
<em>120: </em>  BoolCheck results(make_boolcheck(true));
<em>121: </em>  <strong>while</strong>(!parser.error()) <font color="red"><strong>{</strong></font>
<em>122: </em>    Tokens tk = tc.get();
<em>123: </em>    <strong>if</strong> (tk._tok &lt; 0) <strong>break</strong>;
<em>124: </em>    parser.parse(tk._tok,tk);
<em>125: </em>    <strong>if</strong> (!tk._tok) <font color="red"><strong>{</strong></font>
<em>126: </em>      <font color="#ffa600"><em>// End of file reached- spawn off a compile job for this translation</em></font>
<em>127: </em>      <font color="#ffa600"><em>// unit and reset the parser for the next file.</em></font>
<em>128: </em>      results.push_back(spawn(compiler.compileUnit(parser.lastUnit(),parser.filename(),options._ast,options._check)));
<em>129: </em>      parser.reset();
<em>130: </em>    <font color="red"><strong>}</strong></font>
<em>131: </em>  <font color="red"><strong>}</strong></font>
<em>132: </em>  <font color="#ffa600"><em>// If we have a parsing error, exit.</em></font>
<em>133: </em>  <strong>if</strong> (parser.error()) <font color="red"><strong>{</strong></font>
<em>134: </em>    pExit(1);
<em>135: </em>  <font color="red"><strong>}</strong></font>
<em>136: </em>  <font color="#ffa600"><em>// Synchronize by making sure all compile threads are done.</em></font>
<em>137: </em>  <font color="#ffa600"><em>// Exit w/error if any report an error.</em></font>
<em>138: </em>  <strong>if</strong> (!results.check()) <font color="red"><strong>{</strong></font>
<em>139: </em>    pExit(2);
<em>140: </em>  <font color="red"><strong>}</strong></font>
<em>141: </em>  <font color="#ffa600"><em>// Print ASTs, if so requested.</em></font>
<em>142: </em>  <strong>if</strong> (options._ast) <font color="red"><strong>{</strong></font>
<em>143: </em>    parser.print_ast_list(cout,options._syms);
<em>144: </em>  <font color="red"><strong>}</strong></font>
<em>145: </em><font color="red"><strong>}</strong></font>
<em>146: </em>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
</div>
<!-- Compiler Driver -->
<a name="Compiler-Driver"></a>
<div class="skribesubsectiontitle"><table width="100%"><tr><td bgcolor="#ffffff"><h3><font color="#8381de">5.2 Compiler Driver</font>
</h3></td></tr></table>
</div><div class="subsection">
<!-- cc/Compiler.h -->
<a name="cc/Compiler.h"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">5.2.1 cc/Compiler.h</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em> 1: </em><font color="#ffa600"><em>//</em></font>
<em> 2: </em><font color="#ffa600"><em>// Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.</em></font>
<em> 3: </em><font color="#ffa600"><em>//</em></font>
<em> 4: </em><font color="#ffa600"><em>// You may distribute under the terms of the Artistic License, as specified in</em></font>
<em> 5: </em><font color="#ffa600"><em>// the COPYING file.</em></font>
<em> 6: </em><font color="#ffa600"><em>//</em></font>
<em> 7: </em><font color="#ffa600"><em>//</em></font>
<em> 8: </em><font color="#ffa600"><em>// This class takes ASTs and performs all of the compilation passes.</em></font>
<em> 9: </em><font color="#ffa600"><em>//</em></font>
<em>10: </em>
<em>11: </em>#ifndef _COMPILER_H_
<em>12: </em><font color="#1919af"><strong>#define</strong></font> _COMPILER_H_
<em>13: </em>
<em>14: </em><font color="#1919af"><strong>#include</strong></font> &lt;iosfwd&gt;
<em>15: </em>
<em>16: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;Types.h&quot;</font>
<em>17: </em>
<em>18: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;gc/gc_cpp.h&quot;</font>
<em>19: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;gc/gc_allocator.h&quot;</font>
<em>20: </em>
<em>21: </em><strong>class</strong> Node;
<em>22: </em><strong>class</strong> CodeGen;
<em>23: </em>
<em>24: </em><strong>class</strong> Compiler <font color="red"><strong>{</strong></font>
<em>25: </em>public:
<em>26: </em>  Compiler();
<em>27: </em>
<em>28: </em>  <font color="#ffa600"><em>// sym_only:    Stop after symbol table creation.</em></font>
<em>29: </em>  <font color="#ffa600"><em>// check_only:  Stop after type-checking and flow control analysis.</em></font>
<em>30: </em>  <font color="#ffa600"><em>// return:      False:  An error occurred.</em></font>
<em>31: </em>  bool compileUnit(Node *,const char *filename,bool sym_only,bool check_only);
<em>32: </em>
<em>33: </em><font color="red"><strong>}</strong></font>;
<em>34: </em>
<em>35: </em><font color="#1919af"><strong>#endif</strong></font>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
<!-- cc/Compiler.pa -->
<a name="cc/Compiler.pa"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">5.2.2 cc/Compiler.pa</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em> 1: </em><font color="#ffa600"><em>//</em></font>
<em> 2: </em><font color="#ffa600"><em>// Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.</em></font>
<em> 3: </em><font color="#ffa600"><em>//</em></font>
<em> 4: </em><font color="#ffa600"><em>// You may distribute under the terms of the Artistic License, as specified in</em></font>
<em> 5: </em><font color="#ffa600"><em>// the COPYING file.</em></font>
<em> 6: </em><font color="#ffa600"><em>//</em></font>
<em> 7: </em><font color="#ffa600"><em>//</em></font>
<em> 8: </em><font color="#ffa600"><em>// This class takes ASTs and performs all of the compilation passes.</em></font>
<em> 9: </em><font color="#ffa600"><em>//</em></font>
<em>10: </em>
<em>11: </em><font color="#1919af"><strong>#include</strong></font> &lt;iostream&gt;
<em>12: </em><font color="#1919af"><strong>#include</strong></font> &lt;stdexcept&gt;
<em>13: </em>
<em>14: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;Compiler.h&quot;</font>
<em>15: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;SymTab.h&quot;</font>
<em>16: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;Node.h&quot;</font>
<em>17: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;CodeGen.h&quot;</font>
<em>18: </em>
<em>19: </em>using namespace std;
<em>20: </em>using namespace plasma;
<em>21: </em>
<em>22: </em>Compiler::Compiler( )
<em>23: </em><font color="red"><strong>{</strong></font>
<em>24: </em><font color="red"><strong>}</strong></font>
<em>25: </em>
<em>26: </em>string get_outname(const char *filename)
<em>27: </em><font color="red"><strong>{</strong></font>
<em>28: </em>  string outname = filename;
<em>29: </em>  size_t pos = outname.rfind(<font color="red">&quot;.c&quot;</font>);
<em>30: </em>  <strong>if</strong> (pos != string::npos) <font color="red"><strong>{</strong></font>
<em>31: </em>    outname = outname.substr(0,pos) + <font color="red">&quot;.s&quot;</font>;
<em>32: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em>33: </em>    outname = outname + <font color="red">&quot;.s&quot;</font>;
<em>34: </em>  <font color="red"><strong>}</strong></font>
<em>35: </em>  pos = outname.rfind(<font color="red">&quot;/&quot;</font>);
<em>36: </em>  <strong>if</strong> (pos != string::npos) <font color="red"><strong>{</strong></font>
<em>37: </em>    outname = outname.substr(pos+1);
<em>38: </em>  <font color="red"><strong>}</strong></font>
<em>39: </em>  <strong>return</strong> outname;
<em>40: </em><font color="red"><strong>}</strong></font>
<em>41: </em>
<em>42: </em><font color="#ffa600"><em>// Compile a translation unit.</em></font>
<em>43: </em>bool Compiler::compileUnit(Node *tu,const char *filename,bool sym_only,bool check_only)
<em>44: </em><font color="red"><strong>{</strong></font>
<em>45: </em>  <font color="#ffa600"><em>// First, we generate the symbol table.  This has to be done serially b/c of</em></font>
<em>46: </em>  <font color="#ffa600"><em>// the sequential nature of C, i.e. symbols are visible in the order in which</em></font>
<em>47: </em>  <font color="#ffa600"><em>// they appear in the file.</em></font>
<em>48: </em>  <strong>try</strong> <font color="red"><strong>{</strong></font>
<em>49: </em>    tu-&gt;gensymtab();
<em>50: </em>  <font color="red"><strong>}</strong></font>
<em>51: </em>  <strong>catch</strong> (exception &amp;err) <font color="red"><strong>{</strong></font>
<em>52: </em>    cerr &lt;&lt; err.what() &lt;&lt; endl;
<em>53: </em>    <strong>return</strong> false;
<em>54: </em>  <font color="red"><strong>}</strong></font>
<em>55: </em>  <strong>if</strong> (sym_only) <font color="red"><strong>{</strong></font>
<em>56: </em>    <strong>return</strong> true;
<em>57: </em>  <font color="red"><strong>}</strong></font>
<em>58: </em>
<em>59: </em>  <font color="#ffa600"><em>// Main global generator- creates shared data.</em></font>
<em>60: </em>  CodeGen maingen(true);
<em>61: </em>
<em>62: </em>  <font color="#ffa600"><em>// Do checking stages.</em></font>
<em>63: </em>  <strong>if</strong> (!tu-&gt;dochecks(maingen)) <font color="red"><strong>{</strong></font>
<em>64: </em>    <strong>return</strong> false;
<em>65: </em>  <font color="red"><strong>}</strong></font>
<em>66: </em>
<em>67: </em>  <font color="#ffa600"><em>// Exit if that's all we're supposed to do.</em></font>
<em>68: </em>  <strong>if</strong> (check_only) <font color="red"><strong>{</strong></font>
<em>69: </em>    <strong>return</strong> true;
<em>70: </em>  <font color="red"><strong>}</strong></font>
<em>71: </em>
<em>72: </em>  <strong>try</strong> <font color="red"><strong>{</strong></font>
<em>73: </em>    <font color="#ffa600"><em>// Next, generate global variables.</em></font>
<em>74: </em>    <font color="#ffa600"><em>// This is done serially.</em></font>
<em>75: </em>    maingen.handleGlobals(tu);
<em>76: </em>
<em>77: </em>    <font color="#ffa600"><em>// Generate main code.  This is done in parallel.</em></font>
<em>78: </em>    tu-&gt;codegen(maingen);
<em>79: </em>    
<em>80: </em>    <font color="#ffa600"><em>// Create output name from input name.</em></font>
<em>81: </em>    string outname = get_outname(filename);
<em>82: </em>
<em>83: </em>    cout &lt;&lt; <font color="red">&quot;\n&quot;</font> &lt;&lt; filename &lt;&lt; <font color="red">&quot; -&gt; &quot;</font> &lt;&lt; outname &lt;&lt; <font color="red">&quot;\n&quot;</font>;
<em>84: </em>    
<em>85: </em>    <font color="#ffa600"><em>// Write out all assembly data.</em></font>
<em>86: </em>    maingen.write(outname,tu);
<em>87: </em>  <font color="red"><strong>}</strong></font>
<em>88: </em>  <strong>catch</strong> (exception &amp;err) <font color="red"><strong>{</strong></font>
<em>89: </em>    cerr &lt;&lt; err.what() &lt;&lt; endl;
<em>90: </em>    <strong>return</strong> false;
<em>91: </em>  <font color="red"><strong>}</strong></font>
<em>92: </em>  <strong>return</strong> true;
<em>93: </em><font color="red"><strong>}</strong></font>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
</div>
<!-- Lexer -->
<a name="Lexer"></a>
<div class="skribesubsectiontitle"><table width="100%"><tr><td bgcolor="#ffffff"><h3><font color="#8381de">5.3 Lexer</font>
</h3></td></tr></table>
</div><div class="subsection">
<!-- cc/Tokens.h -->
<a name="cc/Tokens.h"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">5.3.1 cc/Tokens.h</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em> 1: </em><font color="#ffa600"><em>//</em></font>
<em> 2: </em><font color="#ffa600"><em>// Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.</em></font>
<em> 3: </em><font color="#ffa600"><em>//</em></font>
<em> 4: </em><font color="#ffa600"><em>// You may distribute under the terms of the Artistic License, as specified in</em></font>
<em> 5: </em><font color="#ffa600"><em>// the COPYING file.</em></font>
<em> 6: </em><font color="#ffa600"><em>//</em></font>
<em> 7: </em><font color="#ffa600"><em>//</em></font>
<em> 8: </em><font color="#ffa600"><em>// This defines the Tokens structure, which is used to pass data from</em></font>
<em> 9: </em><font color="#ffa600"><em>// the tokenizer to the parser.</em></font>
<em>10: </em><font color="#ffa600"><em>//</em></font>
<em>11: </em>
<em>12: </em>#ifndef _TOKENS_H_
<em>13: </em><font color="#1919af"><strong>#define</strong></font> _TOKENS_H_
<em>14: </em>
<em>15: </em><strong>struct</strong> Tokens <font color="red"><strong>{</strong></font>
<em>16: </em>  int _tok;        <font color="#ffa600"><em>// The token itself- these are defined by lemon.</em></font>
<em>17: </em>  int _ln;         <font color="#ffa600"><em>// Line number.</em></font>
<em>18: </em>  const char *_fn; <font color="#ffa600"><em>// File name.</em></font>
<em>19: </em>  <strong>union</strong> <font color="red"><strong>{</strong></font>
<em>20: </em>    <font color="#ffa600"><em>// For strings or identifiers:  Pointer to the</em></font>
<em>21: </em>    <font color="#ffa600"><em>// data and its length.</em></font>
<em>22: </em>    <strong>struct</strong> <font color="red"><strong>{</strong></font>
<em>23: </em>      const char *p;
<em>24: </em>      int l;
<em>25: </em>    <font color="red"><strong>}</strong></font> _str;
<em>26: </em>    <font color="#ffa600"><em>// For integer data.</em></font>
<em>27: </em>    int _int;
<em>28: </em>    <font color="#ffa600"><em>// For floating point data.</em></font>
<em>29: </em>    double _fp;
<em>30: </em>  <font color="red"><strong>}</strong></font>;
<em>31: </em><font color="red"><strong>}</strong></font>;
<em>32: </em>
<em>33: </em><font color="#ffa600"><em>// This is explicitly defined b/c it's not generated by the tokenizer-</em></font>
<em>34: </em><font color="#ffa600"><em>// it's used to signal that all files have been parsed.</em></font>
<em>35: </em><font color="#1919af"><strong>#define</strong></font> ALL_DONE -1
<em>36: </em>
<em>37: </em><font color="#1919af"><strong>#endif</strong></font>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
<!-- cc/CFlexLexer.h -->
<a name="cc/CFlexLexer.h"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">5.3.2 cc/CFlexLexer.h</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em> 1: </em><font color="#ffa600"><em>//</em></font>
<em> 2: </em><font color="#ffa600"><em>// Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.</em></font>
<em> 3: </em><font color="#ffa600"><em>//</em></font>
<em> 4: </em><font color="#ffa600"><em>// You may distribute under the terms of the Artistic License, as specified in</em></font>
<em> 5: </em><font color="#ffa600"><em>// the COPYING file.</em></font>
<em> 6: </em><font color="#ffa600"><em>//</em></font>
<em> 7: </em><font color="#ffa600"><em>//</em></font>
<em> 8: </em><font color="#ffa600"><em>// Don't include this directly- include CLexer.h to wrap this.</em></font>
<em> 9: </em><font color="#ffa600"><em>//</em></font>
<em>10: </em><font color="#ffa600"><em>// The tokenizer class.  This is a re-entrant C class</em></font>
<em>11: </em><font color="#ffa600"><em>// that does our tokenizing.  It reads from a file by</em></font>
<em>12: </em><font color="#ffa600"><em>// mmaping it.</em></font>
<em>13: </em><font color="#ffa600"><em>//</em></font>
<em>14: </em><font color="#ffa600"><em>// Note:  To use this header, you must include it like this:</em></font>
<em>15: </em><font color="#ffa600"><em>//         #undef yyFlexLexer</em></font>
<em>16: </em><font color="#ffa600"><em>//         #define yyFlexLexer cFlexLexer</em></font>
<em>17: </em><font color="#ffa600"><em>//         #include &quot;FlexLexer.h&quot;</em></font>
<em>18: </em><font color="#ffa600"><em>//         #include &quot;CLexer.h&quot;</em></font>
<em>19: </em>
<em>20: </em>#ifndef _CFLEXLEXER_H_
<em>21: </em><font color="#1919af"><strong>#define</strong></font> _CFLEXLEXER_H_
<em>22: </em>
<em>23: </em><font color="#1919af"><strong>#include</strong></font> &lt;string&gt;
<em>24: </em>
<em>25: </em><strong>struct</strong> TokChan;
<em>26: </em><strong>struct</strong> Tokens;
<em>27: </em>
<em>28: </em><strong>class</strong> CLexer : public cFlexLexer <font color="red"><strong>{</strong></font>
<em>29: </em>
<em>30: </em>public:
<em>31: </em>
<em>32: </em>  CLexer(TokChan &amp;);
<em>33: </em>  CLexer(TokChan &amp;,const char *filename);
<em>34: </em>  ~CLexer();
<em>35: </em>
<em>36: </em>  void reset(const char *filename);
<em>37: </em>
<em>38: </em>  const char *filename() const <font color="red"><strong>{</strong></font> <strong>return</strong> _filename; <font color="red"><strong>}</strong></font>;
<em>39: </em>  unsigned linenumber() const <font color="red"><strong>{</strong></font> <strong>return</strong> _linenumber; <font color="red"><strong>}</strong></font>;
<em>40: </em>
<em>41: </em>  <font color="#ffa600"><em>// Main parsing routine.</em></font>
<em>42: </em>  int yylex();
<em>43: </em>
<em>44: </em>  <font color="#ffa600"><em>// Sends an all-done signal on the channel.</em></font>
<em>45: </em>  void send_alldone();
<em>46: </em>
<em>47: </em>protected:
<em>48: </em>  <font color="#ffa600"><em>// Send a token and linenumber.</em></font>
<em>49: </em>  void send(int tk);
<em>50: </em>  <font color="#ffa600"><em>// Sends an identifier.</em></font>
<em>51: </em>  void send_ident();
<em>52: </em>  <font color="#ffa600"><em>// Sends an integer constant.</em></font>
<em>53: </em>  void send_int();
<em>54: </em>  <font color="#ffa600"><em>// Sends a floating-point constant.</em></font>
<em>55: </em>  void send_float();
<em>56: </em>  <font color="#ffa600"><em>// Send a character constant.</em></font>
<em>57: </em>  void send_char();
<em>58: </em>  <font color="#ffa600"><em>// Sends a string literal.  Currently this does not do </em></font>
<em>59: </em>  <font color="#ffa600"><em>// any character translation- this needs to be fixed in the future.</em></font>
<em>60: </em>  void send_string();
<em>61: </em>
<em>62: </em>  const char *yystr();
<em>63: </em>
<em>64: </em>  virtual int LexerInput( char* buf, int max_size );
<em>65: </em>
<em>66: </em>private:
<em>67: </em>  void tksetup(Tokens &amp;tk,int t);
<em>68: </em>
<em>69: </em>  int convert_char(const char *str,int len);
<em>70: </em>  void closefile();
<em>71: </em>
<em>72: </em>  const char *_filename;
<em>73: </em>  unsigned    _linenumber;
<em>74: </em>
<em>75: </em>  TokChan    &amp;_chan;
<em>76: </em>
<em>77: </em>  int         _fd;
<em>78: </em>  const char *_base;
<em>79: </em>  const char *_prevpos;
<em>80: </em>  const char *_srcbase;
<em>81: </em>  const char *_bufbase;
<em>82: </em>  unsigned    _size;
<em>83: </em>
<em>84: </em><font color="red"><strong>}</strong></font>;
<em>85: </em> 
<em>86: </em>
<em>87: </em><font color="#1919af"><strong>#endif</strong></font>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
<!-- cc/FlexLexer.h -->
<a name="cc/FlexLexer.h"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">5.3.3 cc/FlexLexer.h</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em>  1: </em><font color="#ffa600"><em>//</em></font>
<em>  2: </em><font color="#ffa600"><em>// Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.</em></font>
<em>  3: </em><font color="#ffa600"><em>//</em></font>
<em>  4: </em><font color="#ffa600"><em>// You may distribute under the terms of the Artistic License, as specified in</em></font>
<em>  5: </em><font color="#ffa600"><em>// the COPYING file.</em></font>
<em>  6: </em><font color="#ffa600"><em>//</em></font>
<em>  7: </em><font color="#ffa600"><em>// -*-C++-*-</em></font>
<em>  8: </em><font color="#ffa600"><em>// FlexLexer.h -- define interfaces for lexical analyzer classes generated</em></font>
<em>  9: </em><font color="#ffa600"><em>// by flex</em></font>
<em> 10: </em>
<em> 11: </em><font color="#ffa600"><em>// Copyright (c) 1993 The Regents of the University of California.</em></font>
<em> 12: </em><font color="#ffa600"><em>// All rights reserved.</em></font>
<em> 13: </em><font color="#ffa600"><em>//</em></font>
<em> 14: </em><font color="#ffa600"><em>// This code is derived from software contributed to Berkeley by</em></font>
<em> 15: </em><font color="#ffa600"><em>// Kent Williams and Tom Epperly.</em></font>
<em> 16: </em><font color="#ffa600"><em>//</em></font>
<em> 17: </em><font color="#ffa600"><em>//  Redistribution and use in source and binary forms, with or without</em></font>
<em> 18: </em><font color="#ffa600"><em>//  modification, are permitted provided that the following conditions</em></font>
<em> 19: </em><font color="#ffa600"><em>//  are met:</em></font>
<em> 20: </em>
<em> 21: </em><font color="#ffa600"><em>//  1. Redistributions of source code must retain the above copyright</em></font>
<em> 22: </em><font color="#ffa600"><em>//  notice, this list of conditions and the following disclaimer.</em></font>
<em> 23: </em><font color="#ffa600"><em>//  2. Redistributions in binary form must reproduce the above copyright</em></font>
<em> 24: </em><font color="#ffa600"><em>//  notice, this list of conditions and the following disclaimer in the</em></font>
<em> 25: </em><font color="#ffa600"><em>//  documentation and/or other materials provided with the distribution.</em></font>
<em> 26: </em>
<em> 27: </em><font color="#ffa600"><em>//  Neither the name of the University nor the names of its contributors</em></font>
<em> 28: </em><font color="#ffa600"><em>//  may be used to endorse or promote products derived from this software</em></font>
<em> 29: </em><font color="#ffa600"><em>//  without specific prior written permission.</em></font>
<em> 30: </em>
<em> 31: </em><font color="#ffa600"><em>//  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR</em></font>
<em> 32: </em><font color="#ffa600"><em>//  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</em></font>
<em> 33: </em><font color="#ffa600"><em>//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR</em></font>
<em> 34: </em><font color="#ffa600"><em>//  PURPOSE.</em></font>
<em> 35: </em>
<em> 36: </em><font color="#ffa600"><em>// This file defines FlexLexer, an abstract class which specifies the</em></font>
<em> 37: </em><font color="#ffa600"><em>// external interface provided to flex C++ lexer objects, and yyFlexLexer,</em></font>
<em> 38: </em><font color="#ffa600"><em>// which defines a particular lexer class.</em></font>
<em> 39: </em><font color="#ffa600"><em>//</em></font>
<em> 40: </em><font color="#ffa600"><em>// If you want to create multiple lexer classes, you use the -P flag</em></font>
<em> 41: </em><font color="#ffa600"><em>// to rename each yyFlexLexer to some other xxFlexLexer.  You then</em></font>
<em> 42: </em><font color="#ffa600"><em>// include &lt;FlexLexer.h&gt; in your other sources once per lexer class:</em></font>
<em> 43: </em><font color="#ffa600"><em>//</em></font>
<em> 44: </em><font color="#ffa600"><em>//	#undef yyFlexLexer</em></font>
<em> 45: </em><font color="#ffa600"><em>//	#define yyFlexLexer xxFlexLexer</em></font>
<em> 46: </em><font color="#ffa600"><em>//	#include &lt;FlexLexer.h&gt;</em></font>
<em> 47: </em><font color="#ffa600"><em>//</em></font>
<em> 48: </em><font color="#ffa600"><em>//	#undef yyFlexLexer</em></font>
<em> 49: </em><font color="#ffa600"><em>//	#define yyFlexLexer zzFlexLexer</em></font>
<em> 50: </em><font color="#ffa600"><em>//	#include &lt;FlexLexer.h&gt;</em></font>
<em> 51: </em><font color="#ffa600"><em>//	...</em></font>
<em> 52: </em>
<em> 53: </em>#ifndef __FLEX_LEXER_H
<em> 54: </em><font color="#ffa600"><em>// Never included before - need to define base class.</em></font>
<em> 55: </em><font color="#1919af"><strong>#define</strong></font> __FLEX_LEXER_H
<em> 56: </em>
<em> 57: </em><font color="#1919af"><strong>#include</strong></font> &lt;iostream&gt;
<em> 58: </em>#  ifndef FLEX_STD
<em> 59: </em>#    define FLEX_STD std::
<em> 60: </em>#  endif
<em> 61: </em>
<em> 62: </em><strong>extern</strong> <font color="red">&quot;C++&quot;</font> <font color="red"><strong>{</strong></font>
<em> 63: </em>
<em> 64: </em><strong>struct</strong> yy_buffer_state;
<em> 65: </em><strong>typedef</strong> int yy_state_type;
<em> 66: </em>
<em> 67: </em><strong>class</strong> FlexLexer <font color="red"><strong>{</strong></font>
<em> 68: </em>public:
<em> 69: </em>    virtual ~FlexLexer()    <font color="red"><strong>{</strong></font> <font color="red"><strong>}</strong></font>
<em> 70: </em>
<em> 71: </em>    const char* YYText()    <font color="red"><strong>{</strong></font> <strong>return</strong> yytext; <font color="red"><strong>}</strong></font>
<em> 72: </em>    int YYLeng()        <font color="red"><strong>{</strong></font> <strong>return</strong> yyleng; <font color="red"><strong>}</strong></font>
<em> 73: </em>
<em> 74: </em>    virtual void
<em> 75: </em>        yy_switch_to_buffer( <strong>struct</strong> yy_buffer_state* new_buffer ) = 0;
<em> 76: </em>    virtual <strong>struct</strong> yy_buffer_state*
<em> 77: </em>        yy_create_buffer( FLEX_STD istream* s, int size ) = 0;
<em> 78: </em>    virtual void yy_delete_buffer( <strong>struct</strong> yy_buffer_state* b ) = 0;
<em> 79: </em>    virtual void yyrestart( FLEX_STD istream* s ) = 0;
<em> 80: </em>
<em> 81: </em>    virtual int yylex() = 0;
<em> 82: </em>
<em> 83: </em>    <font color="#ffa600"><em>// Call yylex with new input/output sources.</em></font>
<em> 84: </em>    int yylex( FLEX_STD istream* new_in, FLEX_STD ostream* new_out = 0 )
<em> 85: </em>        <font color="red"><strong>{</strong></font>
<em> 86: </em>        switch_streams( new_in, new_out );
<em> 87: </em>        <strong>return</strong> yylex();
<em> 88: </em>        <font color="red"><strong>}</strong></font>
<em> 89: </em>
<em> 90: </em>    <font color="#ffa600"><em>// Switch to new input/output streams.  A nil stream pointer</em></font>
<em> 91: </em>    <font color="#ffa600"><em>// indicates &quot;keep the current one&quot;.</em></font>
<em> 92: </em>    virtual void switch_streams( FLEX_STD istream* new_in = 0,
<em> 93: </em>                    FLEX_STD ostream* new_out = 0 ) = 0;
<em> 94: </em>
<em> 95: </em>    int lineno() const      <font color="red"><strong>{</strong></font> <strong>return</strong> yylineno; <font color="red"><strong>}</strong></font>
<em> 96: </em>
<em> 97: </em>    int debug() const       <font color="red"><strong>{</strong></font> <strong>return</strong> yy_flex_debug; <font color="red"><strong>}</strong></font>
<em> 98: </em>    void set_debug( int flag )  <font color="red"><strong>{</strong></font> yy_flex_debug = flag; <font color="red"><strong>}</strong></font>
<em> 99: </em>
<em>100: </em>protected:
<em>101: </em>    char* yytext;
<em>102: </em>    int yyleng;
<em>103: </em>    int yylineno;       <font color="#ffa600"><em>// only maintained if you use %option yylineno</em></font>
<em>104: </em>    int yy_flex_debug;  <font color="#ffa600"><em>// only has effect with -d or &quot;%option debug&quot;</em></font>
<em>105: </em><font color="red"><strong>}</strong></font>;
<em>106: </em>
<em>107: </em><font color="red"><strong>}</strong></font>
<em>108: </em><font color="#1919af"><strong>#endif</strong></font>
<em>109: </em>
<em>110: </em><font color="#1919af"><strong>#if</strong></font> defined(yyFlexLexer) || ! defined(yyFlexLexerOnce)
<em>111: </em><font color="#ffa600"><em>// Either this is the first time through (yyFlexLexerOnce not defined),</em></font>
<em>112: </em><font color="#ffa600"><em>// or this is a repeated include to define a different flavor of</em></font>
<em>113: </em><font color="#ffa600"><em>// yyFlexLexer, as discussed in the flex man page.</em></font>
<em>114: </em><font color="#1919af"><strong>#define</strong></font> yyFlexLexerOnce
<em>115: </em>
<em>116: </em><strong>extern</strong> <font color="red">&quot;C++&quot;</font> <font color="red"><strong>{</strong></font>
<em>117: </em>
<em>118: </em><strong>class</strong> yyFlexLexer : public FlexLexer <font color="red"><strong>{</strong></font>
<em>119: </em>public:
<em>120: </em>    <font color="#ffa600"><em>// arg_yyin and arg_yyout default to the cin and cout, but we</em></font>
<em>121: </em>    <font color="#ffa600"><em>// only make that assignment when initializing in yylex().</em></font>
<em>122: </em>    yyFlexLexer( FLEX_STD istream* arg_yyin = 0, FLEX_STD ostream* arg_yyout = 0 );
<em>123: </em>
<em>124: </em>    virtual ~yyFlexLexer();
<em>125: </em>
<em>126: </em>    void yy_switch_to_buffer( <strong>struct</strong> yy_buffer_state* new_buffer );
<em>127: </em>    <strong>struct</strong> yy_buffer_state* yy_create_buffer( FLEX_STD istream* s, int size );
<em>128: </em>    void yy_delete_buffer( <strong>struct</strong> yy_buffer_state* b );
<em>129: </em>    void yyrestart( FLEX_STD istream* s );
<em>130: </em>
<em>131: </em>    virtual int yylex();
<em>132: </em>    virtual void switch_streams( FLEX_STD istream* new_in, FLEX_STD ostream* new_out );
<em>133: </em>
<em>134: </em>protected:
<em>135: </em>    virtual int LexerInput( char* buf, int max_size );
<em>136: </em>    virtual void LexerOutput( const char* buf, int size );
<em>137: </em>    virtual void LexerError( const char* msg );
<em>138: </em>
<em>139: </em>    void yyunput( int c, char* buf_ptr );
<em>140: </em>    int yyinput();
<em>141: </em>
<em>142: </em>    void yy_load_buffer_state();
<em>143: </em>    void yy_init_buffer( <strong>struct</strong> yy_buffer_state* b, FLEX_STD istream* s );
<em>144: </em>    void yy_flush_buffer( <strong>struct</strong> yy_buffer_state* b );
<em>145: </em>
<em>146: </em>    int yy_start_stack_ptr;
<em>147: </em>    int yy_start_stack_depth;
<em>148: </em>    int* yy_start_stack;
<em>149: </em>
<em>150: </em>    void yy_push_state( int new_state );
<em>151: </em>    void yy_pop_state();
<em>152: </em>    int yy_top_state();
<em>153: </em>
<em>154: </em>    yy_state_type yy_get_previous_state();
<em>155: </em>    yy_state_type yy_try_NUL_trans( yy_state_type current_state );
<em>156: </em>    int yy_get_next_buffer();
<em>157: </em>
<em>158: </em>    FLEX_STD istream* yyin; <font color="#ffa600"><em>// input source for default LexerInput</em></font>
<em>159: </em>    FLEX_STD ostream* yyout;    <font color="#ffa600"><em>// output sink for default LexerOutput</em></font>
<em>160: </em>
<em>161: </em>    <strong>struct</strong> yy_buffer_state* yy_current_buffer;
<em>162: </em>
<em>163: </em>    <font color="#ffa600"><em>// yy_hold_char holds the character lost when yytext is formed.</em></font>
<em>164: </em>    char yy_hold_char;
<em>165: </em>
<em>166: </em>    <font color="#ffa600"><em>// Number of characters read into yy_ch_buf.</em></font>
<em>167: </em>    int yy_n_chars;
<em>168: </em>
<em>169: </em>    <font color="#ffa600"><em>// Points to current character in buffer.</em></font>
<em>170: </em>    char* yy_c_buf_p;
<em>171: </em>
<em>172: </em>    int yy_init;        <font color="#ffa600"><em>// whether we need to initialize</em></font>
<em>173: </em>    int yy_start;       <font color="#ffa600"><em>// start state number</em></font>
<em>174: </em>
<em>175: </em>    <font color="#ffa600"><em>// Flag which is used to allow yywrap()'s to do buffer switches</em></font>
<em>176: </em>    <font color="#ffa600"><em>// instead of setting up a fresh yyin.  A bit of a hack ...</em></font>
<em>177: </em>    int yy_did_buffer_switch_on_eof;
<em>178: </em>
<em>179: </em>    <font color="#ffa600"><em>// The following are not always needed, but may be depending</em></font>
<em>180: </em>    <font color="#ffa600"><em>// on use of certain flex features (like REJECT or yymore()).</em></font>
<em>181: </em>
<em>182: </em>    yy_state_type yy_last_accepting_state;
<em>183: </em>    char* yy_last_accepting_cpos;
<em>184: </em>
<em>185: </em>    yy_state_type* yy_state_buf;
<em>186: </em>    yy_state_type* yy_state_ptr;
<em>187: </em>
<em>188: </em>    char* yy_full_match;
<em>189: </em>    int* yy_full_state;
<em>190: </em>    int yy_full_lp;
<em>191: </em>
<em>192: </em>    int yy_lp;
<em>193: </em>    int yy_looking_for_trail_begin;
<em>194: </em>
<em>195: </em>    int yy_more_flag;
<em>196: </em>    int yy_more_len;
<em>197: </em>    int yy_more_offset;
<em>198: </em>    int yy_prev_more_offset;
<em>199: </em><font color="red"><strong>}</strong></font>;
<em>200: </em>
<em>201: </em><font color="red"><strong>}</strong></font>
<em>202: </em>
<em>203: </em><font color="#1919af"><strong>#endif</strong></font>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
<!-- cc/CLexer.h -->
<a name="cc/CLexer.h"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">5.3.4 cc/CLexer.h</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em> 1: </em><font color="#ffa600"><em>//</em></font>
<em> 2: </em><font color="#ffa600"><em>// Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.</em></font>
<em> 3: </em><font color="#ffa600"><em>//</em></font>
<em> 4: </em><font color="#ffa600"><em>// You may distribute under the terms of the Artistic License, as specified in</em></font>
<em> 5: </em><font color="#ffa600"><em>// the COPYING file.</em></font>
<em> 6: </em><font color="#ffa600"><em>//</em></font>
<em> 7: </em><font color="#ffa600"><em>//</em></font>
<em> 8: </em><font color="#ffa600"><em>// Main tokenizer include file.  Include this file to use</em></font>
<em> 9: </em><font color="#ffa600"><em>// the class.</em></font>
<em>10: </em><font color="#ffa600"><em>//</em></font>
<em>11: </em>
<em>12: </em>#ifndef _CLEXER_H_
<em>13: </em><font color="#1919af"><strong>#define</strong></font> _CLEXER_H_
<em>14: </em>
<em>15: </em>#undef yyFlexLexer
<em>16: </em><font color="#1919af"><strong>#define</strong></font> yyFlexLexer cFlexLexer
<em>17: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;FlexLexer.h&quot;</font>
<em>18: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;CFlexLexer.h&quot;</font>
<em>19: </em>
<em>20: </em><font color="#1919af"><strong>#endif</strong></font>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
<!-- cc/CLexer.pa -->
<a name="cc/CLexer.pa"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">5.3.5 cc/CLexer.pa</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em>  1: </em><font color="#ffa600"><em>//</em></font>
<em>  2: </em><font color="#ffa600"><em>// Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.</em></font>
<em>  3: </em><font color="#ffa600"><em>//</em></font>
<em>  4: </em><font color="#ffa600"><em>// You may distribute under the terms of the Artistic License, as specified in</em></font>
<em>  5: </em><font color="#ffa600"><em>// the COPYING file.</em></font>
<em>  6: </em><font color="#ffa600"><em>//</em></font>
<em>  7: </em><font color="#ffa600"><em>//</em></font>
<em>  8: </em><font color="#ffa600"><em>// Support routines for the tokenizer.</em></font>
<em>  9: </em><font color="#ffa600"><em>//</em></font>
<em> 10: </em>
<em> 11: </em><font color="#1919af"><strong>#include</strong></font> &lt;sys/stat.h&gt;
<em> 12: </em><font color="#1919af"><strong>#include</strong></font> &lt;sys/mman.h&gt;
<em> 13: </em><font color="#1919af"><strong>#include</strong></font> &lt;fcntl.h&gt;
<em> 14: </em><font color="#1919af"><strong>#include</strong></font> &lt;sstream&gt;
<em> 15: </em><font color="#1919af"><strong>#include</strong></font> &lt;stdexcept&gt;
<em> 16: </em>
<em> 17: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;Channels.h&quot;</font>
<em> 18: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;CLexer.h&quot;</font>
<em> 19: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;Tokens.h&quot;</font>
<em> 20: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;cparse.h&quot;</font>
<em> 21: </em>
<em> 22: </em>using namespace plasma;
<em> 23: </em>using namespace std;
<em> 24: </em>
<em> 25: </em><font color="#1919af"><strong>#define</strong></font> Error(x) <font color="red"><strong>{</strong></font> ostringstream ss; ss &lt;&lt; x; <strong>throw</strong> runtime_error(ss.str()); <font color="red"><strong>}</strong></font>
<em> 26: </em>
<em> 27: </em>CLexer::CLexer(TokChan &amp;c) :
<em> 28: </em>  _linenumber(0),
<em> 29: </em>  _chan(c),
<em> 30: </em>  _fd(-1),
<em> 31: </em>  _base(0),
<em> 32: </em>  _prevpos(0),
<em> 33: </em>  _srcbase(0),
<em> 34: </em>  _bufbase(0),
<em> 35: </em>  _size(0)
<em> 36: </em><font color="red"><strong>{</strong></font>
<em> 37: </em><font color="red"><strong>}</strong></font>
<em> 38: </em>
<em> 39: </em>CLexer::CLexer(TokChan &amp;c,const char *filename) :
<em> 40: </em>  yyFlexLexer(),
<em> 41: </em>  _chan(c),
<em> 42: </em>  _fd(-1)
<em> 43: </em><font color="red"><strong>{</strong></font>
<em> 44: </em>  reset(filename);
<em> 45: </em><font color="red"><strong>}</strong></font>
<em> 46: </em>
<em> 47: </em>CLexer::~CLexer()
<em> 48: </em><font color="red"><strong>{</strong></font>
<em> 49: </em>  closefile();
<em> 50: </em><font color="red"><strong>}</strong></font>
<em> 51: </em>
<em> 52: </em><font color="#ffa600"><em>// We never unmap b/c then any string pointing </em></font>
<em> 53: </em><font color="#ffa600"><em>// at the file's data would become invalid.  We just</em></font>
<em> 54: </em><font color="#ffa600"><em>// close the file in order to reclaim file buffers.</em></font>
<em> 55: </em>void CLexer::closefile()
<em> 56: </em><font color="red"><strong>{</strong></font>
<em> 57: </em>  <strong>if</strong> (_fd &gt;= 0) <font color="red"><strong>{</strong></font>
<em> 58: </em>    <font color="#ffa600"><em>//munmap((void*)_base,_size);</em></font>
<em> 59: </em>    close(_fd);
<em> 60: </em>  <font color="red"><strong>}</strong></font>
<em> 61: </em><font color="red"><strong>}</strong></font>
<em> 62: </em>
<em> 63: </em>void CLexer::reset(const char *filename)
<em> 64: </em><font color="red"><strong>{</strong></font>
<em> 65: </em>  <strong>struct</strong> stat statbuf;
<em> 66: </em>
<em> 67: </em>  _filename = filename;
<em> 68: </em>  _linenumber = 1;
<em> 69: </em>
<em> 70: </em>  closefile();
<em> 71: </em>
<em> 72: </em>  <strong>if</strong> ( (_fd = open(_filename,O_RDONLY)) &lt; 0) <font color="red"><strong>{</strong></font>
<em> 73: </em>    Error(<font color="red">&quot;Can't open &quot;</font> &lt;&lt; filename &lt;&lt; <font color="red">&quot; for reading.&quot;</font>);
<em> 74: </em>  <font color="red"><strong>}</strong></font>
<em> 75: </em>  <strong>if</strong> (fstat(_fd,&amp;statbuf) &lt; 0) <font color="red"><strong>{</strong></font>
<em> 76: </em>    Error(<font color="red">&quot;Can't open &quot;</font> &lt;&lt; filename &lt;&lt; <font color="red">&quot; for reading.&quot;</font>);
<em> 77: </em>  <font color="red"><strong>}</strong></font>
<em> 78: </em>  _size = statbuf.st_size;
<em> 79: </em>  <strong>if</strong> ( (_base = (const char *)mmap(0,_size,PROT_READ,MAP_SHARED,_fd,0)) == (caddr_t)-1) <font color="red"><strong>{</strong></font>
<em> 80: </em>    Error(<font color="red">&quot;mmap error for input.&quot;</font>);
<em> 81: </em>  <font color="red"><strong>}</strong></font>
<em> 82: </em>
<em> 83: </em>  _prevpos = _base;
<em> 84: </em>  _srcbase = _base;
<em> 85: </em>
<em> 86: </em><font color="red"><strong>}</strong></font>
<em> 87: </em>
<em> 88: </em><font color="#ffa600"><em>// This defines a new input routine which copies from an mmap'd</em></font>
<em> 89: </em><font color="#ffa600"><em>// file to a buffer.  The copy is necessary b/c flex modifies its buffer.</em></font>
<em> 90: </em>int CLexer::LexerInput(char* buf, int max_size )
<em> 91: </em><font color="red"><strong>{</strong></font>
<em> 92: </em>  int result;
<em> 93: </em>  <strong>if</strong> (_prevpos &gt;= (_base+_size)) <font color="red"><strong>{</strong></font> 
<em> 94: </em>    result = 0;
<em> 95: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font> 
<em> 96: </em>    result = ( (_prevpos + max_size) &lt; (_base + _size)) ?  
<em> 97: </em>      max_size : 
<em> 98: </em>      (_base - _prevpos + _size); 
<em> 99: </em>    memcpy(buf,_prevpos,result); 
<em>100: </em>    _srcbase = _prevpos;
<em>101: </em>    _prevpos +=  result;
<em>102: </em>    _bufbase = buf; 
<em>103: </em>  <font color="red"><strong>}</strong></font>
<em>104: </em>  <strong>return</strong> result;
<em>105: </em><font color="red"><strong>}</strong></font>
<em>106: </em>
<em>107: </em><font color="#ffa600"><em>// This retrieves text from the mmap'd file.  Use this instead of</em></font>
<em>108: </em><font color="#ffa600"><em>// YYText() for anything that will persist, such as strings.</em></font>
<em>109: </em>const char *CLexer::yystr()
<em>110: </em><font color="red"><strong>{</strong></font>
<em>111: </em>  <strong>return</strong> _srcbase+(YYText()-_bufbase);
<em>112: </em><font color="red"><strong>}</strong></font>
<em>113: </em>
<em>114: </em>void CLexer::tksetup(Tokens &amp;tk,int t)
<em>115: </em><font color="red"><strong>{</strong></font>
<em>116: </em>  memset(&amp;tk,0,sizeof(Tokens));
<em>117: </em>  tk._tok = t;
<em>118: </em>  tk._ln = _linenumber;
<em>119: </em>  tk._fn = _filename;
<em>120: </em><font color="red"><strong>}</strong></font>
<em>121: </em>
<em>122: </em><font color="#ffa600"><em>// Sends just a token.</em></font>
<em>123: </em>void CLexer::send(int t)
<em>124: </em><font color="red"><strong>{</strong></font>
<em>125: </em>  Tokens tk;
<em>126: </em>  tksetup(tk,t);
<em>127: </em>  _chan.write(tk);
<em>128: </em><font color="red"><strong>}</strong></font>
<em>129: </em>
<em>130: </em><font color="#ffa600"><em>// Sends an identifier.</em></font>
<em>131: </em>void CLexer::send_ident()
<em>132: </em><font color="red"><strong>{</strong></font>
<em>133: </em>  Tokens tk;
<em>134: </em>  tksetup(tk,IDENTIFIER);
<em>135: </em>  tk._str.p = yystr();
<em>136: </em>  tk._str.l = YYLeng();
<em>137: </em>  _chan.write(tk);
<em>138: </em><font color="red"><strong>}</strong></font>
<em>139: </em>
<em>140: </em><font color="#ffa600"><em>// Sends an integer constant.</em></font>
<em>141: </em>void CLexer::send_int()
<em>142: </em><font color="red"><strong>{</strong></font>
<em>143: </em>  Tokens tk;
<em>144: </em>  tksetup(tk,INTCONST);
<em>145: </em>  tk._int = atoi(YYText());
<em>146: </em>  _chan.write(tk);
<em>147: </em><font color="red"><strong>}</strong></font>
<em>148: </em>
<em>149: </em><font color="#ffa600"><em>// Sends a floating-point constant.</em></font>
<em>150: </em>void CLexer::send_float()
<em>151: </em><font color="red"><strong>{</strong></font>
<em>152: </em>  Tokens tk;
<em>153: </em>  tksetup(tk,FPCONST);
<em>154: </em>  tk._fp = strtod(YYText(),0);
<em>155: </em>  _chan.write(tk);
<em>156: </em><font color="red"><strong>}</strong></font>
<em>157: </em>
<em>158: </em><font color="#ffa600"><em>// Sends a character constant.  We only allow single-character constants</em></font>
<em>159: </em><font color="#ffa600"><em>// and we return the value in the integer portion (_int) of the structure.</em></font>
<em>160: </em>void CLexer::send_char()
<em>161: </em><font color="red"><strong>{</strong></font>
<em>162: </em>  Tokens tk;
<em>163: </em>  tksetup(tk,CHARCONST);
<em>164: </em>  tk._int = convert_char(yystr()+1,YYLeng()-2);
<em>165: </em>  _chan.write(tk);
<em>166: </em><font color="red"><strong>}</strong></font>
<em>167: </em>
<em>168: </em><font color="#ffa600"><em>// Sends a string literal.  We don't bother with any translation b/c</em></font>
<em>169: </em><font color="#ffa600"><em>// we assume that the assembler will handle it.</em></font>
<em>170: </em>void CLexer::send_string()
<em>171: </em><font color="red"><strong>{</strong></font>
<em>172: </em>  Tokens tk;
<em>173: </em>  tksetup(tk,STRING_LITERAL);
<em>174: </em>  tk._str.p = yystr()+1;
<em>175: </em>  tk._str.l = YYLeng()-2;
<em>176: </em>  _chan.write(tk);
<em>177: </em><font color="red"><strong>}</strong></font>
<em>178: </em>
<em>179: </em><font color="#ffa600"><em>// Sends all-done signal to the channel.</em></font>
<em>180: </em>void CLexer::send_alldone()
<em>181: </em><font color="red"><strong>{</strong></font>
<em>182: </em>  Tokens tk;
<em>183: </em>  tksetup(tk,ALL_DONE);
<em>184: </em>  _chan.write(tk);
<em>185: </em><font color="red"><strong>}</strong></font>
<em>186: </em>
<em>187: </em>inline bool isodigit(char x) 
<em>188: </em><font color="red"><strong>{</strong></font> 
<em>189: </em>  <strong>return</strong> ((x) &gt;= '0' &amp;&amp; (x) &lt;= '7'); 
<em>190: </em><font color="red"><strong>}</strong></font>
<em>191: </em>
<em>192: </em>inline int hextoint(char x) 
<em>193: </em><font color="red"><strong>{</strong></font>
<em>194: </em>  <strong>return</strong> (isdigit((x)) ? (x) - '0' : ((x) - 'A') + 10);
<em>195: </em><font color="red"><strong>}</strong></font>
<em>196: </em>
<em>197: </em>int CLexer::convert_char(const char *str,int len)
<em>198: </em><font color="red"><strong>{</strong></font>
<em>199: </em>  <strong>if</strong> (*str == '\\') <font color="red"><strong>{</strong></font>
<em>200: </em>    ++str;
<em>201: </em>    <strong>if</strong> (*str == 'x') <font color="red"><strong>{</strong></font>
<em>202: </em>      <font color="#ffa600"><em>// Hex digits- code terminates at first non-hex digit.</em></font>
<em>203: </em>      ++str;
<em>204: </em>      int tmp = 0,foo;
<em>205: </em>      bool dump = false;
<em>206: </em>      <strong>while</strong> (isxdigit(*str)) <font color="red"><strong>{</strong></font>
<em>207: </em>        tmp &lt;&lt;= 4;
<em>208: </em>        foo = toupper(*str++);
<em>209: </em>        tmp += hextoint(foo);
<em>210: </em>        <strong>if</strong> (dump) <font color="red"><strong>{</strong></font>
<em>211: </em>          <strong>return</strong> tmp;
<em>212: </em>        <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em>213: </em>          dump = true;
<em>214: </em>        <font color="red"><strong>}</strong></font>
<em>215: </em>      <font color="red"><strong>}</strong></font>
<em>216: </em>      <strong>if</strong> (dump) <font color="red"><strong>{</strong></font>
<em>217: </em>        <strong>return</strong> tmp;
<em>218: </em>      <font color="red"><strong>}</strong></font>
<em>219: </em>      <font color="#ffa600"><em>// I don't think we should ever get here.</em></font>
<em>220: </em>      <strong>return</strong> 0;
<em>221: </em>    <font color="red"><strong>}</strong></font> <strong>else</strong> <strong>if</strong> (isodigit(*str)) <font color="red"><strong>{</strong></font>
<em>222: </em>      <font color="#ffa600"><em>// Octal digits- code terminates at first non-octal digit.</em></font>
<em>223: </em>      int tmp = 0;
<em>224: </em>      <strong>while</strong> (isodigit(*str)) <font color="red"><strong>{</strong></font>
<em>225: </em>        tmp &lt;&lt;= 3;
<em>226: </em>        tmp += (*str++ - '0');
<em>227: </em>      <font color="red"><strong>}</strong></font>
<em>228: </em>      <strong>return</strong> tmp;
<em>229: </em>    <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em>230: </em>      char tmp;
<em>231: </em>      <strong>switch</strong> (*str) <font color="red"><strong>{</strong></font>
<em>232: </em>      <strong>case</strong> 'b':
<em>233: </em>        tmp = '\b';
<em>234: </em>        <strong>break</strong>;
<em>235: </em>      <strong>case</strong> 't':
<em>236: </em>        tmp = '\t';
<em>237: </em>        <strong>break</strong>;
<em>238: </em>      <strong>case</strong> 'n':
<em>239: </em>        tmp = '\n';
<em>240: </em>        <strong>break</strong>;
<em>241: </em>      <strong>case</strong> 'v':
<em>242: </em>        tmp = '\v';
<em>243: </em>        <strong>break</strong>;
<em>244: </em>      <strong>case</strong> 'f':
<em>245: </em>        tmp = '\f';
<em>246: </em>        <strong>break</strong>;
<em>247: </em>      <strong>case</strong> 'r':
<em>248: </em>        tmp = '\r';
<em>249: </em>        <strong>break</strong>;
<em>250: </em>      default:
<em>251: </em>        tmp = *str;
<em>252: </em>      <font color="red"><strong>}</strong></font>
<em>253: </em>      <strong>return</strong> tmp;
<em>254: </em>    <font color="red"><strong>}</strong></font>
<em>255: </em>  <font color="red"><strong>}</strong></font>
<em>256: </em>
<em>257: </em>  <strong>return</strong> *str;
<em>258: </em><font color="red"><strong>}</strong></font>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
<!-- cc/clex.ll -->
<a name="cc/clex.ll"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">5.3.6 cc/clex.ll</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em>  1: </em>%<font color="red"><strong>{</strong></font>
<em>  2: </em>
<em>  3: </em><font color="#ffa600"><em>//</em></font>
<em>  4: </em><font color="#ffa600"><em>// Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.</em></font>
<em>  5: </em><font color="#ffa600"><em>//</em></font>
<em>  6: </em><font color="#ffa600"><em>// You may distribute under the terms of the Artistic License, as specified in</em></font>
<em>  7: </em><font color="#ffa600"><em>// the COPYING file.</em></font>
<em>  8: </em><font color="#ffa600"><em>//</em></font>
<em>  9: </em><font color="#ffa600"><em>//</em></font>
<em> 10: </em><font color="#ffa600"><em>// Tokenizer for our C compiler.  The input is handled as</em></font>
<em> 11: </em><font color="#ffa600"><em>// a mmap'd file, so we don't copy identifiers or strings- we</em></font>
<em> 12: </em><font color="#ffa600"><em>// use the String class, which stores a pointer and length.</em></font>
<em> 13: </em><font color="#ffa600"><em>//</em></font>
<em> 14: </em><font color="#ffa600"><em>// Unfortunately, flex modifies its buffer, so we have to copy</em></font>
<em> 15: </em><font color="#ffa600"><em>// data from the file to a buffer.  This could be an area for</em></font>
<em> 16: </em><font color="#ffa600"><em>// future optimization.  Still, it should be pretty fast- only a</em></font>
<em> 17: </em><font color="#ffa600"><em>// single copy, vs. copying from the file via fread, plus copying</em></font>
<em> 18: </em><font color="#ffa600"><em>// to a string.</em></font>
<em> 19: </em><font color="#ffa600"><em>//</em></font>
<em> 20: </em>
<em> 21: </em><font color="#1919af"><strong>#include</strong></font> &lt;string.h&gt;
<em> 22: </em>
<em> 23: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;String.h&quot;</font>
<em> 24: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;CFlexLexer.h&quot;</font>
<em> 25: </em>
<em> 26: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;Tokens.h&quot;</font>
<em> 27: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;cparse.h&quot;</font>
<em> 28: </em>
<em> 29: </em>  using namespace std;
<em> 30: </em>
<em> 31: </em>%<font color="red"><strong>}</strong></font>
<em> 32: </em>
<em> 33: </em><font color="#ffa600"><strong>/* This generates an interactive c++ tokenizer which</strong></font>
<em> 34: </em><font color="#ffa600"><strong>    doesn't call yywrap- when it reaches EOF, it assumes it's done.</strong></font>
<em> 35: </em><font color="#ffa600"><strong>*/</strong></font>
<em> 36: </em>
<em> 37: </em>%option batch
<em> 38: </em>%option c++
<em> 39: </em>%option noyywrap
<em> 40: </em>%option prefix=<font color="red">&quot;c&quot;</font>
<em> 41: </em>%option yyclass=<font color="red">&quot;CLexer&quot;</font>
<em> 42: </em>
<em> 43: </em>D           [0-9]
<em> 44: </em>L           [a-zA-Z_]
<em> 45: </em>H           [a-fA-F0-9]
<em> 46: </em>E           [Ee][+-]?<font color="red"><strong>{</strong></font>D<font color="red"><strong>}</strong></font>+
<em> 47: </em>FS          (f|F|l|L)
<em> 48: </em>IS          (u|U|l|L)*
<em> 49: </em>
<em> 50: </em>%x comment
<em> 51: </em>
<em> 52: </em>%%
<em> 53: </em>
<em> 54: </em>[ \t]+                  <font color="#ffa600"><strong>/* do nothing */</strong></font>
<em> 55: </em>
<em> 56: </em>   <font color="#ffa600"><strong>/* C++ style comments. */</strong></font>
<em> 57: </em><font color="red">&quot;//&quot;</font>.*\n                 _linenumber++;
<em> 58: </em>
<em> 59: </em>  <font color="#ffa600"><strong>/* C style comments. */</strong></font>
<em> 60: </em><font color="red">&quot;/*&quot;</font>                     BEGIN(comment);
<em> 61: </em>&lt;comment&gt;[^*\n]*         
<em> 62: </em>&lt;comment&gt;[^*\n]*\n       _linenumber++;
<em> 63: </em>&lt;comment&gt;<font color="red">&quot;*&quot;</font>+[^*/\n]*    
<em> 64: </em>&lt;comment&gt;<font color="red">&quot;*&quot;</font>+[^*/\n]*\n  _linenumber++;
<em> 65: </em>&lt;comment&gt;<font color="red">&quot;*/&quot;</font>            BEGIN(INITIAL);
<em> 66: </em>
<em> 67: </em><font color="red">&quot;break&quot;</font>             <font color="red"><strong>{</strong></font> send(BREAK); <font color="red"><strong>}</strong></font>
<em> 68: </em><font color="red">&quot;char&quot;</font>          <font color="red"><strong>{</strong></font> send(CHAR); <font color="red"><strong>}</strong></font>
<em> 69: </em><font color="red">&quot;continue&quot;</font>      <font color="red"><strong>{</strong></font> send(CONTINUE); <font color="red"><strong>}</strong></font>
<em> 70: </em><font color="red">&quot;else&quot;</font>          <font color="red"><strong>{</strong></font> send(ELSE); <font color="red"><strong>}</strong></font>
<em> 71: </em><font color="red">&quot;extern&quot;</font>        <font color="red"><strong>{</strong></font> send(EXTERN); <font color="red"><strong>}</strong></font>
<em> 72: </em><font color="red">&quot;for&quot;</font>           <font color="red"><strong>{</strong></font> send(FOR); <font color="red"><strong>}</strong></font>
<em> 73: </em><font color="red">&quot;if&quot;</font>            <font color="red"><strong>{</strong></font> send(IF); <font color="red"><strong>}</strong></font>
<em> 74: </em><font color="red">&quot;int&quot;</font>           <font color="red"><strong>{</strong></font> send(INT); <font color="red"><strong>}</strong></font>
<em> 75: </em><font color="red">&quot;return&quot;</font>        <font color="red"><strong>{</strong></font> send(RETURN); <font color="red"><strong>}</strong></font>
<em> 76: </em><font color="red">&quot;static&quot;</font>        <font color="red"><strong>{</strong></font> send(STATIC); <font color="red"><strong>}</strong></font>
<em> 77: </em><font color="red">&quot;while&quot;</font>             <font color="red"><strong>{</strong></font> send(WHILE); <font color="red"><strong>}</strong></font>
<em> 78: </em>
<em> 79: </em><font color="red"><strong>{</strong></font>L<font color="red"><strong>}</strong></font>(<font color="red"><strong>{</strong></font>L<font color="red"><strong>}</strong></font>|<font color="red"><strong>{</strong></font>D<font color="red"><strong>}</strong></font>)*   <font color="red"><strong>{</strong></font> send_ident(); <font color="red"><strong>}</strong></font>
<em> 80: </em>
<em> 81: </em>0[xX]<font color="red"><strong>{</strong></font>H<font color="red"><strong>}</strong></font>+<font color="red"><strong>{</strong></font>IS<font color="red"><strong>}</strong></font>?	<font color="red"><strong>{</strong></font> send_int(); <font color="red"><strong>}</strong></font>
<em> 82: </em>0<font color="red"><strong>{</strong></font>D<font color="red"><strong>}</strong></font>+<font color="red"><strong>{</strong></font>IS<font color="red"><strong>}</strong></font>?      <font color="red"><strong>{</strong></font> send_int(); <font color="red"><strong>}</strong></font>
<em> 83: </em><font color="red"><strong>{</strong></font>D<font color="red"><strong>}</strong></font>+<font color="red"><strong>{</strong></font>IS<font color="red"><strong>}</strong></font>?       <font color="red"><strong>{</strong></font> send_int(); <font color="red"><strong>}</strong></font>
<em> 84: </em> 
<em> 85: </em><font color="red"><strong>{</strong></font>D<font color="red"><strong>}</strong></font>+<font color="red"><strong>{</strong></font>E<font color="red"><strong>}</strong></font><font color="red"><strong>{</strong></font>FS<font color="red"><strong>}</strong></font>?            <font color="red"><strong>{</strong></font> send_float(); <font color="red"><strong>}</strong></font>
<em> 86: </em><font color="red"><strong>{</strong></font>D<font color="red"><strong>}</strong></font>*<font color="red">&quot;.&quot;</font><font color="red"><strong>{</strong></font>D<font color="red"><strong>}</strong></font>+(<font color="red"><strong>{</strong></font>E<font color="red"><strong>}</strong></font>)?<font color="red"><strong>{</strong></font>FS<font color="red"><strong>}</strong></font>?	<font color="red"><strong>{</strong></font> send_float(); <font color="red"><strong>}</strong></font>
<em> 87: </em><font color="red"><strong>{</strong></font>D<font color="red"><strong>}</strong></font>+<font color="red">&quot;.&quot;</font><font color="red"><strong>{</strong></font>D<font color="red"><strong>}</strong></font>*(<font color="red"><strong>{</strong></font>E<font color="red"><strong>}</strong></font>)?<font color="red"><strong>{</strong></font>FS<font color="red"><strong>}</strong></font>?	<font color="red"><strong>{</strong></font> send_float(); <font color="red"><strong>}</strong></font>
<em> 88: </em>
<em> 89: </em>L?\<font color="red">&quot;(\\.|[^\\&quot;</font>])*\<font color="red">&quot;     { send_string(); }</font>
<em> 90: </em>
<em> 91: </em><font color="red">\'(\\.|[^\\'])*\' { send_char(); }</font>
<em> 92: </em>
<em> 93: </em><font color="red">&quot;</font>...<font color="red">&quot;           { send(ELLIPSIS); }</font>
<em> 94: </em><font color="red">&quot;</font>+=<font color="red">&quot;            { send(ADD_ASSIGN); }</font>
<em> 95: </em><font color="red">&quot;</font>-=<font color="red">&quot;            { send(SUB_ASSIGN); }</font>
<em> 96: </em><font color="red">&quot;</font>&lt;=<font color="red">&quot;            { send(LESS_EQ); }</font>
<em> 97: </em><font color="red">&quot;</font>&gt;=<font color="red">&quot;            { send(GREATER_EQ); }</font>
<em> 98: </em><font color="red">&quot;</font>==<font color="red">&quot;            { send(EQ); }</font>
<em> 99: </em><font color="red">&quot;</font>!=<font color="red">&quot;            { send(NOT_EQ); }</font>
<em>100: </em>
<em>101: </em><font color="red">&quot;</font>=<font color="red">&quot;         { send(ASSIGN); }</font>
<em>102: </em><font color="red">&quot;</font>;&quot;             <font color="red"><strong>{</strong></font> send(SEMICOLON); <font color="red"><strong>}</strong></font>
<em>103: </em>(<font color="red">&quot;{&quot;</font>|<font color="red">&quot;&lt;%&quot;</font>)	<font color="red"><strong>{</strong></font> send(LBRACE); <font color="red"><strong>}</strong></font>
<em>104: </em>(<font color="red">&quot;}&quot;</font>|<font color="red">&quot;%&gt;&quot;</font>)	<font color="red"><strong>{</strong></font> send(RBRACE); <font color="red"><strong>}</strong></font>
<em>105: </em><font color="red">&quot;,&quot;</font>             <font color="red"><strong>{</strong></font> send(COMMA); <font color="red"><strong>}</strong></font>
<em>106: </em><font color="red">&quot;(&quot;</font>             <font color="red"><strong>{</strong></font> send(LPAREN); <font color="red"><strong>}</strong></font>
<em>107: </em><font color="red">&quot;)&quot;</font>             <font color="red"><strong>{</strong></font> send(RPAREN); <font color="red"><strong>}</strong></font>
<em>108: </em>(<font color="red">&quot;[&quot;</font>|<font color="red">&quot;&lt;:&quot;</font>)	<font color="red"><strong>{</strong></font> send(LBRACKET); <font color="red"><strong>}</strong></font>
<em>109: </em>(<font color="red">&quot;]&quot;</font>|<font color="red">&quot;:&gt;&quot;</font>)	<font color="red"><strong>{</strong></font> send(RBRACKET); <font color="red"><strong>}</strong></font>
<em>110: </em><font color="red">&quot;&amp;&quot;</font>             <font color="red"><strong>{</strong></font> send(AMPERSAND); <font color="red"><strong>}</strong></font>
<em>111: </em><font color="red">&quot;!&quot;</font>             <font color="red"><strong>{</strong></font> send(EXCLAMATION); <font color="red"><strong>}</strong></font>
<em>112: </em><font color="red">&quot;-&quot;</font>             <font color="red"><strong>{</strong></font> send(MINUS); <font color="red"><strong>}</strong></font>
<em>113: </em><font color="red">&quot;+&quot;</font>             <font color="red"><strong>{</strong></font> send(PLUS); <font color="red"><strong>}</strong></font>
<em>114: </em><font color="red">&quot;*&quot;</font>             <font color="red"><strong>{</strong></font> send(ASTERISK); <font color="red"><strong>}</strong></font>
<em>115: </em><font color="red">&quot;&lt;&quot;</font>             <font color="red"><strong>{</strong></font> send(LESS); <font color="red"><strong>}</strong></font>
<em>116: </em><font color="red">&quot;&gt;&quot;</font>             <font color="red"><strong>{</strong></font> send(GREATER); <font color="red"><strong>}</strong></font>
<em>117: </em><font color="red">&quot;/&quot;</font>         <font color="red"><strong>{</strong></font> send(DIV); <font color="red"><strong>}</strong></font>
<em>118: </em><font color="red">&quot;%&quot;</font>         <font color="red"><strong>{</strong></font> send(MODULO); <font color="red"><strong>}</strong></font>
<em>119: </em>
<em>120: </em>\n          <font color="red"><strong>{</strong></font> _linenumber++;  <font color="red"><strong>}</strong></font>
<em>121: </em>
<em>122: </em>.           <font color="red"><strong>{</strong></font> <font color="#ffa600"><strong>/* ignore bad characters */</strong></font> <font color="red"><strong>}</strong></font>
<em>123: </em>
<em>124: </em>&lt;&lt;EOF&gt;&gt;     <font color="red"><strong>{</strong></font> send(0); <strong>return</strong> 0; <font color="red"><strong>}</strong></font>;
<em>125: </em>
<em>126: </em>%%
<em>127: </em>
<em>128: </em><font color="#ffa600"><em>//&quot;</em></font>
<em>129: </em>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
</div>
<!-- Parser -->
<a name="Parser"></a>
<div class="skribesubsectiontitle"><table width="100%"><tr><td bgcolor="#ffffff"><h3><font color="#8381de">5.4 Parser</font>
</h3></td></tr></table>
</div><div class="subsection">
<!-- cc/CParser.h -->
<a name="cc/CParser.h"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">5.4.1 cc/CParser.h</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em> 1: </em><font color="#ffa600"><em>//</em></font>
<em> 2: </em><font color="#ffa600"><em>// Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.</em></font>
<em> 3: </em><font color="#ffa600"><em>//</em></font>
<em> 4: </em><font color="#ffa600"><em>// You may distribute under the terms of the Artistic License, as specified in</em></font>
<em> 5: </em><font color="#ffa600"><em>// the COPYING file.</em></font>
<em> 6: </em><font color="#ffa600"><em>//</em></font>
<em> 7: </em><font color="#ffa600"><em>//</em></font>
<em> 8: </em><font color="#ffa600"><em>// The main parser class.  This wraps the parser internals,</em></font>
<em> 9: </em><font color="#ffa600"><em>// which are generated by Lemon.</em></font>
<em>10: </em><font color="#ffa600"><em>//</em></font>
<em>11: </em>
<em>12: </em>#ifndef _CPARSER_H_
<em>13: </em><font color="#1919af"><strong>#define</strong></font> _CPARSER_H_
<em>14: </em>
<em>15: </em><font color="#1919af"><strong>#include</strong></font> &lt;iosfwd&gt;
<em>16: </em><font color="#1919af"><strong>#include</strong></font> &lt;vector&gt;
<em>17: </em>
<em>18: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;gc/gc_cpp.h&quot;</font>
<em>19: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;gc/gc_allocator.h&quot;</font>
<em>20: </em>
<em>21: </em><strong>struct</strong> Tokens;
<em>22: </em><strong>class</strong> Node;
<em>23: </em>
<em>24: </em><strong>typedef</strong> std::vector&lt;Node *,traceable_allocator&lt;Node *&gt; &gt; Nodes;
<em>25: </em>
<em>26: </em><font color="#ffa600"><em>// Wrapper class.  The copy-constructor is shallow</em></font>
<em>27: </em><font color="#ffa600"><em>// and there is no destructor b/c allocation is garbage collected.</em></font>
<em>28: </em><strong>class</strong> CParser <font color="red"><strong>{</strong></font>
<em>29: </em>public:
<em>30: </em>  CParser(bool debug = false);
<em>31: </em>  CParser(const CParser &amp;cp) : _parser(cp._parser) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>
<em>32: </em>
<em>33: </em>  void parse(int t,Tokens tk);
<em>34: </em>
<em>35: </em>  int linenumber() const <font color="red"><strong>{</strong></font> <strong>return</strong> _linenumber; <font color="red"><strong>}</strong></font>;
<em>36: </em>  const char *filename() const <font color="red"><strong>{</strong></font> <strong>return</strong> _filename; <font color="red"><strong>}</strong></font>;
<em>37: </em>  void setinfo(Node *) const;
<em>38: </em>
<em>39: </em>  <font color="#ffa600"><em>// Resets error status only.</em></font>
<em>40: </em>  void reset();
<em>41: </em>  <font color="#ffa600"><em>// Resets error status and clears all data structures.</em></font>
<em>42: </em>  void reset_all();
<em>43: </em>  void seterror() <font color="red"><strong>{</strong></font> _error = true; <font color="red"><strong>}</strong></font>;
<em>44: </em>  bool error() const <font color="red"><strong>{</strong></font> <strong>return</strong> _error; <font color="red"><strong>}</strong></font>;
<em>45: </em>
<em>46: </em>  <font color="#ffa600"><em>// Stores a translation unit AST.</em></font>
<em>47: </em>  void add_translation_unit(Node *);
<em>48: </em>
<em>49: </em>  <font color="#ffa600"><em>// Print all ASTs.</em></font>
<em>50: </em>  void print_ast_list(std::ostream &amp;,bool printsyms);
<em>51: </em>
<em>52: </em>  <font color="#ffa600"><em>// Returns last unit added.</em></font>
<em>53: </em>  Node *lastUnit() <font color="red"><strong>{</strong></font> <strong>return</strong> _asts.back(); <font color="red"><strong>}</strong></font>;
<em>54: </em>
<em>55: </em>private:
<em>56: </em>  void *_parser;  <font color="#ffa600"><em>// The parser (opaque type generated by Lemon).</em></font>
<em>57: </em>
<em>58: </em>  const char *_filename;
<em>59: </em>  int         _linenumber;
<em>60: </em>  bool        _error;
<em>61: </em>
<em>62: </em>  <font color="#ffa600"><em>// All of the translation units that have been parsed.</em></font>
<em>63: </em>  Nodes       _asts;
<em>64: </em><font color="red"><strong>}</strong></font>;
<em>65: </em>
<em>66: </em><font color="#1919af"><strong>#endif</strong></font>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
<!-- cc/CParser.pa -->
<a name="cc/CParser.pa"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">5.4.2 cc/CParser.pa</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em> 1: </em><font color="#ffa600"><em>//</em></font>
<em> 2: </em><font color="#ffa600"><em>// Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.</em></font>
<em> 3: </em><font color="#ffa600"><em>//</em></font>
<em> 4: </em><font color="#ffa600"><em>// You may distribute under the terms of the Artistic License, as specified in</em></font>
<em> 5: </em><font color="#ffa600"><em>// the COPYING file.</em></font>
<em> 6: </em><font color="#ffa600"><em>//</em></font>
<em> 7: </em><font color="#ffa600"><em>//</em></font>
<em> 8: </em><font color="#ffa600"><em>// The main parser class.  This wraps the parser internals,</em></font>
<em> 9: </em><font color="#ffa600"><em>// which are generated by Lemon.</em></font>
<em>10: </em><font color="#ffa600"><em>//</em></font>
<em>11: </em>
<em>12: </em><font color="#1919af"><strong>#include</strong></font> &lt;iostream&gt;
<em>13: </em>
<em>14: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;Tokens.h&quot;</font>
<em>15: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;CParser.h&quot;</font>
<em>16: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;Node.h&quot;</font>
<em>17: </em>
<em>18: </em>using namespace std;
<em>19: </em>
<em>20: </em>void *ParseAlloc(void *(*mallocProc)(size_t));
<em>21: </em>void ParseFree(void *,void (*freeProc)(void*));
<em>22: </em>void Parse(void *,int,Tokens,CParser *);
<em>23: </em>void ParseTrace(FILE *, char *);
<em>24: </em>
<em>25: </em>CParser::CParser(bool debug) : 
<em>26: </em>  _parser(ParseAlloc(GC_malloc)),
<em>27: </em>  _error(false)
<em>28: </em><font color="red"><strong>{</strong></font>
<em>29: </em>  <strong>if</strong> (debug) <font color="red"><strong>{</strong></font>
<em>30: </em>    ParseTrace(stdout,<font color="red">&quot;lemon:  &quot;</font>);
<em>31: </em>  <font color="red"><strong>}</strong></font>
<em>32: </em><font color="red"><strong>}</strong></font>
<em>33: </em>
<em>34: </em>void CParser::parse(int t,Tokens tk) 
<em>35: </em><font color="red"><strong>{</strong></font> 
<em>36: </em>  <font color="#ffa600"><em>//cout &lt;&lt; &quot;Token:  &quot; &lt;&lt; t &lt;&lt; endl;</em></font>
<em>37: </em>  _linenumber = tk._ln;
<em>38: </em>  _filename = tk._fn;
<em>39: </em>  Parse(_parser,t,tk,this); 
<em>40: </em><font color="red"><strong>}</strong></font>
<em>41: </em>
<em>42: </em>void CParser::setinfo(Node *n) const
<em>43: </em><font color="red"><strong>{</strong></font>
<em>44: </em>  n-&gt;setFileData(_filename,_linenumber);
<em>45: </em><font color="red"><strong>}</strong></font>
<em>46: </em>
<em>47: </em>void CParser::reset()
<em>48: </em><font color="red"><strong>{</strong></font>
<em>49: </em>  _error = false;
<em>50: </em><font color="red"><strong>}</strong></font>
<em>51: </em>
<em>52: </em>void CParser::reset_all()
<em>53: </em><font color="red"><strong>{</strong></font>
<em>54: </em>  reset();
<em>55: </em>  _asts.clear();
<em>56: </em><font color="red"><strong>}</strong></font>
<em>57: </em>
<em>58: </em>void CParser::add_translation_unit(Node *n)
<em>59: </em><font color="red"><strong>{</strong></font>
<em>60: </em>  _asts.push_back(n);
<em>61: </em><font color="red"><strong>}</strong></font>
<em>62: </em>
<em>63: </em>void CParser::print_ast_list(ostream &amp;o,bool ps)
<em>64: </em><font color="red"><strong>{</strong></font>
<em>65: </em>  <strong>if</strong> (ps) <font color="red"><strong>{</strong></font>
<em>66: </em>    o &lt;&lt; printsyms;
<em>67: </em>  <font color="red"><strong>}</strong></font>
<em>68: </em>  <strong>for</strong> (Nodes::const_iterator i = _asts.begin(); i != _asts.end(); ++i) <font color="red"><strong>{</strong></font>
<em>69: </em>    o &lt;&lt; <font color="red">&quot;\nTranslation Unit\n&quot;</font>
<em>70: </em>      &lt;&lt; <font color="red">&quot;================\n&quot;</font>
<em>71: </em>      &lt;&lt; (*i)
<em>72: </em>      &lt;&lt; endl;
<em>73: </em>  <font color="red"><strong>}</strong></font>
<em>74: </em><font color="red"><strong>}</strong></font>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
<!-- cc/cparse.yy -->
<a name="cc/cparse.yy"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">5.4.3 cc/cparse.yy</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em>  1: </em><font color="#ffa600"><em>//</em></font>
<em>  2: </em><font color="#ffa600"><em>// Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.</em></font>
<em>  3: </em><font color="#ffa600"><em>//</em></font>
<em>  4: </em><font color="#ffa600"><em>// You may distribute under the terms of the Artistic License, as specified in</em></font>
<em>  5: </em><font color="#ffa600"><em>// the COPYING file.</em></font>
<em>  6: </em><font color="#ffa600"><em>//</em></font>
<em>  7: </em><font color="#ffa600"><em>//</em></font>
<em>  8: </em><font color="#ffa600"><em>// C subset grammar.  This uss the lemon parser generator</em></font>
<em>  9: </em><font color="#ffa600"><em>// http://www.hwaci.com/sw/lemon/lemon.html to create the parser.</em></font>
<em> 10: </em><font color="#ffa600"><em>//</em></font>
<em> 11: </em>
<em> 12: </em>%include <font color="red"><strong>{</strong></font>   
<em> 13: </em>
<em> 14: </em><font color="#1919af"><strong>#include</strong></font> &lt;iostream&gt;  
<em> 15: </em>
<em> 16: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;Tokens.h&quot;</font>
<em> 17: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;cparse.h&quot;</font>
<em> 18: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;CParser.h&quot;</font>
<em> 19: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;Node.h&quot;</font>
<em> 20: </em>
<em> 21: </em>  using namespace std;
<em> 22: </em>
<em> 23: </em>  Node *declaration(Type *typespec,Node *declarator) <font color="red"><strong>{</strong></font>
<em> 24: </em>    Declaration &amp;d = dynamic_cast&lt;Declaration&amp;&gt;(*declarator);
<em> 25: </em>    <strong>if</strong> (dynamic_cast&lt;FunctionType*&gt;(declarator-&gt;type())) <font color="red"><strong>{</strong></font>
<em> 26: </em>      d.set_extern();
<em> 27: </em>    <font color="red"><strong>}</strong></font>
<em> 28: </em>    d.set_base_type(typespec);
<em> 29: </em>    <strong>return</strong> declarator;
<em> 30: </em>  <font color="red"><strong>}</strong></font>
<em> 31: </em>
<em> 32: </em><font color="red"><strong>}</strong></font>
<em> 33: </em>
<em> 34: </em>%nonassoc LOWER_THAN_ELSE.
<em> 35: </em>%nonassoc ELSE.
<em> 36: </em>
<em> 37: </em>%start_symbol translation_unit
<em> 38: </em>
<em> 39: </em>%extra_argument <font color="red"><strong>{</strong></font> CParser *cp <font color="red"><strong>}</strong></font>
<em> 40: </em>
<em> 41: </em>%token_type <font color="red"><strong>{</strong></font>Tokens <font color="red"><strong>}</strong></font>
<em> 42: </em>%type expr <font color="red"><strong>{</strong></font>int<font color="red"><strong>}</strong></font>
<em> 43: </em>
<em> 44: </em>%syntax_error <font color="red"><strong>{</strong></font>  
<em> 45: </em>  cerr &lt;&lt; cp-&gt;filename() &lt;&lt; <font color="red">&quot;:&quot;</font> &lt;&lt; cp-&gt;linenumber() &lt;&lt; <font color="red">&quot;:  syntax error.&quot;</font> &lt;&lt; endl;  
<em> 46: </em>  cp-&gt;seterror();
<em> 47: </em><font color="red"><strong>}</strong></font>   
<em> 48: </em>
<em> 49: </em>%parse_failure <font color="red"><strong>{</strong></font>
<em> 50: </em>  cerr &lt;&lt; <font color="red">&quot;Parse failed!&quot;</font> &lt;&lt; endl;
<em> 51: </em><font color="red"><strong>}</strong></font>
<em> 52: </em>
<em> 53: </em>%default_type <font color="red"><strong>{</strong></font> Node * <font color="red"><strong>}</strong></font>
<em> 54: </em>
<em> 55: </em>translation_unit ::= extern_decl_list(B). <font color="red"><strong>{</strong></font>
<em> 56: </em>  cp-&gt;add_translation_unit(B);
<em> 57: </em><font color="red"><strong>}</strong></font>
<em> 58: </em>
<em> 59: </em>extern_decl_list(A) ::= extern_decl(B). <font color="red"><strong>{</strong></font>
<em> 60: </em>  A = new TranslationUnit(B);
<em> 61: </em>  cp-&gt;setinfo(A);
<em> 62: </em><font color="red"><strong>}</strong></font>
<em> 63: </em>extern_decl_list(A) ::= extern_decl_list(B) extern_decl(C). <font color="red"><strong>{</strong></font>
<em> 64: </em>  A = B;
<em> 65: </em>  B-&gt;add(C);
<em> 66: </em><font color="red"><strong>}</strong></font>
<em> 67: </em>
<em> 68: </em>extern_decl(A) ::= function_definition(B). <font color="red"><strong>{</strong></font>
<em> 69: </em>  A = B;
<em> 70: </em><font color="red"><strong>}</strong></font>
<em> 71: </em>extern_decl(A) ::= declaration(B). <font color="red"><strong>{</strong></font>
<em> 72: </em>  A = B;
<em> 73: </em><font color="red"><strong>}</strong></font>
<em> 74: </em>
<em> 75: </em>function_definition(A) ::= type_specifier(B) declarator(C) compound_statement(D). <font color="red"><strong>{</strong></font>
<em> 76: </em>  Declaration &amp;d = dynamic_cast&lt;Declaration&amp;&gt;(*C);  
<em> 77: </em>  d.set_base_type(B);
<em> 78: </em>  A = new FunctionDefn(C,D);
<em> 79: </em>  cp-&gt;setinfo(A);
<em> 80: </em><font color="red"><strong>}</strong></font>
<em> 81: </em>function_definition(A) ::= STATIC type_specifier(B) declarator(C) compound_statement(D). <font color="red"><strong>{</strong></font>
<em> 82: </em>  Declaration &amp;d = dynamic_cast&lt;Declaration&amp;&gt;(*C);  
<em> 83: </em>  d.set_static();
<em> 84: </em>  d.set_base_type(B);
<em> 85: </em>  A = new FunctionDefn(C,D);
<em> 86: </em>  cp-&gt;setinfo(A);
<em> 87: </em><font color="red"><strong>}</strong></font>
<em> 88: </em>
<em> 89: </em>declaration(A) ::= type_specifier(B) declarator(C) SEMICOLON. <font color="red"><strong>{</strong></font>
<em> 90: </em>  A = declaration(B,C);  
<em> 91: </em><font color="red"><strong>}</strong></font>
<em> 92: </em>declaration(A) ::= EXTERN type_specifier(B) declarator(C) SEMICOLON. <font color="red"><strong>{</strong></font>
<em> 93: </em>  A = C;
<em> 94: </em>  Declaration &amp;d = dynamic_cast&lt;Declaration&amp;&gt;(*A);
<em> 95: </em>  d.set_extern();
<em> 96: </em>  d.set_base_type(B);
<em> 97: </em><font color="red"><strong>}</strong></font>
<em> 98: </em>
<em> 99: </em>declaration_list_opt(A) ::= . <font color="red"><strong>{</strong></font>
<em>100: </em>  A = new NullNode();
<em>101: </em>  cp-&gt;setinfo(A);
<em>102: </em><font color="red"><strong>}</strong></font>
<em>103: </em>declaration_list_opt(A) ::= declaration_list(B). <font color="red"><strong>{</strong></font>
<em>104: </em>  A = B;
<em>105: </em><font color="red"><strong>}</strong></font>
<em>106: </em>
<em>107: </em>declaration_list(A) ::= declaration(B). <font color="red"><strong>{</strong></font>
<em>108: </em>  A = new DeclarationList(B);
<em>109: </em>  cp-&gt;setinfo(A);
<em>110: </em><font color="red"><strong>}</strong></font>
<em>111: </em>declaration_list(A) ::= declaration_list(B) declaration(C). <font color="red"><strong>{</strong></font>
<em>112: </em>  A = B;
<em>113: </em>  B-&gt;add(C);
<em>114: </em><font color="red"><strong>}</strong></font>
<em>115: </em>
<em>116: </em>%type type_specifier <font color="red"><strong>{</strong></font> Type * <font color="red"><strong>}</strong></font>
<em>117: </em>type_specifier(A) ::= INT. <font color="red"><strong>{</strong></font>
<em>118: </em>  A = new BaseType(BaseType::Int);
<em>119: </em><font color="red"><strong>}</strong></font>
<em>120: </em>type_specifier(A) ::= CHAR. <font color="red"><strong>{</strong></font>
<em>121: </em>  A = new BaseType(BaseType::Char);
<em>122: </em><font color="red"><strong>}</strong></font>
<em>123: </em>
<em>124: </em>declarator(A) ::= direct_declarator(B). <font color="red"><strong>{</strong></font>
<em>125: </em>  A = B;
<em>126: </em><font color="red"><strong>}</strong></font>
<em>127: </em>declarator(A) ::= ASTERISK declarator(B). <font color="red"><strong>{</strong></font>
<em>128: </em>  A = B;
<em>129: </em>  dynamic_cast&lt;Declaration&amp;&gt;(*A).set_base_type(new PointerType);
<em>130: </em><font color="red"><strong>}</strong></font>
<em>131: </em>
<em>132: </em>direct_declarator(A) ::= IDENTIFIER(B). <font color="red"><strong>{</strong></font>
<em>133: </em>  A = new Declaration(String(B._str.p,B._str.l));
<em>134: </em>  cp-&gt;setinfo(A);
<em>135: </em><font color="red"><strong>}</strong></font>
<em>136: </em>direct_declarator(A) ::= direct_declarator(B) LPAREN parameter_type_list(C) RPAREN. <font color="red"><strong>{</strong></font>
<em>137: </em>  A = B;
<em>138: </em>  dynamic_cast&lt;Declaration&amp;&gt;(*A).add_type(new FunctionType(C));
<em>139: </em><font color="red"><strong>}</strong></font>
<em>140: </em>direct_declarator(A) ::= direct_declarator(B) LPAREN RPAREN. <font color="red"><strong>{</strong></font>
<em>141: </em>  A = B;
<em>142: </em>  dynamic_cast&lt;Declaration&amp;&gt;(*A).add_type(new FunctionType(new ParamList));
<em>143: </em><font color="red"><strong>}</strong></font>
<em>144: </em>
<em>145: </em>parameter_type_list(A) ::= parameter_list(B). <font color="red"><strong>{</strong></font>
<em>146: </em>  A = B;
<em>147: </em><font color="red"><strong>}</strong></font>
<em>148: </em>parameter_type_list(A) ::= parameter_list(B) COMMA ELLIPSIS. <font color="red"><strong>{</strong></font>
<em>149: </em>  A = B;
<em>150: </em>  dynamic_cast&lt;ParamList&amp;&gt;(*A).set_has_ellipsis();
<em>151: </em><font color="red"><strong>}</strong></font>
<em>152: </em>
<em>153: </em>parameter_list(A) ::= parameter_declaration(B). <font color="red"><strong>{</strong></font>
<em>154: </em>  A = new ParamList(B);
<em>155: </em>  cp-&gt;setinfo(A);
<em>156: </em><font color="red"><strong>}</strong></font>
<em>157: </em>parameter_list(A) ::= parameter_list(B) COMMA parameter_declaration(C). <font color="red"><strong>{</strong></font>
<em>158: </em>  A = B;
<em>159: </em>  A-&gt;add(C);
<em>160: </em><font color="red"><strong>}</strong></font>
<em>161: </em>
<em>162: </em>parameter_declaration(A) ::= type_specifier(B) declarator(C). <font color="red"><strong>{</strong></font>
<em>163: </em>  A = declaration(B,C);
<em>164: </em><font color="red"><strong>}</strong></font>
<em>165: </em>
<em>166: </em>compound_statement(A) ::= LBRACE declaration_list_opt(B) statement_list(C) RBRACE. <font color="red"><strong>{</strong></font>
<em>167: </em>  A = new CompoundStatement(B,C);
<em>168: </em>  cp-&gt;setinfo(A);
<em>169: </em><font color="red"><strong>}</strong></font>
<em>170: </em>compound_statement(A) ::= LBRACE declaration_list_opt(B) RBRACE. <font color="red"><strong>{</strong></font>
<em>171: </em>  A = new CompoundStatement(B,new NullNode());
<em>172: </em>  cp-&gt;setinfo(A);
<em>173: </em><font color="red"><strong>}</strong></font>
<em>174: </em>
<em>175: </em>expression_statement(A) ::= expression(B) SEMICOLON. <font color="red"><strong>{</strong></font>
<em>176: </em>  A = B;
<em>177: </em><font color="red"><strong>}</strong></font>
<em>178: </em>
<em>179: </em>expression(A) ::= equality_expression(B). <font color="red"><strong>{</strong></font>
<em>180: </em>  A = B;
<em>181: </em><font color="red"><strong>}</strong></font>
<em>182: </em>expression(A) ::= equality_expression(B) ASSIGN(Op) expression(C). <font color="red"><strong>{</strong></font>
<em>183: </em>  A = new Binop(B,Op._tok,C);
<em>184: </em>  cp-&gt;setinfo(A);
<em>185: </em><font color="red"><strong>}</strong></font>
<em>186: </em>expression(A) ::= equality_expression(B) ADD_ASSIGN(Op) expression(C). <font color="red"><strong>{</strong></font>
<em>187: </em>  A = new Binop(B,Op._tok,C);
<em>188: </em>  cp-&gt;setinfo(A);
<em>189: </em><font color="red"><strong>}</strong></font>
<em>190: </em>expression(A) ::= equality_expression(B) SUB_ASSIGN(Op) expression(C). <font color="red"><strong>{</strong></font>
<em>191: </em>  A = new Binop(B,Op._tok,C);
<em>192: </em>  cp-&gt;setinfo(A);
<em>193: </em><font color="red"><strong>}</strong></font>
<em>194: </em>
<em>195: </em>equality_expression(A) ::= relational_expression(B). <font color="red"><strong>{</strong></font>
<em>196: </em>  A = B;
<em>197: </em><font color="red"><strong>}</strong></font>
<em>198: </em>equality_expression(A) ::= equality_expression(B) EQ(Op) relational_expression(C). <font color="red"><strong>{</strong></font>
<em>199: </em>  A = get_calculated(new Binop(B,Op._tok,C));
<em>200: </em><font color="red"><strong>}</strong></font>
<em>201: </em>equality_expression(A) ::= equality_expression(B) NOT_EQ(Op) relational_expression(C). <font color="red"><strong>{</strong></font>
<em>202: </em>  A = get_calculated(new Binop(B,Op._tok,C));
<em>203: </em><font color="red"><strong>}</strong></font>
<em>204: </em>
<em>205: </em>relational_expression(A) ::= additive_expression(B). <font color="red"><strong>{</strong></font>
<em>206: </em>  A = B;
<em>207: </em><font color="red"><strong>}</strong></font>
<em>208: </em>relational_expression(A) ::= relational_expression(B) LESS(Op) additive_expression(C). <font color="red"><strong>{</strong></font>
<em>209: </em>  A = get_calculated(new Binop(B,Op._tok,C));
<em>210: </em><font color="red"><strong>}</strong></font>
<em>211: </em>relational_expression(A) ::= relational_expression(B) GREATER(Op) additive_expression(C). <font color="red"><strong>{</strong></font>
<em>212: </em>  A = get_calculated(new Binop(B,Op._tok,C));
<em>213: </em><font color="red"><strong>}</strong></font>
<em>214: </em>relational_expression(A) ::= relational_expression(B) LESS_EQ(Op) additive_expression(C). <font color="red"><strong>{</strong></font>
<em>215: </em>  A = get_calculated(new Binop(B,Op._tok,C));
<em>216: </em><font color="red"><strong>}</strong></font>
<em>217: </em>relational_expression(A) ::= relational_expression(B) GREATER_EQ(Op) additive_expression(C). <font color="red"><strong>{</strong></font>
<em>218: </em>  A = get_calculated(new Binop(B,Op._tok,C));
<em>219: </em><font color="red"><strong>}</strong></font>
<em>220: </em>
<em>221: </em>postfix_expression(A) ::= primary_expression(B). <font color="red"><strong>{</strong></font>
<em>222: </em>  A = B;
<em>223: </em><font color="red"><strong>}</strong></font>
<em>224: </em>postfix_expression(A) ::= postfix_expression(B) LPAREN argument_expression_list(C) RPAREN. <font color="red"><strong>{</strong></font>
<em>225: </em>  A = new FunctionExpression(B,C);
<em>226: </em>  cp-&gt;setinfo(A);
<em>227: </em><font color="red"><strong>}</strong></font>
<em>228: </em>postfix_expression(A) ::= postfix_expression(B) LPAREN RPAREN. <font color="red"><strong>{</strong></font>
<em>229: </em>  A = new FunctionExpression(B,new ArgumentList);
<em>230: </em>  cp-&gt;setinfo(A);
<em>231: </em><font color="red"><strong>}</strong></font>
<em>232: </em>postfix_expression(A) ::= postfix_expression(B) LBRACKET expression(C) RBRACKET. <font color="red"><strong>{</strong></font>
<em>233: </em>  A = new ArrayExpression(B,C);
<em>234: </em>  cp-&gt;setinfo(A);
<em>235: </em><font color="red"><strong>}</strong></font>  
<em>236: </em>
<em>237: </em>argument_expression_list(A) ::= expression(B). <font color="red"><strong>{</strong></font>
<em>238: </em>  A = new ArgumentList(B);
<em>239: </em>  cp-&gt;setinfo(A);
<em>240: </em><font color="red"><strong>}</strong></font>
<em>241: </em>argument_expression_list(A) ::= argument_expression_list(B) COMMA expression(C). <font color="red"><strong>{</strong></font>
<em>242: </em>  A = B;
<em>243: </em>  A-&gt;add(C);
<em>244: </em><font color="red"><strong>}</strong></font>
<em>245: </em>
<em>246: </em>unary_expression(A) ::= postfix_expression(B). <font color="red"><strong>{</strong></font>
<em>247: </em>  A = B;
<em>248: </em><font color="red"><strong>}</strong></font>
<em>249: </em>unary_expression(A) ::= MINUS unary_expression(B). <font color="red"><strong>{</strong></font>
<em>250: </em>  A = get_calculated(new Negative(B));
<em>251: </em>  cp-&gt;setinfo(A);
<em>252: </em><font color="red"><strong>}</strong></font>
<em>253: </em>unary_expression ::= PLUS unary_expression.
<em>254: </em>unary_expression(A) ::= EXCLAMATION unary_expression(B). <font color="red"><strong>{</strong></font>
<em>255: </em>  <font color="#ffa600"><em>// Hack:  replace !expr with (expr == 0).</em></font>
<em>256: </em>  A = get_calculated(new Binop(B,EQ,new Const(0,new BaseType(BaseType::Int)))); 
<em>257: </em>  cp-&gt;setinfo(A);
<em>258: </em><font color="red"><strong>}</strong></font>
<em>259: </em>unary_expression(A) ::= ASTERISK unary_expression(B). <font color="red"><strong>{</strong></font>
<em>260: </em>  A = new Pointer(B);
<em>261: </em>  cp-&gt;setinfo(A);
<em>262: </em><font color="red"><strong>}</strong></font>
<em>263: </em>unary_expression(A) ::= AMPERSAND unary_expression(B). <font color="red"><strong>{</strong></font>
<em>264: </em>  A = new AddrOf(B);
<em>265: </em>  cp-&gt;setinfo(A);
<em>266: </em><font color="red"><strong>}</strong></font>
<em>267: </em>
<em>268: </em>mult_expression(A) ::= unary_expression(B). <font color="red"><strong>{</strong></font>
<em>269: </em>  A = B;
<em>270: </em><font color="red"><strong>}</strong></font>
<em>271: </em>mult_expression(A) ::= mult_expression(B) ASTERISK(Op) unary_expression(C). <font color="red"><strong>{</strong></font>
<em>272: </em>  A = get_calculated(new Binop(B,Op._tok,C));
<em>273: </em>  cp-&gt;setinfo(A);
<em>274: </em><font color="red"><strong>}</strong></font>
<em>275: </em>mult_expression(A) ::= mult_expression(B) DIV(Op) unary_expression(C). <font color="red"><strong>{</strong></font>
<em>276: </em>  A = get_calculated(new Binop(B,Op._tok,C));
<em>277: </em>  cp-&gt;setinfo(A);
<em>278: </em><font color="red"><strong>}</strong></font>
<em>279: </em>mult_expression(A) ::= mult_expression(B) MODULO(Op) unary_expression(C). <font color="red"><strong>{</strong></font>
<em>280: </em>  A = get_calculated(new Binop(B,Op._tok,C));
<em>281: </em>  cp-&gt;setinfo(A);
<em>282: </em><font color="red"><strong>}</strong></font>
<em>283: </em>
<em>284: </em>additive_expression(A) ::= mult_expression(B). <font color="red"><strong>{</strong></font>
<em>285: </em>  A = B;
<em>286: </em><font color="red"><strong>}</strong></font>
<em>287: </em>additive_expression(A) ::= additive_expression(B) PLUS(Op) mult_expression(C). <font color="red"><strong>{</strong></font>
<em>288: </em>  A = get_calculated(new Binop(B,Op._tok,C));
<em>289: </em>  cp-&gt;setinfo(A);
<em>290: </em><font color="red"><strong>}</strong></font>
<em>291: </em>additive_expression(A) ::=  additive_expression(B) MINUS(Op) mult_expression(C). <font color="red"><strong>{</strong></font>
<em>292: </em>  A = get_calculated(new Binop(B,Op._tok,C));
<em>293: </em>  cp-&gt;setinfo(A);
<em>294: </em><font color="red"><strong>}</strong></font>
<em>295: </em>
<em>296: </em>primary_expression(A) ::= IDENTIFIER(B). <font color="red"><strong>{</strong></font> 
<em>297: </em>  A = new Id(String(B._str.p,B._str.l)); 
<em>298: </em>  cp-&gt;setinfo(A); 
<em>299: </em><font color="red"><strong>}</strong></font>
<em>300: </em>primary_expression(A) ::= INTCONST(B). <font color="red"><strong>{</strong></font> 
<em>301: </em>  A = new Const(B._int,new BaseType(BaseType::Int)); 
<em>302: </em>  cp-&gt;setinfo(A); 
<em>303: </em><font color="red"><strong>}</strong></font>
<em>304: </em>primary_expression(A) ::= FPCONST(B). <font color="red"><strong>{</strong></font> 
<em>305: </em>  A = new Const((int)B._fp,new BaseType(BaseType::Double)); 
<em>306: </em>  cp-&gt;setinfo(A); 
<em>307: </em><font color="red"><strong>}</strong></font>
<em>308: </em>primary_expression(A) ::= CHARCONST(B). <font color="red"><strong>{</strong></font> 
<em>309: </em>  A = new Const(B._int,new BaseType(BaseType::Char)); 
<em>310: </em>  cp-&gt;setinfo(A); 
<em>311: </em><font color="red"><strong>}</strong></font>
<em>312: </em>primary_expression(A) ::= string_literal(B). <font color="red"><strong>{</strong></font>
<em>313: </em>  A = B;
<em>314: </em><font color="red"><strong>}</strong></font>
<em>315: </em>primary_expression(A) ::= LPAREN expression(B) RPAREN. <font color="red"><strong>{</strong></font> 
<em>316: </em>  A = B; 
<em>317: </em><font color="red"><strong>}</strong></font>
<em>318: </em>
<em>319: </em>%type string_literal <font color="red"><strong>{</strong></font> StringLiteral * <font color="red"><strong>}</strong></font>
<em>320: </em>string_literal(A) ::= STRING_LITERAL(B). <font color="red"><strong>{</strong></font> 
<em>321: </em>  A = new StringLiteral(String(B._str.p,B._str.l)); 
<em>322: </em>  cp-&gt;setinfo(A); 
<em>323: </em><font color="red"><strong>}</strong></font>
<em>324: </em>string_literal(A) ::= string_literal(B) STRING_LITERAL(C). <font color="red"><strong>{</strong></font> 
<em>325: </em>  A = B;
<em>326: </em>  B-&gt;append(String(C._str.p,C._str.l)); 
<em>327: </em><font color="red"><strong>}</strong></font>
<em>328: </em>
<em>329: </em>statement(A) ::= compound_statement(B). <font color="red"><strong>{</strong></font>
<em>330: </em>  A = B;
<em>331: </em><font color="red"><strong>}</strong></font>
<em>332: </em>statement(A) ::= expression_statement(B). <font color="red"><strong>{</strong></font>
<em>333: </em>  A = B;
<em>334: </em><font color="red"><strong>}</strong></font>
<em>335: </em>statement(A) ::= selection_statement(B). <font color="red"><strong>{</strong></font>
<em>336: </em>  A = B;
<em>337: </em><font color="red"><strong>}</strong></font>
<em>338: </em>statement(A) ::= iteration_statement(B). <font color="red"><strong>{</strong></font>
<em>339: </em>  A = B;
<em>340: </em><font color="red"><strong>}</strong></font>
<em>341: </em>statement(A) ::= jump_statement(B). <font color="red"><strong>{</strong></font>
<em>342: </em>  A = B;
<em>343: </em><font color="red"><strong>}</strong></font>
<em>344: </em>
<em>345: </em>jump_statement(A) ::= RETURN SEMICOLON. <font color="red"><strong>{</strong></font> 
<em>346: </em>  A = new ReturnStatement(new NullNode()); 
<em>347: </em>  cp-&gt;setinfo(A); 
<em>348: </em><font color="red"><strong>}</strong></font>
<em>349: </em>jump_statement(A) ::= RETURN expression(B) SEMICOLON. <font color="red"><strong>{</strong></font> 
<em>350: </em>  A = new ReturnStatement(B); 
<em>351: </em>  cp-&gt;setinfo(A); 
<em>352: </em><font color="red"><strong>}</strong></font>
<em>353: </em>jump_statement(A) ::= BREAK SEMICOLON. <font color="red"><strong>{</strong></font> 
<em>354: </em>  A = new BreakStatement; 
<em>355: </em>  cp-&gt;setinfo(A); 
<em>356: </em><font color="red"><strong>}</strong></font>
<em>357: </em>jump_statement(A) ::= CONTINUE SEMICOLON. <font color="red"><strong>{</strong></font> 
<em>358: </em>  A = new ContinueStatement; 
<em>359: </em>  cp-&gt;setinfo(A); 
<em>360: </em><font color="red"><strong>}</strong></font>
<em>361: </em>
<em>362: </em>iteration_statement(A) ::= WHILE LPAREN expression(B) RPAREN statement(C). <font color="red"><strong>{</strong></font> 
<em>363: </em>  A = new WhileLoop(B,C); 
<em>364: </em>  cp-&gt;setinfo(A); 
<em>365: </em><font color="red"><strong>}</strong></font>
<em>366: </em>iteration_statement(A) ::= FOR LPAREN expression_statement(B) expression_statement(C) expression(D) RPAREN statement(E). <font color="red"><strong>{</strong></font> 
<em>367: </em>  A = new ForLoop(B,C,D,E); 
<em>368: </em>  cp-&gt;setinfo(A); 
<em>369: </em><font color="red"><strong>}</strong></font>
<em>370: </em>
<em>371: </em>selection_statement(A) ::= IF LPAREN expression(B) RPAREN statement(C). [LOWER_THAN_ELSE] <font color="red"><strong>{</strong></font> 
<em>372: </em>  A = new IfStatement(B,C,new NullNode); 
<em>373: </em>  cp-&gt;setinfo(A); 
<em>374: </em><font color="red"><strong>}</strong></font>
<em>375: </em>selection_statement(A) ::= IF LPAREN expression(B) RPAREN statement(C) ELSE statement(D). <font color="red"><strong>{</strong></font> 
<em>376: </em>  A = new IfStatement(B,C,D);  
<em>377: </em>  cp-&gt;setinfo(A); 
<em>378: </em><font color="red"><strong>}</strong></font>
<em>379: </em>
<em>380: </em>statement_list(A) ::= statement(B). <font color="red"><strong>{</strong></font> 
<em>381: </em>  A = new StatementList(B); 
<em>382: </em>  cp-&gt;setinfo(A); 
<em>383: </em><font color="red"><strong>}</strong></font>
<em>384: </em>statement_list(A) ::= statement_list(B) statement(C). <font color="red"><strong>{</strong></font> 
<em>385: </em>  A = B; 
<em>386: </em>  A-&gt;add(C); 
<em>387: </em><font color="red"><strong>}</strong></font>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
</div>
<!--  -->
<a name=""></a>
<div class="skribesubsectiontitle"><table width="100%"><tr><td bgcolor="#ffffff"><h3><font color="#8381de">5.5 </font>
</h3></td></tr></table>
</div><div class="subsection">
Abstract Syntax Tree<!-- cc/Node.h -->
<a name="cc/Node.h"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">5.5.1 cc/Node.h</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em>  1: </em><font color="#ffa600"><em>//</em></font>
<em>  2: </em><font color="#ffa600"><em>// Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.</em></font>
<em>  3: </em><font color="#ffa600"><em>//</em></font>
<em>  4: </em><font color="#ffa600"><em>// You may distribute under the terms of the Artistic License, as specified in</em></font>
<em>  5: </em><font color="#ffa600"><em>// the COPYING file.</em></font>
<em>  6: </em><font color="#ffa600"><em>//</em></font>
<em>  7: </em><font color="#ffa600"><em>//</em></font>
<em>  8: </em><font color="#ffa600"><em>// AST nodes used by the compiler.</em></font>
<em>  9: </em><font color="#ffa600"><em>// These are garbage collected when allocated</em></font>
<em> 10: </em><font color="#ffa600"><em>// from the heap.  However, they do not register</em></font>
<em> 11: </em><font color="#ffa600"><em>// a finalizer, so thir destructors will not be called.</em></font>
<em> 12: </em><font color="#ffa600"><em>//</em></font>
<em> 13: </em>
<em> 14: </em>#ifndef _NODE_H_
<em> 15: </em><font color="#1919af"><strong>#define</strong></font> _NODE_H_
<em> 16: </em>
<em> 17: </em><font color="#1919af"><strong>#include</strong></font> &lt;vector&gt;
<em> 18: </em>
<em> 19: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;gc/gc_cpp.h&quot;</font>
<em> 20: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;gc/gc_allocator.h&quot;</font>
<em> 21: </em>
<em> 22: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;String.h&quot;</font>
<em> 23: </em>
<em> 24: </em><strong>class</strong> String;
<em> 25: </em><strong>class</strong> SymTab;
<em> 26: </em><strong>class</strong> CodeGen;
<em> 27: </em><strong>class</strong> AsmStore;
<em> 28: </em><strong>class</strong> CompileLoc;
<em> 29: </em>
<em> 30: </em><font color="#1919af"><strong>#define</strong></font> Error(n,x) <font color="red"><strong>{</strong></font> \
<em> 31: </em>  ostringstream ss; \
<em> 32: </em>  ss &lt;&lt; n-&gt;filename() &lt;&lt; <font color="red">&quot;:&quot;</font> &lt;&lt; n-&gt;linenumber() &lt;&lt; <font color="red">&quot;:  Error:  &quot;</font> &lt;&lt; x; \
<em> 33: </em>  <strong>throw</strong> runtime_error(ss.str()); \
<em> 34: </em><font color="red"><strong>}</strong></font>
<em> 35: </em>
<em> 36: </em><font color="#1919af"><strong>#define</strong></font> Error1(x) <font color="red"><strong>{</strong></font> \
<em> 37: </em>  ostringstream ss; \
<em> 38: </em>  ss &lt;&lt; <font color="red">&quot;Error:  &quot;</font> &lt;&lt; x; \
<em> 39: </em>  <strong>throw</strong> runtime_error(ss.str()); \
<em> 40: </em><font color="red"><strong>}</strong></font>
<em> 41: </em>
<em> 42: </em><font color="#1919af"><strong>#define</strong></font> Warn(n,x) <font color="red"><strong>{</strong></font> \
<em> 43: </em>  cerr &lt;&lt; n-&gt;filename() &lt;&lt; <font color="red">&quot;:&quot;</font> &lt;&lt; n-&gt;linenumber() &lt;&lt; <font color="red">&quot;:  Warning:  &quot;</font> &lt;&lt; x &lt;&lt; <font color="red">&quot;\n&quot;</font>; \
<em> 44: </em><font color="red"><strong>}</strong></font>
<em> 45: </em>
<em> 46: </em><strong>struct</strong> Type;
<em> 47: </em>
<em> 48: </em><font color="#ffa600"><em>// Various manipulators for setting stream attributes.</em></font>
<em> 49: </em>
<em> 50: </em><font color="#ffa600"><em>// Use this manipulator to indicate that you want symbols to be printed.</em></font>
<em> 51: </em>std::ostream &amp;printsyms(std::ostream &amp;o);
<em> 52: </em><font color="#ffa600"><em>// Turn of symbol printing.</em></font>
<em> 53: </em>std::ostream &amp;noprintsyms(std::ostream &amp;o);
<em> 54: </em><font color="#ffa600"><em>// Return current indentation amount.</em></font>
<em> 55: </em>int curindent(std::ostream &amp;o);
<em> 56: </em><font color="#ffa600"><em>// Insert indentation whitespace.</em></font>
<em> 57: </em>std::ostream &amp;indent(std::ostream &amp;o);
<em> 58: </em><font color="#ffa600"><em>// Increment indentation amount.</em></font>
<em> 59: </em>std::ostream &amp;incrindent(std::ostream &amp;o);
<em> 60: </em><font color="#ffa600"><em>// Decrement indentation amount.</em></font>
<em> 61: </em>std::ostream &amp;decrindent(std::ostream &amp;o);
<em> 62: </em>
<em> 63: </em><strong>struct</strong> Node : public gc <font color="red"><strong>{</strong></font>
<em> 64: </em>  Node(Type *t = 0);
<em> 65: </em>  virtual ~Node();
<em> 66: </em>  <font color="#ffa600"><em>// Return true if we're a null class (leaf node).</em></font>
<em> 67: </em>  virtual bool is_null() const <font color="red"><strong>{</strong></font> <strong>return</strong> false; <font color="red"><strong>}</strong></font>;
<em> 68: </em>  <font color="#ffa600"><em>// Returns true if we're a constant e.g. 5, &quot;hello&quot;, etc.</em></font>
<em> 69: </em>  virtual bool is_const() const <font color="red"><strong>{</strong></font> <strong>return</strong> false; <font color="red"><strong>}</strong></font>;
<em> 70: </em>  <font color="#ffa600"><em>// Returns true if node has an address, i.e. is a valid lvalue.</em></font>
<em> 71: </em>  bool has_address() const <font color="red"><strong>{</strong></font> <strong>return</strong> _has_addr; <font color="red"><strong>}</strong></font>;
<em> 72: </em>  <font color="#ffa600"><em>// Specifies that we have an address.</em></font>
<em> 73: </em>  void set_has_address() <font color="red"><strong>{</strong></font> _has_addr = true; <font color="red"><strong>}</strong></font>;
<em> 74: </em>  <font color="#ffa600"><em>// Getter/setter for has-return-stmt.</em></font>
<em> 75: </em>  bool has_return_stmt() const <font color="red"><strong>{</strong></font> <strong>return</strong> _has_return_stmt; <font color="red"><strong>}</strong></font>;
<em> 76: </em>  void set_has_return_stmt(bool h) <font color="red"><strong>{</strong></font> _has_return_stmt = h; <font color="red"><strong>}</strong></font>;
<em> 77: </em>  <font color="#ffa600"><em>// Get the symbol table for this node.</em></font>
<em> 78: </em>  virtual SymTab *symtab() const <font color="red"><strong>{</strong></font> <strong>return</strong> 0; <font color="red"><strong>}</strong></font>;
<em> 79: </em>  <font color="#ffa600"><em>// Get a symbol associated with this node, if applicable.</em></font>
<em> 80: </em>  virtual Node *symbol() const <font color="red"><strong>{</strong></font> <strong>return</strong> 0; <font color="red"><strong>}</strong></font>;
<em> 81: </em>  <font color="#ffa600"><em>// Getter/setter for output_addr.</em></font>
<em> 82: </em>  int output_addr() const <font color="red"><strong>{</strong></font> <strong>return</strong> _output_addr; <font color="red"><strong>}</strong></font>;
<em> 83: </em>  void set_output_addr(int oa) <font color="red"><strong>{</strong></font> _output_addr = oa; <font color="red"><strong>}</strong></font>;
<em> 84: </em>  <font color="#ffa600"><em>// Getter/setter for compile location.</em></font>
<em> 85: </em>  CompileLoc *compile_loc() const <font color="red"><strong>{</strong></font> <strong>return</strong> _compile_loc; <font color="red"><strong>}</strong></font>;
<em> 86: </em>  void set_compile_loc(CompileLoc *cl) <font color="red"><strong>{</strong></font> _compile_loc = cl; <font color="red"><strong>}</strong></font>;
<em> 87: </em>  <font color="#ffa600"><em>// True if object is externally defined.</em></font>
<em> 88: </em>  virtual bool is_extern() const <font color="red"><strong>{</strong></font> <strong>return</strong> false; <font color="red"><strong>}</strong></font>;
<em> 89: </em>  virtual bool is_static() const <font color="red"><strong>{</strong></font> <strong>return</strong> false; <font color="red"><strong>}</strong></font>;
<em> 90: </em>  <font color="#ffa600"><em>// Getter/setter for whether a variable is used.  Overload</em></font>
<em> 91: </em>  <font color="#ffa600"><em>// to provide functionality.</em></font>
<em> 92: </em>  virtual bool is_used() const <font color="red"><strong>{</strong></font> <strong>return</strong> false; <font color="red"><strong>}</strong></font>;
<em> 93: </em>  virtual void set_used() <font color="red"><strong>{</strong></font> <font color="red"><strong>}</strong></font>;
<em> 94: </em>  <font color="#ffa600"><em>// Getter/setter for coerce-to-type.</em></font>
<em> 95: </em>  Type *coerce_to_type() const <font color="red"><strong>{</strong></font> <strong>return</strong> _coerce_to_type; <font color="red"><strong>}</strong></font>;
<em> 96: </em>  void set_coerce_to_type(Type *t) <font color="red"><strong>{</strong></font> _coerce_to_type = t; <font color="red"><strong>}</strong></font>;
<em> 97: </em>  <font color="#ffa600"><em>// Item's name, if applicable.</em></font>
<em> 98: </em>  virtual String name() const <font color="red"><strong>{</strong></font> <strong>return</strong> String(); <font color="red"><strong>}</strong></font>;
<em> 99: </em>  <font color="#ffa600"><em>// Its constant value, if appropriate.</em></font>
<em>100: </em>  virtual int value() const <font color="red"><strong>{</strong></font> <strong>return</strong> 0; <font color="red"><strong>}</strong></font>;
<em>101: </em>  <font color="#ffa600"><em>// Returns the node's type.</em></font>
<em>102: </em>  Type *type() const <font color="red"><strong>{</strong></font> <strong>return</strong> _type; <font color="red"><strong>}</strong></font>;
<em>103: </em>  <font color="#ffa600"><em>// Change the node's type.</em></font>
<em>104: </em>  void set_type(Type *t) <font color="red"><strong>{</strong></font> _type = t; <font color="red"><strong>}</strong></font>;
<em>105: </em>  <font color="#ffa600"><em>// This will just assert- a collection class should overload</em></font>
<em>106: </em>  <font color="#ffa600"><em>// this to store multiple items.</em></font>
<em>107: </em>  virtual void add(Node *n);
<em>108: </em>  <font color="#ffa600"><em>// Calculates a constant integer if the node represents</em></font>
<em>109: </em>  <font color="#ffa600"><em>// a constant expression, e.g. returns a node storing</em></font>
<em>110: </em>  <font color="#ffa600"><em>// 30 if the node represents an expression of 3*10.</em></font>
<em>111: </em>  <font color="#ffa600"><em>// Returns false in second if not constant, otherwise </em></font>
<em>112: </em>  <font color="#ffa600"><em>// the result in first and true in second.</em></font>
<em>113: </em>  <strong>typedef</strong> std::pair&lt;int,bool&gt; Calc;
<em>114: </em>  virtual Calc calculate() const;
<em>115: </em>
<em>116: </em>  void setFileData(const char *fn,int ln);
<em>117: </em>  int linenumber() const <font color="red"><strong>{</strong></font> <strong>return</strong> _linenumber; <font color="red"><strong>}</strong></font>;
<em>118: </em>  const char *filename() const <font color="red"><strong>{</strong></font> <strong>return</strong> _filename; <font color="red"><strong>}</strong></font>;
<em>119: </em>
<em>120: </em>  <font color="#ffa600"><em>// These are the main &quot;services&quot; which traverse the ATS,</em></font>
<em>121: </em>  <font color="#ffa600"><em>// performing various compiler passes.</em></font>
<em>122: </em>
<em>123: </em>  <font color="#ffa600"><em>// Print to the specified stream.  Argument is number of </em></font>
<em>124: </em>  <font color="#ffa600"><em>// characters to indent.</em></font>
<em>125: </em>  void print(std::ostream &amp;) const;
<em>126: </em>  <font color="#ffa600"><em>// Generate symbol tables.  Traverse the AST and generate</em></font>
<em>127: </em>  <font color="#ffa600"><em>// symbol tables as we go.  Throws a runtime_error if errors</em></font>
<em>128: </em>  <font color="#ffa600"><em>// are encountered.</em></font>
<em>129: </em>  void gensymtab();
<em>130: </em>  <font color="#ffa600"><em>// Perform type checking.  Throws a runtime_error if errors</em></font>
<em>131: </em>  <font color="#ffa600"><em>// are encountered.</em></font>
<em>132: </em>  void typecheck();  
<em>133: </em>  <font color="#ffa600"><em>// Perform flow-control checking:  Makes sure that all</em></font>
<em>134: </em>  <font color="#ffa600"><em>// branches of a function return a value, check break/continue</em></font>
<em>135: </em>  <font color="#ffa600"><em>// statements, etc.</em></font>
<em>136: </em>  void flowcontrol();
<em>137: </em>  <font color="#ffa600"><em>// Do necessary checks.</em></font>
<em>138: </em>  virtual bool dochecks(CodeGen &amp;);
<em>139: </em>  <font color="#ffa600"><em>// Generate code.  In general, these should just call the</em></font>
<em>140: </em>  <font color="#ffa600"><em>// appropriate routine in CodeGen, which will do the actual work.</em></font>
<em>141: </em>  virtual void codegen(CodeGen &amp;);
<em>142: </em>  <font color="#ffa600"><em>// Write code to specified stream.</em></font>
<em>143: </em>  virtual void writecode(std::ostream &amp;) const;
<em>144: </em>
<em>145: </em>  <font color="#ffa600"><em>// Used internally- don't call directly.</em></font>
<em>146: </em>  virtual void gensymtab(SymTab *);
<em>147: </em>  virtual void typecheck(Node *);
<em>148: </em>  virtual void flowcontrol(Node *,bool);
<em>149: </em>protected:
<em>150: </em>  <font color="#ffa600"><em>// This prints class-specific information.</em></font>
<em>151: </em>  virtual void printdata(std::ostream &amp;) const;
<em>152: </em>
<em>153: </em>  bool        _has_return_stmt;
<em>154: </em>  bool        _has_addr;
<em>155: </em>  int         _output_addr;
<em>156: </em>  CompileLoc *_compile_loc;
<em>157: </em>  Type       *_type;
<em>158: </em>  Type       *_coerce_to_type;
<em>159: </em>  const char *_filename;
<em>160: </em>  int         _linenumber;
<em>161: </em><font color="red"><strong>}</strong></font>;
<em>162: </em>
<em>163: </em>std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const Node *n);
<em>164: </em>
<em>165: </em><font color="#ffa600"><em>// Null-terminator node in an AST.</em></font>
<em>166: </em><strong>struct</strong> NullNode : public Node <font color="red"><strong>{</strong></font>
<em>167: </em>  NullNode();
<em>168: </em>  virtual bool is_null() const <font color="red"><strong>{</strong></font> <strong>return</strong> true; <font color="red"><strong>}</strong></font>;
<em>169: </em><font color="red"><strong>}</strong></font>;
<em>170: </em>
<em>171: </em><font color="#ffa600"><em>// Expression w/array notation, e.g. a[5+4].</em></font>
<em>172: </em><strong>struct</strong> ArrayExpression : public Node <font color="red"><strong>{</strong></font>
<em>173: </em>  ArrayExpression(Node *expr, Node *index) :
<em>174: </em>    _expr(expr), _index(index) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>
<em>175: </em>  virtual void gensymtab(SymTab *);
<em>176: </em>  virtual void typecheck(Node *);
<em>177: </em>  virtual void codegen(CodeGen &amp;);
<em>178: </em>
<em>179: </em>  Node *expr() const <font color="red"><strong>{</strong></font> <strong>return</strong> _expr; <font color="red"><strong>}</strong></font>;
<em>180: </em>  Node *index() const <font color="red"><strong>{</strong></font> <strong>return</strong> _index; <font color="red"><strong>}</strong></font>;
<em>181: </em>protected:
<em>182: </em>  virtual void printdata(std::ostream &amp;) const;
<em>183: </em>
<em>184: </em>  Node *_expr;
<em>185: </em>  Node *_index;
<em>186: </em><font color="red"><strong>}</strong></font>;
<em>187: </em>
<em>188: </em><font color="#ffa600"><em>// String literal node.</em></font>
<em>189: </em><strong>struct</strong> StringLiteral : public Node <font color="red"><strong>{</strong></font>
<em>190: </em>  StringLiteral(String s);
<em>191: </em>  void append(String s);
<em>192: </em>  String get() const <font color="red"><strong>{</strong></font> <strong>return</strong> _s; <font color="red"><strong>}</strong></font>;
<em>193: </em>
<em>194: </em>  virtual void codegen(CodeGen &amp;);
<em>195: </em>protected:
<em>196: </em>  virtual void printdata(std::ostream &amp;) const;
<em>197: </em>
<em>198: </em>private:
<em>199: </em>  String _s;
<em>200: </em><font color="red"><strong>}</strong></font>;
<em>201: </em>
<em>202: </em><font color="#ffa600"><em>// Identifier node.</em></font>
<em>203: </em><strong>struct</strong> Id : public Node <font color="red"><strong>{</strong></font>
<em>204: </em>  Id(String id) : _id(id), _symbol(0) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>205: </em>
<em>206: </em>  virtual String name() const <font color="red"><strong>{</strong></font> <strong>return</strong> _id; <font color="red"><strong>}</strong></font>;
<em>207: </em>  virtual Node *symbol() const <font color="red"><strong>{</strong></font> <strong>return</strong> _symbol; <font color="red"><strong>}</strong></font>;
<em>208: </em>
<em>209: </em>  virtual void gensymtab(SymTab *);
<em>210: </em>  virtual void typecheck(Node *);
<em>211: </em>  virtual void codegen(CodeGen &amp;);
<em>212: </em>protected:
<em>213: </em>  virtual void printdata(std::ostream &amp;) const;
<em>214: </em>
<em>215: </em>private:
<em>216: </em>  String  _id;
<em>217: </em>  Node   *_symbol;
<em>218: </em><font color="red"><strong>}</strong></font>;
<em>219: </em>
<em>220: </em><font color="#ffa600"><em>// Numeric constants.</em></font>
<em>221: </em><strong>struct</strong> Const : public Node <font color="red"><strong>{</strong></font>
<em>222: </em>  Const(int value,Type *type) : Node(type), _value(value) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>223: </em>  Calc calculate() const;
<em>224: </em>
<em>225: </em>  virtual bool is_const() const <font color="red"><strong>{</strong></font> <strong>return</strong> true; <font color="red"><strong>}</strong></font>;
<em>226: </em>  virtual int value() const <font color="red"><strong>{</strong></font> <strong>return</strong> _value; <font color="red"><strong>}</strong></font>;
<em>227: </em>
<em>228: </em>  virtual void codegen(CodeGen &amp;);
<em>229: </em>protected:
<em>230: </em>  virtual void printdata(std::ostream &amp;) const;
<em>231: </em>
<em>232: </em>private:
<em>233: </em>  int _value;
<em>234: </em><font color="red"><strong>}</strong></font>;
<em>235: </em>
<em>236: </em><font color="#ffa600"><em>// Tries to calculate the value of a numeric expression.</em></font>
<em>237: </em><font color="#ffa600"><em>// If it can, it returns a constant node, otherwise it</em></font>
<em>238: </em><font color="#ffa600"><em>// returns the original tree.</em></font>
<em>239: </em>Node *get_calculated(Node *);
<em>240: </em>
<em>241: </em><font color="#ffa600"><em>// Any generic unary operator.</em></font>
<em>242: </em><strong>struct</strong> Unaryop : public Node <font color="red"><strong>{</strong></font>
<em>243: </em>  Unaryop(Node *expr) : _expr(expr) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>244: </em>  Node *expr() const <font color="red"><strong>{</strong></font> <strong>return</strong> _expr; <font color="red"><strong>}</strong></font>;
<em>245: </em>
<em>246: </em>  virtual void gensymtab(SymTab *);
<em>247: </em>  virtual void typecheck(Node *);
<em>248: </em>protected:
<em>249: </em>  virtual void printdata(std::ostream &amp;) const;  
<em>250: </em>
<em>251: </em>  Node *_expr;
<em>252: </em><font color="red"><strong>}</strong></font>;
<em>253: </em>
<em>254: </em><font color="#ffa600"><em>// A negative unary operator, e.g. -5.</em></font>
<em>255: </em><strong>struct</strong> Negative : public Unaryop <font color="red"><strong>{</strong></font>
<em>256: </em>  Negative(Node *expr) : Unaryop(expr) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>257: </em>  Calc calculate() const;
<em>258: </em>  virtual void typecheck(Node *curr_func);
<em>259: </em>  virtual void codegen(CodeGen &amp;);
<em>260: </em><font color="red"><strong>}</strong></font>;
<em>261: </em>
<em>262: </em><font color="#ffa600"><em>// A pointer dereference, e.g. *a.</em></font>
<em>263: </em><strong>struct</strong> Pointer : public Unaryop <font color="red"><strong>{</strong></font>
<em>264: </em>  Pointer(Node *expr) : Unaryop(expr) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>265: </em>  virtual void typecheck(Node *curr_func);
<em>266: </em>  virtual void codegen(CodeGen &amp;);
<em>267: </em><font color="red"><strong>}</strong></font>;
<em>268: </em>
<em>269: </em><font color="#ffa600"><em>// An address-of operator, e.g. &amp;a.</em></font>
<em>270: </em><strong>struct</strong> AddrOf : public Unaryop <font color="red"><strong>{</strong></font>
<em>271: </em>  AddrOf(Node *expr) : Unaryop(expr) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>272: </em>  virtual void typecheck(Node *curr_func);
<em>273: </em>  virtual void codegen(CodeGen &amp;);
<em>274: </em><font color="red"><strong>}</strong></font>;
<em>275: </em>
<em>276: </em><font color="#ffa600"><em>// Any binary operator, such as that for arithmetic</em></font>
<em>277: </em><font color="#ffa600"><em>// operations (+, -, *), assignment operations, etc.</em></font>
<em>278: </em><font color="#ffa600"><em>// The operator type is the token id used by the parser.</em></font>
<em>279: </em><strong>struct</strong> Binop : public Node <font color="red"><strong>{</strong></font>
<em>280: </em>  Binop(Node *l,int op,Node *r) : _left(l), _right(r), _op(op) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>281: </em>  Calc calculate() const;
<em>282: </em>
<em>283: </em>  Node *left() const <font color="red"><strong>{</strong></font> <strong>return</strong> _left; <font color="red"><strong>}</strong></font>;
<em>284: </em>  Node *right() const <font color="red"><strong>{</strong></font> <strong>return</strong> _right; <font color="red"><strong>}</strong></font>;
<em>285: </em>  int op() const <font color="red"><strong>{</strong></font> <strong>return</strong> _op; <font color="red"><strong>}</strong></font>;
<em>286: </em>
<em>287: </em>  const char *op_str() const;
<em>288: </em>
<em>289: </em>  bool is_assign_op() const;
<em>290: </em>  bool is_compare_op() const;
<em>291: </em>
<em>292: </em>  virtual void gensymtab(SymTab *);
<em>293: </em>  virtual void typecheck(Node *);
<em>294: </em>  virtual void codegen(CodeGen &amp;);
<em>295: </em>protected:
<em>296: </em>  virtual void printdata(std::ostream &amp;) const;
<em>297: </em>private:
<em>298: </em>  Node *_left;
<em>299: </em>  Node *_right;
<em>300: </em>  int   _op;
<em>301: </em><font color="red"><strong>}</strong></font>;
<em>302: </em>
<em>303: </em><font color="#ffa600"><em>// If-then-else statement.</em></font>
<em>304: </em><strong>struct</strong> IfStatement : public Node <font color="red"><strong>{</strong></font>
<em>305: </em>  IfStatement(Node *e,Node *t,Node *el = 0) :
<em>306: </em>    _expr(e), _then(t), _else(el) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>307: </em>
<em>308: </em>  virtual void gensymtab(SymTab *);
<em>309: </em>  virtual void typecheck(Node *);
<em>310: </em>  virtual void flowcontrol(Node *,bool);
<em>311: </em>  virtual void codegen(CodeGen &amp;);
<em>312: </em>
<em>313: </em>  Node *expr() const <font color="red"><strong>{</strong></font> <strong>return</strong> _expr; <font color="red"><strong>}</strong></font>;
<em>314: </em>  Node *then_blk() const <font color="red"><strong>{</strong></font> <strong>return</strong> _then; <font color="red"><strong>}</strong></font>;
<em>315: </em>  Node *else_blk() const <font color="red"><strong>{</strong></font> <strong>return</strong> _else; <font color="red"><strong>}</strong></font>;
<em>316: </em>protected:
<em>317: </em>  virtual void printdata(std::ostream &amp;) const;
<em>318: </em>private:
<em>319: </em>  Node *_expr;
<em>320: </em>  Node *_then;
<em>321: </em>  Node *_else;
<em>322: </em><font color="red"><strong>}</strong></font>;
<em>323: </em>
<em>324: </em><font color="#ffa600"><em>// A break statement.</em></font>
<em>325: </em><strong>struct</strong> BreakStatement : public Node <font color="red"><strong>{</strong></font>
<em>326: </em>  virtual void flowcontrol(Node *,bool);
<em>327: </em>  virtual void codegen(CodeGen &amp;);
<em>328: </em><font color="red"><strong>}</strong></font>;
<em>329: </em>
<em>330: </em><font color="#ffa600"><em>// A continue statement.</em></font>
<em>331: </em><strong>struct</strong> ContinueStatement : public Node <font color="red"><strong>{</strong></font>
<em>332: </em>  virtual void flowcontrol(Node *,bool);
<em>333: </em>  virtual void codegen(CodeGen &amp;);
<em>334: </em><font color="red"><strong>}</strong></font>;
<em>335: </em>
<em>336: </em><font color="#ffa600"><em>// A return statement.</em></font>
<em>337: </em><strong>struct</strong> ReturnStatement : public Node <font color="red"><strong>{</strong></font>
<em>338: </em>  ReturnStatement(Node *expr = 0) : _expr(expr) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>339: </em>
<em>340: </em>  Node *expr() const <font color="red"><strong>{</strong></font> <strong>return</strong> _expr; <font color="red"><strong>}</strong></font>;
<em>341: </em>
<em>342: </em>  virtual void gensymtab(SymTab *);
<em>343: </em>  virtual void typecheck(Node *);
<em>344: </em>  virtual void flowcontrol(Node *,bool);
<em>345: </em>  virtual void codegen(CodeGen &amp;);
<em>346: </em>protected:
<em>347: </em>  virtual void printdata(std::ostream &amp;) const;
<em>348: </em>private:
<em>349: </em>  Node *_expr;
<em>350: </em><font color="red"><strong>}</strong></font>;
<em>351: </em>
<em>352: </em><font color="#ffa600"><em>// A for-loop.</em></font>
<em>353: </em><strong>struct</strong> ForLoop : public Node <font color="red"><strong>{</strong></font>
<em>354: </em>  ForLoop(Node *b,Node *expr,Node *e,Node *s) :
<em>355: </em>    _begin(b), _expr(expr), _end(e), _stmt(s) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>356: </em>
<em>357: </em>  Node *begin() const <font color="red"><strong>{</strong></font> <strong>return</strong> _begin; <font color="red"><strong>}</strong></font>;
<em>358: </em>  Node *expr() const <font color="red"><strong>{</strong></font> <strong>return</strong> _expr; <font color="red"><strong>}</strong></font>;
<em>359: </em>  Node *end() const <font color="red"><strong>{</strong></font> <strong>return</strong> _end; <font color="red"><strong>}</strong></font>;
<em>360: </em>  Node *stmt() const <font color="red"><strong>{</strong></font> <strong>return</strong> _stmt; <font color="red"><strong>}</strong></font>;
<em>361: </em>
<em>362: </em>  virtual void gensymtab(SymTab *);
<em>363: </em>  void typecheck(Node *);
<em>364: </em>  virtual void flowcontrol(Node *,bool);
<em>365: </em>  virtual void codegen(CodeGen &amp;);
<em>366: </em>protected:
<em>367: </em>  virtual void printdata(std::ostream &amp;) const;
<em>368: </em>private:
<em>369: </em>  Node *_begin;
<em>370: </em>  Node *_expr;
<em>371: </em>  Node *_end;
<em>372: </em>  Node *_stmt;
<em>373: </em><font color="red"><strong>}</strong></font>;
<em>374: </em>
<em>375: </em><font color="#ffa600"><em>// A while loop.</em></font>
<em>376: </em><strong>struct</strong> WhileLoop : public Node <font color="red"><strong>{</strong></font>
<em>377: </em>  WhileLoop(Node *expr,Node *stmt) :
<em>378: </em>    _expr(expr), _stmt(stmt) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>379: </em>
<em>380: </em>  Node *expr() const <font color="red"><strong>{</strong></font> <strong>return</strong> _expr; <font color="red"><strong>}</strong></font>;
<em>381: </em>  Node *stmt() const <font color="red"><strong>{</strong></font> <strong>return</strong> _stmt; <font color="red"><strong>}</strong></font>;
<em>382: </em>
<em>383: </em>  virtual void gensymtab(SymTab *);
<em>384: </em>  virtual void typecheck(Node *);
<em>385: </em>  virtual void flowcontrol(Node *,bool);
<em>386: </em>  virtual void codegen(CodeGen &amp;);
<em>387: </em>protected:
<em>388: </em>  virtual void printdata(std::ostream &amp;) const;
<em>389: </em>private:
<em>390: </em>  Node *_expr;
<em>391: </em>  Node *_stmt;
<em>392: </em><font color="red"><strong>}</strong></font>;
<em>393: </em>
<em>394: </em><font color="#ffa600"><em>// A list of nodes (base class).</em></font>
<em>395: </em><strong>struct</strong> NodeList : public Node, public std::vector&lt;Node *,traceable_allocator&lt;Node *&gt; &gt; <font color="red"><strong>{</strong></font>
<em>396: </em>  NodeList() <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>397: </em>  NodeList (Node *n) <font color="red"><strong>{</strong></font> push_back(n); <font color="red"><strong>}</strong></font>;
<em>398: </em>  virtual void add(Node *n) <font color="red"><strong>{</strong></font> push_back(n); <font color="red"><strong>}</strong></font>;
<em>399: </em>
<em>400: </em>  virtual void gensymtab(SymTab *);
<em>401: </em>  virtual void typecheck(Node *);
<em>402: </em>  virtual void codegen(CodeGen &amp;);
<em>403: </em>  virtual void writecode(std::ostream &amp;) const;
<em>404: </em>protected:
<em>405: </em>  virtual void printdata(std::ostream &amp;) const;
<em>406: </em><font color="red"><strong>}</strong></font>;
<em>407: </em>
<em>408: </em><font color="#ffa600"><em>// A list of arguments for a function expression., e.g.</em></font>
<em>409: </em><font color="#ffa600"><em>// &quot;5,2,3&quot; in &quot;a = my_func(5,2,3)&quot;</em></font>
<em>410: </em><strong>struct</strong> ArgumentList : public NodeList <font color="red"><strong>{</strong></font>
<em>411: </em>  ArgumentList() <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>412: </em>  ArgumentList(Node *n) : NodeList(n) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>413: </em><font color="red"><strong>}</strong></font>;
<em>414: </em>
<em>415: </em><font color="#ffa600"><em>// A list of parameters for a function prototype, e.g. </em></font>
<em>416: </em><font color="#ffa600"><em>// &quot;int a, char b, char c&quot; in int my_func(int a,char b,char c).</em></font>
<em>417: </em><strong>struct</strong> ParamList : public NodeList <font color="red"><strong>{</strong></font>
<em>418: </em>  ParamList() <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>419: </em>  ParamList(Node *n) : NodeList(n) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>420: </em>  bool has_ellipsis() const <font color="red"><strong>{</strong></font> <strong>return</strong> _hasellipsis; <font color="red"><strong>}</strong></font>;
<em>421: </em>  void set_has_ellipsis() <font color="red"><strong>{</strong></font> _hasellipsis = true; <font color="red"><strong>}</strong></font>;
<em>422: </em>private:
<em>423: </em>  bool _hasellipsis;
<em>424: </em><font color="red"><strong>}</strong></font>;
<em>425: </em>
<em>426: </em><font color="#ffa600"><em>// A list of statements, such as for a function body or</em></font>
<em>427: </em><font color="#ffa600"><em>// loop body.</em></font>
<em>428: </em><strong>struct</strong> StatementList : public NodeList <font color="red"><strong>{</strong></font>
<em>429: </em>  StatementList() <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>430: </em>  StatementList(Node *n) : NodeList(n) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>431: </em>
<em>432: </em>  virtual void flowcontrol(Node *,bool);
<em>433: </em>  virtual void codegen(CodeGen &amp;);
<em>434: </em><font color="red"><strong>}</strong></font>;
<em>435: </em>
<em>436: </em><font color="#ffa600"><em>// Inherit from this if you have a symbol table.</em></font>
<em>437: </em><strong>struct</strong> SymNode <font color="red"><strong>{</strong></font>
<em>438: </em>  SymNode() : _symtab(0) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>439: </em>  SymTab *getsymtab() const <font color="red"><strong>{</strong></font> <strong>return</strong> _symtab; <font color="red"><strong>}</strong></font>;
<em>440: </em>  void printsyms(std::ostream &amp;o) const;
<em>441: </em>protected:
<em>442: </em>  SymTab *_symtab;
<em>443: </em><font color="red"><strong>}</strong></font>;
<em>444: </em>
<em>445: </em><font color="#ffa600"><em>// This represents a single C file.</em></font>
<em>446: </em><strong>struct</strong> TranslationUnit : public NodeList, public SymNode <font color="red"><strong>{</strong></font>
<em>447: </em>  TranslationUnit() <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>448: </em>  TranslationUnit(Node *n) : NodeList(n) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>449: </em>
<em>450: </em>  virtual SymTab *symtab() const <font color="red"><strong>{</strong></font> <strong>return</strong> getsymtab(); <font color="red"><strong>}</strong></font>;
<em>451: </em>
<em>452: </em>  virtual void gensymtab(SymTab *);
<em>453: </em>  virtual bool dochecks(CodeGen &amp;cg);
<em>454: </em>  virtual void codegen(CodeGen &amp;cg);
<em>455: </em>protected:
<em>456: </em>  virtual void printdata(std::ostream &amp;) const;
<em>457: </em><font color="red"><strong>}</strong></font>;
<em>458: </em>
<em>459: </em><font color="#ffa600"><em>// A list of variable declarations, such as the ones</em></font>
<em>460: </em><font color="#ffa600"><em>// put at the beginning of a block.</em></font>
<em>461: </em><strong>struct</strong> DeclarationList : public NodeList <font color="red"><strong>{</strong></font>
<em>462: </em>  DeclarationList() <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>463: </em>  DeclarationList(Node *n) : NodeList(n) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>464: </em><font color="red"><strong>}</strong></font>;
<em>465: </em>
<em>466: </em><font color="#ffa600"><em>// A function call.</em></font>
<em>467: </em><strong>struct</strong> FunctionExpression : public Node <font color="red"><strong>{</strong></font>
<em>468: </em>  FunctionExpression(Node *f,Node *a) :
<em>469: </em>    _function(f), _arglist(a) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>470: </em>
<em>471: </em>  Node *function() const <font color="red"><strong>{</strong></font> <strong>return</strong> _function; <font color="red"><strong>}</strong></font>;
<em>472: </em>  Node *arglist() const <font color="red"><strong>{</strong></font> <strong>return</strong> _arglist; <font color="red"><strong>}</strong></font>;
<em>473: </em>  NodeList &amp;get_arglist() const;
<em>474: </em>
<em>475: </em>  virtual void gensymtab(SymTab *);
<em>476: </em>  virtual void typecheck(Node *);
<em>477: </em>  virtual void codegen(CodeGen &amp;);
<em>478: </em>protected:
<em>479: </em>  virtual void printdata(std::ostream &amp;) const;
<em>480: </em>private:
<em>481: </em>  Node *_function;
<em>482: </em>  Node *_arglist;
<em>483: </em><font color="red"><strong>}</strong></font>;
<em>484: </em>
<em>485: </em><font color="#ffa600"><em>// A compound statement, e.g. &quot;{ int i; i += 1; }&quot;.</em></font>
<em>486: </em><strong>struct</strong> CompoundStatement : public Node, public SymNode <font color="red"><strong>{</strong></font>
<em>487: </em>  CompoundStatement(Node *d,Node *s) :
<em>488: </em>    _declaration_list(d), _statement_list(s) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>489: </em>
<em>490: </em>  virtual SymTab *symtab() const <font color="red"><strong>{</strong></font> <strong>return</strong> getsymtab(); <font color="red"><strong>}</strong></font>;
<em>491: </em>
<em>492: </em>  Node *declaration_list() const <font color="red"><strong>{</strong></font> <strong>return</strong> _declaration_list; <font color="red"><strong>}</strong></font>;
<em>493: </em>  Node *statement_list() const <font color="red"><strong>{</strong></font> <strong>return</strong> _statement_list; <font color="red"><strong>}</strong></font>;
<em>494: </em>
<em>495: </em>  virtual void gensymtab(SymTab *);
<em>496: </em>  virtual void typecheck(Node *);
<em>497: </em>  virtual void flowcontrol(Node *,bool);
<em>498: </em>  virtual void codegen(CodeGen &amp;);
<em>499: </em>protected:
<em>500: </em>  virtual void printdata(std::ostream &amp;) const;
<em>501: </em>private:
<em>502: </em>  Node *_declaration_list;
<em>503: </em>  Node *_statement_list;
<em>504: </em><font color="red"><strong>}</strong></font>;
<em>505: </em>
<em>506: </em><font color="#ffa600"><em>// A function definition (declaration and body).</em></font>
<em>507: </em><strong>struct</strong> FunctionDefn : public Node, public SymNode <font color="red"><strong>{</strong></font>
<em>508: </em>  FunctionDefn(Node *decl,Node *body);
<em>509: </em>
<em>510: </em>  virtual String name() const <font color="red"><strong>{</strong></font> <strong>return</strong> _name; <font color="red"><strong>}</strong></font>;
<em>511: </em>  Node *body() const <font color="red"><strong>{</strong></font> <strong>return</strong> _body; <font color="red"><strong>}</strong></font>;
<em>512: </em>  void setcode(AsmStore *c) <font color="red"><strong>{</strong></font> _code = c; <font color="red"><strong>}</strong></font>;
<em>513: </em>
<em>514: </em>  virtual SymTab *symtab() const <font color="red"><strong>{</strong></font> <strong>return</strong> getsymtab(); <font color="red"><strong>}</strong></font>;
<em>515: </em>
<em>516: </em>  virtual bool is_extern() const <font color="red"><strong>{</strong></font> <strong>return</strong> _extern; <font color="red"><strong>}</strong></font>;
<em>517: </em>  virtual bool is_static() const <font color="red"><strong>{</strong></font> <strong>return</strong> _static; <font color="red"><strong>}</strong></font>;
<em>518: </em>
<em>519: </em>  virtual void gensymtab(SymTab *);
<em>520: </em>  virtual void typecheck(Node *);
<em>521: </em>  virtual void flowcontrol(Node *,bool);
<em>522: </em>  virtual void codegen(CodeGen &amp;);
<em>523: </em>  virtual void writecode(std::ostream &amp;) const;
<em>524: </em>protected:
<em>525: </em>  virtual void printdata(std::ostream &amp;) const;
<em>526: </em>private:
<em>527: </em>  String    _name;
<em>528: </em>  Node     *_body;
<em>529: </em>  AsmStore *_code;
<em>530: </em>  bool      _extern;
<em>531: </em>  bool      _static;
<em>532: </em><font color="red"><strong>}</strong></font>;
<em>533: </em>
<em>534: </em><font color="#ffa600"><em>// A node representing a declaration of a function or</em></font>
<em>535: </em><font color="#ffa600"><em>// variable.</em></font>
<em>536: </em><strong>struct</strong> Declaration : public Node <font color="red"><strong>{</strong></font>
<em>537: </em>  Declaration (String n,Type *t = 0);
<em>538: </em>
<em>539: </em>  virtual String name() const <font color="red"><strong>{</strong></font> <strong>return</strong> _name; <font color="red"><strong>}</strong></font>;
<em>540: </em>
<em>541: </em>  virtual bool is_used() const <font color="red"><strong>{</strong></font> <strong>return</strong> _is_used; <font color="red"><strong>}</strong></font>;
<em>542: </em>  virtual void set_used() <font color="red"><strong>{</strong></font> _is_used = true; <font color="red"><strong>}</strong></font>;
<em>543: </em>
<em>544: </em>  void set_base_type(Type *t);
<em>545: </em>  void add_type(Type *t);
<em>546: </em>
<em>547: </em>  virtual bool is_extern() const <font color="red"><strong>{</strong></font> <strong>return</strong> _extern; <font color="red"><strong>}</strong></font>;
<em>548: </em>  virtual bool is_static() const <font color="red"><strong>{</strong></font> <strong>return</strong> _static; <font color="red"><strong>}</strong></font>;
<em>549: </em>
<em>550: </em>  void set_extern() <font color="red"><strong>{</strong></font> _extern = true; <font color="red"><strong>}</strong></font>;
<em>551: </em>  void set_static() <font color="red"><strong>{</strong></font> _static = true; <font color="red"><strong>}</strong></font>;
<em>552: </em>
<em>553: </em>  virtual void gensymtab(SymTab *);
<em>554: </em>protected:
<em>555: </em>  virtual void printdata(std::ostream &amp;) const;
<em>556: </em>private:
<em>557: </em>  String  _name;
<em>558: </em>  bool    _extern;
<em>559: </em>  bool    _static;
<em>560: </em>  bool    _is_used;
<em>561: </em><font color="red"><strong>}</strong></font>;
<em>562: </em>
<em>563: </em><font color="#ffa600"><em>//</em></font>
<em>564: </em><font color="#ffa600"><em>// Type nodes. </em></font>
<em>565: </em><font color="#ffa600"><em>//</em></font>
<em>566: </em>
<em>567: </em><font color="#ffa600"><em>// This represents the type of another node, e.g. the</em></font>
<em>568: </em><font color="#ffa600"><em>// type of 5+a, where a is an int, will be a Type node</em></font>
<em>569: </em><font color="#ffa600"><em>// storing int.</em></font>
<em>570: </em><font color="#ffa600"><em>// Types may be nested (chained together).</em></font>
<em>571: </em><strong>struct</strong> Type : public gc <font color="red"><strong>{</strong></font>
<em>572: </em>  Type();
<em>573: </em>  Type(Type *t) : _child(t) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>574: </em>  Type *child() const <font color="red"><strong>{</strong></font> <strong>return</strong> _child; <font color="red"><strong>}</strong></font>;
<em>575: </em>
<em>576: </em>  <font color="#ffa600"><em>// Set the base (innermost) type ofa type.  For instance,</em></font>
<em>577: </em>  <font color="#ffa600"><em>// calling this with a pointer(int) type on a pointer() type</em></font>
<em>578: </em>  <font color="#ffa600"><em>// will give you a pointer(pointer(int)).</em></font>
<em>579: </em>  void set_base_type(Type *t);
<em>580: </em>  <font color="#ffa600"><em>// Returns the return type, if applicable (i.e. it's a function).</em></font>
<em>581: </em>  virtual Type *get_return_type() const <font color="red"><strong>{</strong></font> <strong>return</strong> 0; <font color="red"><strong>}</strong></font>;
<em>582: </em>  <font color="#ffa600"><em>// Returns true if this represents a function.</em></font>
<em>583: </em>  virtual bool is_function() const <font color="red"><strong>{</strong></font> <strong>return</strong> false; <font color="red"><strong>}</strong></font>;
<em>584: </em>  <font color="#ffa600"><em>// Returns size of type in bytes.</em></font>
<em>585: </em>  virtual unsigned size() const;
<em>586: </em>  <font color="#ffa600"><em>// Prints a string representation.</em></font>
<em>587: </em>  virtual std::ostream &amp;print(std::ostream &amp;o) const = 0;
<em>588: </em>  <font color="#ffa600"><em>// Prints only the outer most type.</em></font>
<em>589: </em>  virtual std::ostream &amp;print_outer(std::ostream &amp;o) const = 0;
<em>590: </em>
<em>591: </em>  <font color="#ffa600"><em>// Traversal function for generating symbol tables.</em></font>
<em>592: </em>  virtual void gensymtab(SymTab *);
<em>593: </em>
<em>594: </em>protected:
<em>595: </em>
<em>596: </em>  Type *_child;
<em>597: </em><font color="red"><strong>}</strong></font>;
<em>598: </em>
<em>599: </em><font color="#ffa600"><em>// Use this to print the Type pointer, as it supports nulls.</em></font>
<em>600: </em>std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const Type *);
<em>601: </em>
<em>602: </em><font color="#ffa600"><em>// Represents intrinsic types, e.g. int, char.</em></font>
<em>603: </em><font color="#ffa600"><em>// Note:  The None type doesn't represent a type but is used to</em></font>
<em>604: </em><font color="#ffa600"><em>// note that something is not a base type.</em></font>
<em>605: </em><strong>struct</strong> BaseType : public Type <font color="red"><strong>{</strong></font>
<em>606: </em>  enum BT <font color="red"><strong>{</strong></font> None, Int, Char, Double <font color="red"><strong>}</strong></font>;
<em>607: </em>  BaseType(BT t) : _type(t) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>608: </em>  BT type() const <font color="red"><strong>{</strong></font> <strong>return</strong> _type; <font color="red"><strong>}</strong></font>;
<em>609: </em>  virtual unsigned size() const;
<em>610: </em>  virtual std::ostream &amp;print(std::ostream &amp;o) const;
<em>611: </em>  virtual std::ostream &amp;print_outer(std::ostream &amp;o) const;
<em>612: </em>private:
<em>613: </em>  BT _type;
<em>614: </em><font color="red"><strong>}</strong></font>;
<em>615: </em>
<em>616: </em><font color="#ffa600"><em>// A type representing a function (for prototypes and calls).</em></font>
<em>617: </em><strong>struct</strong> FunctionType : public Type <font color="red"><strong>{</strong></font>
<em>618: </em>  FunctionType(Node *p,Type *c = 0) : Type(c), _params(p) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>619: </em>  Node *get_params() const <font color="red"><strong>{</strong></font> <strong>return</strong> _params; <font color="red"><strong>}</strong></font>;
<em>620: </em>  bool is_function() const <font color="red"><strong>{</strong></font> <strong>return</strong> true; <font color="red"><strong>}</strong></font>;
<em>621: </em>  Type *get_return_type() const <font color="red"><strong>{</strong></font> <strong>return</strong> _child; <font color="red"><strong>}</strong></font>;
<em>622: </em>
<em>623: </em>  virtual std::ostream &amp;print(std::ostream &amp;o) const;
<em>624: </em>  virtual std::ostream &amp;print_outer(std::ostream &amp;o) const;
<em>625: </em>
<em>626: </em>  virtual void gensymtab(SymTab *);
<em>627: </em>private:
<em>628: </em>  Node *_params;
<em>629: </em><font color="red"><strong>}</strong></font>;
<em>630: </em>
<em>631: </em><strong>struct</strong> PointerType : public Type <font color="red"><strong>{</strong></font>
<em>632: </em>  PointerType() <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>633: </em>  PointerType(Type *t) : Type(t) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>634: </em>  virtual unsigned size() const;
<em>635: </em>
<em>636: </em>  virtual std::ostream &amp;print(std::ostream &amp;o) const;
<em>637: </em>  virtual std::ostream &amp;print_outer(std::ostream &amp;o) const;
<em>638: </em><font color="red"><strong>}</strong></font>;
<em>639: </em>
<em>640: </em><font color="#ffa600"><em>// Functions for querying types.</em></font>
<em>641: </em>
<em>642: </em>BaseType::BT intType(Type *t);
<em>643: </em>bool isIntType(Type *t);
<em>644: </em>bool isIntType(Node *n);
<em>645: </em>bool isPtrType(Type *t);
<em>646: </em>bool isPtrType(Node *n);
<em>647: </em>
<em>648: </em><font color="#1919af"><strong>#endif</strong></font>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
<!-- cc/Node.C -->
<a name="cc/Node.C"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">5.5.2 cc/Node.C</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em>   1: </em><font color="#ffa600"><em>//</em></font>
<em>   2: </em><font color="#ffa600"><em>// Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.</em></font>
<em>   3: </em><font color="#ffa600"><em>//</em></font>
<em>   4: </em><font color="#ffa600"><em>// You may distribute under the terms of the Artistic License, as specified in</em></font>
<em>   5: </em><font color="#ffa600"><em>// the COPYING file.</em></font>
<em>   6: </em><font color="#ffa600"><em>//</em></font>
<em>   7: </em><font color="#ffa600"><em>//</em></font>
<em>   8: </em><font color="#ffa600"><em>// AST nodes used by the compiler.</em></font>
<em>   9: </em><font color="#ffa600"><em>// These are garbage collected when allocated</em></font>
<em>  10: </em><font color="#ffa600"><em>// from the heap.  However, they do not register</em></font>
<em>  11: </em><font color="#ffa600"><em>// a finalizer, so thir destructors will not be called.</em></font>
<em>  12: </em><font color="#ffa600"><em>//</em></font>
<em>  13: </em>
<em>  14: </em><font color="#1919af"><strong>#include</strong></font> &lt;sstream&gt;
<em>  15: </em><font color="#1919af"><strong>#include</strong></font> &lt;stdexcept&gt;
<em>  16: </em><font color="#1919af"><strong>#include</strong></font> &lt;assert.h&gt;
<em>  17: </em><font color="#1919af"><strong>#include</strong></font> &lt;iostream&gt;
<em>  18: </em>
<em>  19: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;Types.h&quot;</font>
<em>  20: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;Node.h&quot;</font>
<em>  21: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;SymTab.h&quot;</font>
<em>  22: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;CodeGen.h&quot;</font>
<em>  23: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;AsmStore.h&quot;</font>
<em>  24: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;cparse.h&quot;</font>
<em>  25: </em>
<em>  26: </em>using namespace std;
<em>  27: </em>
<em>  28: </em><strong>template</strong> &lt;<strong>class</strong> T&gt;
<em>  29: </em>T *ncast(Node *n)
<em>  30: </em><font color="red"><strong>{</strong></font>
<em>  31: </em>  <strong>return</strong> dynamic_cast&lt;T *&gt;(n);
<em>  32: </em><font color="red"><strong>}</strong></font>
<em>  33: </em>
<em>  34: </em><strong>template</strong> &lt;<strong>class</strong> T&gt;
<em>  35: </em>T &amp;ncastr(Node *n)
<em>  36: </em><font color="red"><strong>{</strong></font>
<em>  37: </em>  <strong>return</strong> dynamic_cast&lt;T &amp;&gt;(*n);
<em>  38: </em><font color="red"><strong>}</strong></font>
<em>  39: </em>
<em>  40: </em><strong>template</strong> &lt;<strong>class</strong> T&gt;
<em>  41: </em>T *tcast(Type *t)
<em>  42: </em><font color="red"><strong>{</strong></font>
<em>  43: </em>  <strong>return</strong> dynamic_cast&lt;T *&gt;(t);
<em>  44: </em><font color="red"><strong>}</strong></font>
<em>  45: </em>
<em>  46: </em><strong>template</strong> &lt;<strong>class</strong> T&gt;
<em>  47: </em>T &amp;tcastr(Type *t)
<em>  48: </em><font color="red"><strong>{</strong></font>
<em>  49: </em>  <strong>return</strong> dynamic_cast&lt;T &amp;&gt;(*t);
<em>  50: </em><font color="red"><strong>}</strong></font>
<em>  51: </em>
<em>  52: </em><font color="#ffa600"><em>// Per-indent amount of whitespace.</em></font>
<em>  53: </em><strong>static</strong> const int Incr = 2;
<em>  54: </em>
<em>  55: </em><strong>static</strong> int IndentIndex = ostream::xalloc();
<em>  56: </em><strong>static</strong> int PrintSyms = ostream::xalloc();
<em>  57: </em>
<em>  58: </em>int curindent(ostream &amp;o)
<em>  59: </em><font color="red"><strong>{</strong></font>
<em>  60: </em>  <strong>return</strong> o.iword(IndentIndex);
<em>  61: </em><font color="red"><strong>}</strong></font>
<em>  62: </em>
<em>  63: </em><font color="#ffa600"><em>// Indentation manipulator- supply correct indentation.</em></font>
<em>  64: </em>ostream &amp;indent(ostream &amp;o)
<em>  65: </em><font color="red"><strong>{</strong></font>
<em>  66: </em>  o &lt;&lt; '\n';
<em>  67: </em>  <strong>for</strong> (int i = 0; i &lt; o.iword(IndentIndex); ++i) <font color="red"><strong>{</strong></font>
<em>  68: </em>    o &lt;&lt; ' ';
<em>  69: </em>  <font color="red"><strong>}</strong></font>
<em>  70: </em>  <strong>return</strong> o;
<em>  71: </em><font color="red"><strong>}</strong></font>
<em>  72: </em>
<em>  73: </em><font color="#ffa600"><em>// Modify indentation.</em></font>
<em>  74: </em>ostream &amp;incrindent(ostream &amp;o)
<em>  75: </em><font color="red"><strong>{</strong></font>
<em>  76: </em>  o.iword(IndentIndex) += Incr;
<em>  77: </em>  <strong>return</strong> o;
<em>  78: </em><font color="red"><strong>}</strong></font>
<em>  79: </em>
<em>  80: </em><font color="#ffa600"><em>// Modify indentation.</em></font>
<em>  81: </em>ostream &amp;decrindent(ostream &amp;o)
<em>  82: </em><font color="red"><strong>{</strong></font>
<em>  83: </em>  o.iword(IndentIndex) -= Incr;
<em>  84: </em>  <strong>return</strong> o;
<em>  85: </em><font color="red"><strong>}</strong></font>
<em>  86: </em>
<em>  87: </em><font color="#ffa600"><em>// Indicate that symbols should be printed.</em></font>
<em>  88: </em>ostream &amp;printsyms(ostream &amp;o)
<em>  89: </em><font color="red"><strong>{</strong></font>
<em>  90: </em>  o.iword(PrintSyms) = true;
<em>  91: </em>  <strong>return</strong> o;
<em>  92: </em><font color="red"><strong>}</strong></font>
<em>  93: </em>
<em>  94: </em><font color="#ffa600"><em>// Turn off symbol printing.</em></font>
<em>  95: </em>ostream &amp;noprintsyms(ostream &amp;o)
<em>  96: </em><font color="red"><strong>{</strong></font>
<em>  97: </em>  o.iword(PrintSyms) = false;
<em>  98: </em>  <strong>return</strong> o;
<em>  99: </em><font color="red"><strong>}</strong></font>
<em> 100: </em>
<em> 101: </em>bool do_printsyms(ostream &amp;o)
<em> 102: </em><font color="red"><strong>{</strong></font>
<em> 103: </em>  <strong>return</strong> o.iword(PrintSyms);
<em> 104: </em><font color="red"><strong>}</strong></font>
<em> 105: </em>
<em> 106: </em><font color="#ffa600"><em>// If the given type is a constant, coerce it to the</em></font>
<em> 107: </em><font color="#ffa600"><em>// given type.</em></font>
<em> 108: </em>void coerce_const(Node *n,Type *t)
<em> 109: </em><font color="red"><strong>{</strong></font>
<em> 110: </em>  <strong>if</strong> (n-&gt;is_const() &amp;&amp; isIntType(t)) <font color="red"><strong>{</strong></font>
<em> 111: </em>    n-&gt;set_type(t);
<em> 112: </em>  <font color="red"><strong>}</strong></font>
<em> 113: </em><font color="red"><strong>}</strong></font>
<em> 114: </em>
<em> 115: </em><font color="#ffa600"><em>// Given two typed terminals, sees if one is a constant.</em></font>
<em> 116: </em><font color="#ffa600"><em>// If it is, tries to coerce it to the type of the other.</em></font>
<em> 117: </em>void coerce_consts(Node *n1,Node *n2)
<em> 118: </em><font color="red"><strong>{</strong></font>
<em> 119: </em>  <strong>if</strong> (n1-&gt;is_const()) <font color="red"><strong>{</strong></font>
<em> 120: </em>    coerce_const(n1,n2-&gt;type());
<em> 121: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <strong>if</strong> (n2-&gt;is_const()) <font color="red"><strong>{</strong></font>
<em> 122: </em>    coerce_const(n2,n1-&gt;type());
<em> 123: </em>  <font color="red"><strong>}</strong></font>
<em> 124: </em><font color="red"><strong>}</strong></font>
<em> 125: </em>
<em> 126: </em><font color="#ffa600"><em>// Checks the given integeral constant to make sure it is</em></font>
<em> 127: </em><font color="#ffa600"><em>// within the bounds of the given type.</em></font>
<em> 128: </em>bool check_const_range(Node *n,Type *t)
<em> 129: </em><font color="red"><strong>{</strong></font>
<em> 130: </em>  <strong>if</strong> (Const *c = ncast&lt;Const&gt;(n)) <font color="red"><strong>{</strong></font>
<em> 131: </em>    int value = c-&gt;value();
<em> 132: </em>    <strong>switch</strong> (intType(t)) <font color="red"><strong>{</strong></font>
<em> 133: </em>    <strong>case</strong> BaseType::Char:
<em> 134: </em>      <strong>return</strong> (value &gt;= -128 &amp;&amp; value &lt;= 127);
<em> 135: </em>    default:
<em> 136: </em>      <strong>break</strong>;
<em> 137: </em>    <font color="red"><strong>}</strong></font>
<em> 138: </em>  <font color="red"><strong>}</strong></font>
<em> 139: </em>  <strong>return</strong> true;
<em> 140: </em><font color="red"><strong>}</strong></font>
<em> 141: </em>
<em> 142: </em><font color="#ffa600"><em>// Compares two types to see if it's possible to perform</em></font>
<em> 143: </em><font color="#ffa600"><em>// a binary operation on them.  If it is not, then the </em></font>
<em> 144: </em><font color="#ffa600"><em>// appopriate error/warnings are raised, unless raise_errors is</em></font>
<em> 145: </em><font color="#ffa600"><em>// false, in which case the return code is:</em></font>
<em> 146: </em><font color="#ffa600"><em>// 0:  Success</em></font>
<em> 147: </em><font color="#ffa600"><em>// 1:  Warning</em></font>
<em> 148: </em><font color="#ffa600"><em>// 2:  Error</em></font>
<em> 149: </em>int compare_types(Node *name,Type *from,Type *to,bool raise = true)
<em> 150: </em><font color="red"><strong>{</strong></font>
<em> 151: </em>  const int Warning = 1, Error = 2;
<em> 152: </em>  int conflict = 0;
<em> 153: </em>  BaseType::BT from_t = intType(from);
<em> 154: </em>  BaseType::BT to_t = intType(to);
<em> 155: </em>  <strong>if</strong> (from_t != to_t) <font color="red"><strong>{</strong></font>
<em> 156: </em>    <strong>if</strong> (from_t == BaseType::Char) <font color="red"><strong>{</strong></font>
<em> 157: </em>      <strong>if</strong> (to_t == BaseType::Int) <font color="red"><strong>{</strong></font>
<em> 158: </em>        conflict = 0;
<em> 159: </em>      <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em> 160: </em>        conflict = Error;
<em> 161: </em>      <font color="red"><strong>}</strong></font>
<em> 162: </em>    <font color="red"><strong>}</strong></font> <strong>else</strong> <strong>if</strong> (from_t == BaseType::Int) <font color="red"><strong>{</strong></font>
<em> 163: </em>      <strong>if</strong> (to_t == BaseType::Char) <font color="red"><strong>{</strong></font>
<em> 164: </em>        conflict = Warning;
<em> 165: </em>      <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em> 166: </em>        conflict = Error;
<em> 167: </em>      <font color="red"><strong>}</strong></font>
<em> 168: </em>    <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em> 169: </em>      conflict = Error;
<em> 170: </em>    <font color="red"><strong>}</strong></font>
<em> 171: </em>  <font color="red"><strong>}</strong></font>
<em> 172: </em>  <strong>if</strong> (!raise) <font color="red"><strong>{</strong></font>
<em> 173: </em>    <strong>return</strong> conflict;
<em> 174: </em>  <font color="red"><strong>}</strong></font>
<em> 175: </em>  <strong>if</strong> (conflict == Warning) <font color="red"><strong>{</strong></font>
<em> 176: </em>    Warn(name,<font color="red">&quot;Conversion from &quot;</font> &lt;&lt; from &lt;&lt; <font color="red">&quot; to &quot;</font> &lt;&lt; to &lt;&lt; <font color="red">&quot; may result in data loss.&quot;</font>);
<em> 177: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <strong>if</strong> (conflict == Error) <font color="red"><strong>{</strong></font>
<em> 178: </em>    Error(name,<font color="red">&quot;Cannot convert from &quot;</font> &lt;&lt; from &lt;&lt; <font color="red">&quot; to &quot;</font> &lt;&lt; to);
<em> 179: </em>  <font color="red"><strong>}</strong></font>
<em> 180: </em>  <strong>return</strong> conflict;
<em> 181: </em><font color="red"><strong>}</strong></font>
<em> 182: </em>
<em> 183: </em>Node::Node(Type *t) : 
<em> 184: </em>  _has_return_stmt(false),
<em> 185: </em>  _has_addr(false), 
<em> 186: </em>  _output_addr(0), 
<em> 187: </em>  _compile_loc(0),
<em> 188: </em>  _type(t), 
<em> 189: </em>  _coerce_to_type(0), 
<em> 190: </em>  _filename(0), 
<em> 191: </em>  _linenumber(0) 
<em> 192: </em><font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em> 193: </em>
<em> 194: </em><font color="#ffa600"><em>// Doesn't do anything, but is sometimes required due to C++ bullshit.</em></font>
<em> 195: </em>Node::~Node()
<em> 196: </em><font color="red"><strong>{</strong></font>
<em> 197: </em><font color="red"><strong>}</strong></font>
<em> 198: </em>
<em> 199: </em>void Node::setFileData(const char *fn,int ln)
<em> 200: </em><font color="red"><strong>{</strong></font>
<em> 201: </em>  _filename = fn;
<em> 202: </em>  _linenumber = ln;
<em> 203: </em><font color="red"><strong>}</strong></font>
<em> 204: </em>
<em> 205: </em>pair&lt;int,bool&gt; Node::calculate() const
<em> 206: </em><font color="red"><strong>{</strong></font> 
<em> 207: </em>  <strong>return</strong> make_pair(0,false); 
<em> 208: </em><font color="red"><strong>}</strong></font>;
<em> 209: </em>
<em> 210: </em>void Node::add(Node *n) 
<em> 211: </em><font color="red"><strong>{</strong></font> 
<em> 212: </em>  assert(0); 
<em> 213: </em><font color="red"><strong>}</strong></font>
<em> 214: </em>
<em> 215: </em>void Node::print(ostream &amp;o) const
<em> 216: </em><font color="red"><strong>{</strong></font>
<em> 217: </em>  o &lt;&lt; incrindent &lt;&lt; indent &lt;&lt; <font color="red">&quot;+ &quot;</font> &lt;&lt; typeid(*this).name() &lt;&lt; incrindent;
<em> 218: </em>  <strong>if</strong> (_type) <font color="red"><strong>{</strong></font>
<em> 219: </em>    o &lt;&lt; indent &lt;&lt; <font color="red">&quot;Type-string:  &quot;</font> &lt;&lt; _type;
<em> 220: </em>  <font color="red"><strong>}</strong></font>
<em> 221: </em>  printdata(o);
<em> 222: </em>  o &lt;&lt; decrindent &lt;&lt; decrindent;
<em> 223: </em><font color="red"><strong>}</strong></font>
<em> 224: </em>
<em> 225: </em>void Node::printdata(std::ostream &amp;) const
<em> 226: </em><font color="red"><strong>{</strong></font>
<em> 227: </em><font color="red"><strong>}</strong></font>
<em> 228: </em>
<em> 229: </em>std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const Node *n)
<em> 230: </em><font color="red"><strong>{</strong></font>
<em> 231: </em>  <strong>if</strong> (n) <font color="red"><strong>{</strong></font>
<em> 232: </em>    n-&gt;print(o);
<em> 233: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em> 234: </em>    o &lt;&lt; incrindent &lt;&lt; indent &lt;&lt; <font color="red">&quot;null&quot;</font> &lt;&lt; decrindent;
<em> 235: </em>  <font color="red"><strong>}</strong></font>
<em> 236: </em>  <strong>return</strong> o;
<em> 237: </em><font color="red"><strong>}</strong></font>
<em> 238: </em>
<em> 239: </em>void Node::gensymtab()
<em> 240: </em><font color="red"><strong>{</strong></font>
<em> 241: </em>  gensymtab(0);
<em> 242: </em><font color="red"><strong>}</strong></font>
<em> 243: </em>
<em> 244: </em>void Node::typecheck()
<em> 245: </em><font color="red"><strong>{</strong></font>
<em> 246: </em>  typecheck(0);
<em> 247: </em><font color="red"><strong>}</strong></font>
<em> 248: </em>
<em> 249: </em>void Node::flowcontrol()
<em> 250: </em><font color="red"><strong>{</strong></font>
<em> 251: </em>  flowcontrol(0,false);
<em> 252: </em><font color="red"><strong>}</strong></font>
<em> 253: </em>
<em> 254: </em>bool Node::dochecks(CodeGen &amp;)
<em> 255: </em><font color="red"><strong>{</strong></font>
<em> 256: </em>  <strong>return</strong> true;
<em> 257: </em><font color="red"><strong>}</strong></font>
<em> 258: </em>
<em> 259: </em>void Node::codegen(CodeGen &amp;)
<em> 260: </em><font color="red"><strong>{</strong></font>
<em> 261: </em><font color="red"><strong>}</strong></font>
<em> 262: </em>
<em> 263: </em>void Node::writecode(ostream &amp;) const
<em> 264: </em><font color="red"><strong>{</strong></font>
<em> 265: </em><font color="red"><strong>}</strong></font>
<em> 266: </em>
<em> 267: </em>void Node::gensymtab(SymTab *)
<em> 268: </em><font color="red"><strong>{</strong></font>
<em> 269: </em><font color="red"><strong>}</strong></font>
<em> 270: </em>
<em> 271: </em>void Node::typecheck(Node *)
<em> 272: </em><font color="red"><strong>{</strong></font>
<em> 273: </em><font color="red"><strong>}</strong></font>
<em> 274: </em>
<em> 275: </em>void Node::flowcontrol(Node *,bool)
<em> 276: </em><font color="red"><strong>{</strong></font>
<em> 277: </em><font color="red"><strong>}</strong></font>
<em> 278: </em>
<em> 279: </em>NullNode::NullNode() : Node(0) 
<em> 280: </em><font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>
<em> 281: </em>
<em> 282: </em>void ArrayExpression::printdata(ostream &amp;o) const
<em> 283: </em><font color="red"><strong>{</strong></font>
<em> 284: </em>  o &lt;&lt; indent &lt;&lt; <font color="red">&quot;Expr : &quot;</font> &lt;&lt; _expr
<em> 285: </em>    &lt;&lt; indent &lt;&lt; <font color="red">&quot;Index: &quot;</font> &lt;&lt; _index;
<em> 286: </em><font color="red"><strong>}</strong></font>
<em> 287: </em>
<em> 288: </em>void ArrayExpression::gensymtab(SymTab *p)
<em> 289: </em><font color="red"><strong>{</strong></font>
<em> 290: </em>  _expr-&gt;gensymtab(p);
<em> 291: </em>  _index-&gt;gensymtab(p);
<em> 292: </em><font color="red"><strong>}</strong></font>
<em> 293: </em>
<em> 294: </em>void ArrayExpression::typecheck(Node *curr_func)
<em> 295: </em><font color="red"><strong>{</strong></font>
<em> 296: </em>  _expr-&gt;typecheck(curr_func);
<em> 297: </em>  _index-&gt;typecheck(curr_func);
<em> 298: </em>  <strong>if</strong> (!isIntType(_index)) <font color="red"><strong>{</strong></font>
<em> 299: </em>    Error(_index,<font color="red">&quot;Array index is not an int or char.&quot;</font>);
<em> 300: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <strong>if</strong> (!isPtrType(_expr)) <font color="red"><strong>{</strong></font>
<em> 301: </em>    Error(_expr,<font color="red">&quot;Array expression is not a pointer.&quot;</font>);
<em> 302: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em> 303: </em>    _type = _expr-&gt;type()-&gt;child();
<em> 304: </em>    set_has_address();
<em> 305: </em>  <font color="red"><strong>}</strong></font>
<em> 306: </em><font color="red"><strong>}</strong></font>
<em> 307: </em>
<em> 308: </em>void ArrayExpression::codegen(CodeGen &amp;cg)
<em> 309: </em><font color="red"><strong>{</strong></font>
<em> 310: </em>  cg.genArrayExpression(this);
<em> 311: </em><font color="red"><strong>}</strong></font>
<em> 312: </em>
<em> 313: </em>StringLiteral::StringLiteral(String s) : 
<em> 314: </em>  Node(new PointerType(new BaseType(BaseType::Char))),
<em> 315: </em>  _s(s)
<em> 316: </em><font color="red"><strong>{</strong></font>
<em> 317: </em><font color="red"><strong>}</strong></font>
<em> 318: </em>
<em> 319: </em>void StringLiteral::append(String s)
<em> 320: </em><font color="red"><strong>{</strong></font>
<em> 321: </em>  _s = _s.append(s);
<em> 322: </em><font color="red"><strong>}</strong></font>
<em> 323: </em>
<em> 324: </em>void StringLiteral::printdata(ostream &amp;o) const
<em> 325: </em><font color="red"><strong>{</strong></font>
<em> 326: </em>  o &lt;&lt; indent &lt;&lt; <font color="red">&quot;Data:  \&quot;&quot;</font> &lt;&lt; _s &lt;&lt; <font color="red">&quot;\&quot;&quot;</font>;
<em> 327: </em><font color="red"><strong>}</strong></font>
<em> 328: </em>
<em> 329: </em>void StringLiteral::codegen(CodeGen &amp;cg)
<em> 330: </em><font color="red"><strong>{</strong></font>
<em> 331: </em>  cg.genStringLiteral(this);
<em> 332: </em><font color="red"><strong>}</strong></font>
<em> 333: </em>
<em> 334: </em>void Id::printdata(ostream &amp;o) const
<em> 335: </em><font color="red"><strong>{</strong></font>
<em> 336: </em>  o &lt;&lt; indent &lt;&lt; <font color="red">&quot;Name:  &quot;</font> &lt;&lt; _id;
<em> 337: </em><font color="red"><strong>}</strong></font>
<em> 338: </em>
<em> 339: </em>void Id::gensymtab(SymTab *p)
<em> 340: </em><font color="red"><strong>{</strong></font>
<em> 341: </em>  <strong>if</strong> (Node *s = p-&gt;find(_id)) <font color="red"><strong>{</strong></font>
<em> 342: </em>    _has_addr = true;
<em> 343: </em>    _symbol = s;
<em> 344: </em>    _symbol-&gt;set_used();
<em> 345: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em> 346: </em>    Error(this,<font color="red">&quot;Unknown identifier &quot;</font> &lt;&lt; _id);
<em> 347: </em>  <font color="red"><strong>}</strong></font>
<em> 348: </em><font color="red"><strong>}</strong></font>
<em> 349: </em>
<em> 350: </em>void Id::typecheck(Node *curr_func)
<em> 351: </em><font color="red"><strong>{</strong></font>
<em> 352: </em>  assert(_symbol);
<em> 353: </em>  _type = _symbol-&gt;type();
<em> 354: </em><font color="red"><strong>}</strong></font>
<em> 355: </em>
<em> 356: </em>void Id::codegen(CodeGen &amp;cg)
<em> 357: </em><font color="red"><strong>{</strong></font>
<em> 358: </em>  cg.genId(this);
<em> 359: </em><font color="red"><strong>}</strong></font>
<em> 360: </em>
<em> 361: </em>void Const::printdata(ostream &amp;o) const
<em> 362: </em><font color="red"><strong>{</strong></font>
<em> 363: </em>  o &lt;&lt; indent &lt;&lt; <font color="red">&quot;Value:  &quot;</font> &lt;&lt; _value;
<em> 364: </em><font color="red"><strong>}</strong></font>
<em> 365: </em>
<em> 366: </em>void Const::codegen(CodeGen &amp;cg)
<em> 367: </em><font color="red"><strong>{</strong></font>
<em> 368: </em>  cg.genConst(this);
<em> 369: </em><font color="red"><strong>}</strong></font>
<em> 370: </em>
<em> 371: </em>Node::Calc Const::calculate() const
<em> 372: </em><font color="red"><strong>{</strong></font>
<em> 373: </em>  <strong>return</strong> make_pair(_value,true);
<em> 374: </em><font color="red"><strong>}</strong></font>
<em> 375: </em>
<em> 376: </em>Node *get_calculated(Node *node)
<em> 377: </em><font color="red"><strong>{</strong></font>
<em> 378: </em>  pair&lt;int,bool&gt; res = node-&gt;calculate();
<em> 379: </em>  <strong>if</strong> (res.second) <font color="red"><strong>{</strong></font>
<em> 380: </em>    <strong>return</strong> new Const(res.first,new BaseType(BaseType::Int));
<em> 381: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em> 382: </em>    <strong>return</strong> node;
<em> 383: </em>  <font color="red"><strong>}</strong></font>
<em> 384: </em><font color="red"><strong>}</strong></font>
<em> 385: </em>
<em> 386: </em>void Unaryop::printdata(ostream &amp;o) const
<em> 387: </em><font color="red"><strong>{</strong></font>
<em> 388: </em>  o &lt;&lt; indent &lt;&lt; <font color="red">&quot;Expr:  &quot;</font> &lt;&lt; _expr;
<em> 389: </em><font color="red"><strong>}</strong></font>
<em> 390: </em>
<em> 391: </em>void Unaryop::gensymtab(SymTab *p)
<em> 392: </em><font color="red"><strong>{</strong></font>
<em> 393: </em>  _expr-&gt;gensymtab(p);
<em> 394: </em><font color="red"><strong>}</strong></font>
<em> 395: </em>
<em> 396: </em>void Unaryop::typecheck(Node *curr_func)
<em> 397: </em><font color="red"><strong>{</strong></font>
<em> 398: </em>  _expr-&gt;typecheck(curr_func);
<em> 399: </em><font color="red"><strong>}</strong></font>
<em> 400: </em>
<em> 401: </em>Node::Calc Negative::calculate() const
<em> 402: </em><font color="red"><strong>{</strong></font>
<em> 403: </em>  Calc cr = _expr-&gt;calculate();
<em> 404: </em>  <strong>if</strong> (cr.second) <font color="red"><strong>{</strong></font>
<em> 405: </em>    <strong>return</strong> make_pair(-cr.first,true);
<em> 406: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em> 407: </em>    <strong>return</strong> cr;
<em> 408: </em>  <font color="red"><strong>}</strong></font>
<em> 409: </em><font color="red"><strong>}</strong></font>
<em> 410: </em>
<em> 411: </em>void Negative::typecheck(Node *curr_func)
<em> 412: </em><font color="red"><strong>{</strong></font>
<em> 413: </em>  Unaryop::typecheck(curr_func);
<em> 414: </em>  _type = _expr-&gt;type();
<em> 415: </em><font color="red"><strong>}</strong></font>
<em> 416: </em>
<em> 417: </em>void Negative::codegen(CodeGen &amp;cg)
<em> 418: </em><font color="red"><strong>{</strong></font>
<em> 419: </em>  cg.genNegative(this);
<em> 420: </em><font color="red"><strong>}</strong></font>
<em> 421: </em>
<em> 422: </em>void AddrOf::typecheck(Node *curr_func)
<em> 423: </em><font color="red"><strong>{</strong></font>
<em> 424: </em>  Unaryop::typecheck(curr_func);
<em> 425: </em>  <strong>if</strong> (!_expr-&gt;has_address()) <font color="red"><strong>{</strong></font>
<em> 426: </em>    Error(this,<font color="red">&quot;Address-of (&amp;) target has no address.&quot;</font>);
<em> 427: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em> 428: </em>    _expr-&gt;set_output_addr(1);
<em> 429: </em>    _type = new PointerType(_expr-&gt;type());
<em> 430: </em>  <font color="red"><strong>}</strong></font>
<em> 431: </em><font color="red"><strong>}</strong></font>
<em> 432: </em>
<em> 433: </em>void AddrOf::codegen(CodeGen &amp;cg)
<em> 434: </em><font color="red"><strong>{</strong></font>
<em> 435: </em>  cg.genAddrOf(this);
<em> 436: </em><font color="red"><strong>}</strong></font>
<em> 437: </em>
<em> 438: </em>void Pointer::typecheck(Node *curr_func)
<em> 439: </em><font color="red"><strong>{</strong></font>
<em> 440: </em>  Unaryop::typecheck(curr_func);
<em> 441: </em>  <strong>if</strong> (PointerType *pt = tcast&lt;PointerType&gt;(_expr-&gt;type())) <font color="red"><strong>{</strong></font>
<em> 442: </em>    _type = pt-&gt;child();
<em> 443: </em>    set_has_address();
<em> 444: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em> 445: </em>    Error(this,<font color="red">&quot;Pointer dereference (*) target is not a pointer.&quot;</font>);
<em> 446: </em>  <font color="red"><strong>}</strong></font>
<em> 447: </em><font color="red"><strong>}</strong></font>
<em> 448: </em>
<em> 449: </em>void Pointer::codegen(CodeGen &amp;cg)
<em> 450: </em><font color="red"><strong>{</strong></font>
<em> 451: </em>  cg.genPointer(this);
<em> 452: </em><font color="red"><strong>}</strong></font>
<em> 453: </em>
<em> 454: </em>Node::Calc Binop::calculate() const
<em> 455: </em><font color="red"><strong>{</strong></font>
<em> 456: </em>  Calc cl = _left-&gt;calculate();
<em> 457: </em>  <strong>if</strong> (!cl.second) <font color="red"><strong>{</strong></font>
<em> 458: </em>    <strong>return</strong> cl;
<em> 459: </em>  <font color="red"><strong>}</strong></font>
<em> 460: </em>  Calc cr = _right-&gt;calculate();
<em> 461: </em>  <strong>if</strong> (!cr.second) <font color="red"><strong>{</strong></font>
<em> 462: </em>    <strong>return</strong> cr;
<em> 463: </em>  <font color="red"><strong>}</strong></font>
<em> 464: </em>  int l = cl.first, r = cl.second;
<em> 465: </em>  int res;
<em> 466: </em>  <strong>switch</strong> (_op) <font color="red"><strong>{</strong></font>
<em> 467: </em>  <strong>case</strong> PLUS:
<em> 468: </em>    res = l + r;
<em> 469: </em>    <strong>break</strong>;
<em> 470: </em>  <strong>case</strong> MINUS:
<em> 471: </em>    res = l - r;
<em> 472: </em>    <strong>break</strong>;
<em> 473: </em>  <strong>case</strong> ASTERISK:
<em> 474: </em>    res = l * r;
<em> 475: </em>    <strong>break</strong>;
<em> 476: </em>  <strong>case</strong> DIV:
<em> 477: </em>    res = l / r;
<em> 478: </em>    <strong>break</strong>;
<em> 479: </em>  <strong>case</strong> MODULO:
<em> 480: </em>    res = l % r;
<em> 481: </em>    <strong>break</strong>;
<em> 482: </em>  <strong>case</strong> ADD_ASSIGN:
<em> 483: </em>    res = l + r;
<em> 484: </em>    <strong>break</strong>;
<em> 485: </em>  <strong>case</strong> SUB_ASSIGN:
<em> 486: </em>    res = l - r;
<em> 487: </em>    <strong>break</strong>;
<em> 488: </em>  <strong>case</strong> EQ:
<em> 489: </em>    res = (l == r);
<em> 490: </em>    <strong>break</strong>;
<em> 491: </em>  <strong>case</strong> NOT_EQ:
<em> 492: </em>    res = (l != r);
<em> 493: </em>    <strong>break</strong>;
<em> 494: </em>  <strong>case</strong> LESS:
<em> 495: </em>    res = (l &lt; r);
<em> 496: </em>    <strong>break</strong>;
<em> 497: </em>  <strong>case</strong> GREATER:
<em> 498: </em>    res = (l &gt; r);
<em> 499: </em>    <strong>break</strong>;
<em> 500: </em>  <strong>case</strong> LESS_EQ:
<em> 501: </em>    res = (l &lt;= r);
<em> 502: </em>    <strong>break</strong>;
<em> 503: </em>  <strong>case</strong> GREATER_EQ:
<em> 504: </em>    res = (l &gt;= r);
<em> 505: </em>    <strong>break</strong>;
<em> 506: </em>  default: <font color="red"><strong>{</strong></font>
<em> 507: </em>    ostringstream ss;
<em> 508: </em>    ss &lt;&lt; <font color="red">&quot;Unknown binary operator &quot;</font> &lt;&lt; _op;
<em> 509: </em>    <strong>throw</strong> runtime_error(ss.str());
<em> 510: </em>  <font color="red"><strong>}</strong></font>
<em> 511: </em>  <font color="red"><strong>}</strong></font>
<em> 512: </em>  <strong>return</strong> Calc(res,true);
<em> 513: </em><font color="red"><strong>}</strong></font>
<em> 514: </em>
<em> 515: </em>const char *Binop::op_str() const
<em> 516: </em><font color="red"><strong>{</strong></font>
<em> 517: </em>  <strong>switch</strong> (_op) <font color="red"><strong>{</strong></font>
<em> 518: </em>  <strong>case</strong> PLUS:
<em> 519: </em>    <strong>return</strong> <font color="red">&quot;+&quot;</font>;
<em> 520: </em>  <strong>case</strong> MINUS:
<em> 521: </em>    <strong>return</strong> <font color="red">&quot;-&quot;</font>;
<em> 522: </em>  <strong>case</strong> ASTERISK:
<em> 523: </em>    <strong>return</strong> <font color="red">&quot;*&quot;</font>;
<em> 524: </em>  <strong>case</strong> DIV:
<em> 525: </em>    <strong>return</strong> <font color="red">&quot;/&quot;</font>;
<em> 526: </em>  <strong>case</strong> MODULO:
<em> 527: </em>    <strong>return</strong> <font color="red">&quot;%&quot;</font>;
<em> 528: </em>  <strong>case</strong> ASSIGN:
<em> 529: </em>    <strong>return</strong> <font color="red">&quot;=&quot;</font>;
<em> 530: </em>  <strong>case</strong> ADD_ASSIGN:
<em> 531: </em>    <strong>return</strong> <font color="red">&quot;+=&quot;</font>;
<em> 532: </em>  <strong>case</strong> SUB_ASSIGN:
<em> 533: </em>    <strong>return</strong> <font color="red">&quot;-=&quot;</font>;
<em> 534: </em>  <strong>case</strong> EQ:
<em> 535: </em>    <strong>return</strong> <font color="red">&quot;==&quot;</font>;
<em> 536: </em>  <strong>case</strong> NOT_EQ:
<em> 537: </em>    <strong>return</strong> <font color="red">&quot;!=&quot;</font>;
<em> 538: </em>  <strong>case</strong> LESS:
<em> 539: </em>    <strong>return</strong> <font color="red">&quot;&lt;&quot;</font>;
<em> 540: </em>  <strong>case</strong> GREATER:
<em> 541: </em>    <strong>return</strong> <font color="red">&quot;&gt;&quot;</font>;
<em> 542: </em>  <strong>case</strong> LESS_EQ:
<em> 543: </em>    <strong>return</strong> <font color="red">&quot;&lt;=&quot;</font>;
<em> 544: </em>  <strong>case</strong> GREATER_EQ:
<em> 545: </em>    <strong>return</strong> <font color="red">&quot;&gt;=&quot;</font>;
<em> 546: </em>  default: <font color="red"><strong>{</strong></font>
<em> 547: </em>    ostringstream ss;
<em> 548: </em>    ss &lt;&lt; <font color="red">&quot;Unknown binary operator &quot;</font> &lt;&lt; _op;
<em> 549: </em>    <strong>throw</strong> runtime_error(ss.str());
<em> 550: </em>  <font color="red"><strong>}</strong></font>
<em> 551: </em>  <font color="red"><strong>}</strong></font>
<em> 552: </em><font color="red"><strong>}</strong></font>
<em> 553: </em>
<em> 554: </em>void Binop::printdata(ostream &amp;o) const
<em> 555: </em><font color="red"><strong>{</strong></font>
<em> 556: </em>  o &lt;&lt; indent &lt;&lt; <font color="red">&quot;Left:  &quot;</font> &lt;&lt; _left
<em> 557: </em>    &lt;&lt; indent &lt;&lt; <font color="red">&quot;Op  :  &quot;</font> &lt;&lt; op_str()
<em> 558: </em>    &lt;&lt; indent &lt;&lt; <font color="red">&quot;Right:  &quot;</font> &lt;&lt; _right;
<em> 559: </em><font color="red"><strong>}</strong></font>
<em> 560: </em>
<em> 561: </em>void Binop::gensymtab(SymTab *p)
<em> 562: </em><font color="red"><strong>{</strong></font>
<em> 563: </em>  _left-&gt;gensymtab(p);
<em> 564: </em>  _right-&gt;gensymtab(p);
<em> 565: </em><font color="red"><strong>}</strong></font>
<em> 566: </em>
<em> 567: </em>bool Binop::is_assign_op() const
<em> 568: </em><font color="red"><strong>{</strong></font>
<em> 569: </em>  <strong>switch</strong> (_op) <font color="red"><strong>{</strong></font>
<em> 570: </em>  <strong>case</strong> ASSIGN:
<em> 571: </em>  <strong>case</strong> ADD_ASSIGN:
<em> 572: </em>  <strong>case</strong> SUB_ASSIGN:
<em> 573: </em>    <strong>return</strong> true;
<em> 574: </em>  default:
<em> 575: </em>    <strong>return</strong> false;
<em> 576: </em>  <font color="red"><strong>}</strong></font>
<em> 577: </em><font color="red"><strong>}</strong></font>
<em> 578: </em>
<em> 579: </em>bool Binop::is_compare_op() const
<em> 580: </em><font color="red"><strong>{</strong></font>
<em> 581: </em>  <strong>switch</strong> (_op) <font color="red"><strong>{</strong></font>
<em> 582: </em>  <strong>case</strong> EQ:
<em> 583: </em>  <strong>case</strong> NOT_EQ:
<em> 584: </em>  <strong>case</strong> LESS:
<em> 585: </em>  <strong>case</strong> GREATER:
<em> 586: </em>  <strong>case</strong> LESS_EQ:
<em> 587: </em>  <strong>case</strong> GREATER_EQ:
<em> 588: </em>    <strong>return</strong> true;
<em> 589: </em>  default:
<em> 590: </em>    <strong>return</strong> false;
<em> 591: </em>  <font color="red"><strong>}</strong></font>
<em> 592: </em><font color="red"><strong>}</strong></font>
<em> 593: </em>
<em> 594: </em>void Binop::typecheck(Node *curr_func)
<em> 595: </em><font color="red"><strong>{</strong></font>
<em> 596: </em>  _left-&gt;typecheck(curr_func);
<em> 597: </em>  _right-&gt;typecheck(curr_func);
<em> 598: </em>  <strong>if</strong> (is_assign_op()) <font color="red"><strong>{</strong></font>
<em> 599: </em>    <strong>if</strong> (!_left-&gt;has_address()) <font color="red"><strong>{</strong></font>
<em> 600: </em>      Error(this,<font color="red">&quot;Invalid lvalue:  Not an address.&quot;</font>);
<em> 601: </em>    <font color="red"><strong>}</strong></font>
<em> 602: </em>    _left-&gt;set_output_addr(1);
<em> 603: </em>    coerce_const(_right,_left-&gt;type());
<em> 604: </em>    compare_types(_left,_right-&gt;type(),_left-&gt;type());
<em> 605: </em>    _right-&gt;set_coerce_to_type(_left-&gt;type());
<em> 606: </em>    _type = _left-&gt;type();
<em> 607: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em> 608: </em>    coerce_consts(_left,_right);
<em> 609: </em>    bool left_conflicts = compare_types(_left,_left-&gt;type(),_right-&gt;type(),false);
<em> 610: </em>    bool right_conflicts = compare_types(_right,_right-&gt;type(),_left-&gt;type(),false);
<em> 611: </em>    Node *from, *to;
<em> 612: </em>    <strong>if</strong> (left_conflicts &lt; right_conflicts) <font color="red"><strong>{</strong></font>
<em> 613: </em>      from = _right;
<em> 614: </em>      to = _left;
<em> 615: </em>    <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em> 616: </em>      from = _left;
<em> 617: </em>      to = _right;
<em> 618: </em>    <font color="red"><strong>}</strong></font>
<em> 619: </em>    compare_types(from,from-&gt;type(),to-&gt;type());
<em> 620: </em>    from-&gt;set_coerce_to_type(to-&gt;type());
<em> 621: </em>    to-&gt;set_coerce_to_type(to-&gt;type());
<em> 622: </em>    _type = to-&gt;type();
<em> 623: </em>  <font color="red"><strong>}</strong></font>
<em> 624: </em><font color="red"><strong>}</strong></font>
<em> 625: </em>
<em> 626: </em>void Binop::codegen(CodeGen &amp;cg)
<em> 627: </em><font color="red"><strong>{</strong></font>
<em> 628: </em>  cg.genBinop(this);
<em> 629: </em><font color="red"><strong>}</strong></font>
<em> 630: </em>
<em> 631: </em>void IfStatement::printdata(ostream &amp;o) const
<em> 632: </em><font color="red"><strong>{</strong></font>
<em> 633: </em>  o &lt;&lt; indent &lt;&lt; <font color="red">&quot;Expr:  &quot;</font> &lt;&lt; _expr
<em> 634: </em>    &lt;&lt; indent &lt;&lt; <font color="red">&quot;Then:  &quot;</font> &lt;&lt; _then
<em> 635: </em>    &lt;&lt; indent &lt;&lt; <font color="red">&quot;Else:  &quot;</font> &lt;&lt; _else;
<em> 636: </em><font color="red"><strong>}</strong></font>
<em> 637: </em>
<em> 638: </em>void IfStatement::gensymtab(SymTab *p)
<em> 639: </em><font color="red"><strong>{</strong></font>
<em> 640: </em>  _expr-&gt;gensymtab(p);
<em> 641: </em>  _then-&gt;gensymtab(p);
<em> 642: </em>  _else-&gt;gensymtab(p);
<em> 643: </em><font color="red"><strong>}</strong></font>
<em> 644: </em>
<em> 645: </em><font color="#ffa600"><em>// Simple type checking on an expression used by a statement</em></font>
<em> 646: </em><font color="#ffa600"><em>// that expects a boolean value, e.g. if, while, etc.  Throws</em></font>
<em> 647: </em><font color="#ffa600"><em>// an exception if there's a typing problem.</em></font>
<em> 648: </em>void process_conditional(Node *expr)
<em> 649: </em><font color="red"><strong>{</strong></font>
<em> 650: </em>  <strong>if</strong> (!isIntType(expr)) <font color="red"><strong>{</strong></font>
<em> 651: </em>    Error(expr,<font color="red">&quot;Expression must be coercable to a boolean (must be int or char).&quot;</font>);
<em> 652: </em>  <font color="red"><strong>}</strong></font>
<em> 653: </em><font color="red"><strong>}</strong></font>
<em> 654: </em>
<em> 655: </em>void IfStatement::typecheck(Node *curr_func)
<em> 656: </em><font color="red"><strong>{</strong></font>
<em> 657: </em>  _expr-&gt;typecheck(curr_func);
<em> 658: </em>  process_conditional(_expr);
<em> 659: </em>  _then-&gt;typecheck(curr_func);
<em> 660: </em>  _else-&gt;typecheck(curr_func);
<em> 661: </em><font color="red"><strong>}</strong></font>
<em> 662: </em>
<em> 663: </em>void IfStatement::flowcontrol(Node *curr_func,bool in_loop)
<em> 664: </em><font color="red"><strong>{</strong></font>
<em> 665: </em>  _then-&gt;flowcontrol(curr_func,in_loop);
<em> 666: </em>  _else-&gt;flowcontrol(curr_func,in_loop);
<em> 667: </em>  <strong>if</strong> (_then-&gt;has_return_stmt() &amp;&amp; _else-&gt;has_return_stmt()) <font color="red"><strong>{</strong></font>
<em> 668: </em>    set_has_return_stmt(true);
<em> 669: </em>  <font color="red"><strong>}</strong></font>
<em> 670: </em><font color="red"><strong>}</strong></font>
<em> 671: </em>
<em> 672: </em>void IfStatement::codegen(CodeGen &amp;cg)
<em> 673: </em><font color="red"><strong>{</strong></font>
<em> 674: </em>  cg.genConditional(this);
<em> 675: </em><font color="red"><strong>}</strong></font>
<em> 676: </em>
<em> 677: </em>void BreakStatement::flowcontrol(Node *,bool in_loop)
<em> 678: </em><font color="red"><strong>{</strong></font>
<em> 679: </em>  <strong>if</strong> (!in_loop) <font color="red"><strong>{</strong></font>
<em> 680: </em>    Error(this,<font color="red">&quot;Break statement outside of any loop.&quot;</font>);
<em> 681: </em>  <font color="red"><strong>}</strong></font>
<em> 682: </em><font color="red"><strong>}</strong></font>
<em> 683: </em>
<em> 684: </em>void BreakStatement::codegen(CodeGen &amp;cg)
<em> 685: </em><font color="red"><strong>{</strong></font>
<em> 686: </em>  cg.genBreak(this);
<em> 687: </em><font color="red"><strong>}</strong></font>
<em> 688: </em>
<em> 689: </em>void ContinueStatement::flowcontrol(Node *,bool in_loop)
<em> 690: </em><font color="red"><strong>{</strong></font>
<em> 691: </em>  <strong>if</strong> (!in_loop) <font color="red"><strong>{</strong></font>
<em> 692: </em>    Error(this,<font color="red">&quot;Continue statement outside of any loop.&quot;</font>);
<em> 693: </em>  <font color="red"><strong>}</strong></font>
<em> 694: </em><font color="red"><strong>}</strong></font>
<em> 695: </em>
<em> 696: </em>void ContinueStatement::codegen(CodeGen &amp;cg)
<em> 697: </em><font color="red"><strong>{</strong></font>
<em> 698: </em>  cg.genContinue(this);
<em> 699: </em><font color="red"><strong>}</strong></font>
<em> 700: </em>
<em> 701: </em>void ForLoop::printdata(ostream &amp;o) const
<em> 702: </em><font color="red"><strong>{</strong></font>
<em> 703: </em>  o &lt;&lt; indent &lt;&lt; <font color="red">&quot;Begin:  &quot;</font> &lt;&lt; _begin
<em> 704: </em>    &lt;&lt; indent &lt;&lt; <font color="red">&quot;Expr :  &quot;</font> &lt;&lt; _expr
<em> 705: </em>    &lt;&lt; indent &lt;&lt; <font color="red">&quot;End  :  &quot;</font> &lt;&lt; _end
<em> 706: </em>    &lt;&lt; indent &lt;&lt; <font color="red">&quot;Stmt :  &quot;</font> &lt;&lt; _stmt;
<em> 707: </em><font color="red"><strong>}</strong></font>
<em> 708: </em>
<em> 709: </em>void ForLoop::gensymtab(SymTab *p)
<em> 710: </em><font color="red"><strong>{</strong></font>
<em> 711: </em>  _begin-&gt;gensymtab(p);
<em> 712: </em>  _expr-&gt;gensymtab(p);
<em> 713: </em>  _end-&gt;gensymtab(p);
<em> 714: </em>  _stmt-&gt;gensymtab(p);
<em> 715: </em><font color="red"><strong>}</strong></font>
<em> 716: </em>
<em> 717: </em>void ForLoop::typecheck(Node *curr_func)
<em> 718: </em><font color="red"><strong>{</strong></font>
<em> 719: </em>  _begin-&gt;typecheck(curr_func);
<em> 720: </em>  _expr-&gt;typecheck(curr_func);
<em> 721: </em>  process_conditional(_expr);
<em> 722: </em>  _end-&gt;typecheck(curr_func);
<em> 723: </em>  _stmt-&gt;typecheck(curr_func);
<em> 724: </em><font color="red"><strong>}</strong></font>
<em> 725: </em>
<em> 726: </em>void ForLoop::flowcontrol(Node *curr_func,bool in_loop)
<em> 727: </em><font color="red"><strong>{</strong></font>
<em> 728: </em>  _stmt-&gt;flowcontrol(curr_func,true);
<em> 729: </em>  set_has_return_stmt(_stmt-&gt;has_return_stmt());
<em> 730: </em><font color="red"><strong>}</strong></font>
<em> 731: </em>
<em> 732: </em>void ForLoop::codegen(CodeGen &amp;cg)
<em> 733: </em><font color="red"><strong>{</strong></font>
<em> 734: </em>  cg.genForLoop(this);
<em> 735: </em><font color="red"><strong>}</strong></font>
<em> 736: </em>
<em> 737: </em>void WhileLoop::printdata(ostream &amp;o) const
<em> 738: </em><font color="red"><strong>{</strong></font>
<em> 739: </em>  o &lt;&lt; indent &lt;&lt; <font color="red">&quot;Expr:&quot;</font> &lt;&lt; _expr
<em> 740: </em>    &lt;&lt; indent &lt;&lt; <font color="red">&quot;Stmt:&quot;</font> &lt;&lt; _stmt;
<em> 741: </em><font color="red"><strong>}</strong></font>
<em> 742: </em>
<em> 743: </em>void WhileLoop::gensymtab(SymTab *p)
<em> 744: </em><font color="red"><strong>{</strong></font>
<em> 745: </em>  _expr-&gt;gensymtab(p);
<em> 746: </em>  _stmt-&gt;gensymtab(p);
<em> 747: </em><font color="red"><strong>}</strong></font>
<em> 748: </em>
<em> 749: </em>void WhileLoop::typecheck(Node *curr_func)
<em> 750: </em><font color="red"><strong>{</strong></font>
<em> 751: </em>  _expr-&gt;typecheck(curr_func);
<em> 752: </em>  process_conditional(_expr);
<em> 753: </em>  _stmt-&gt;typecheck(curr_func);
<em> 754: </em><font color="red"><strong>}</strong></font>
<em> 755: </em>
<em> 756: </em>void WhileLoop::flowcontrol(Node *curr_func,bool in_loop)
<em> 757: </em><font color="red"><strong>{</strong></font>
<em> 758: </em>  _stmt-&gt;flowcontrol(curr_func,true);
<em> 759: </em>  set_has_return_stmt(_stmt-&gt;has_return_stmt());
<em> 760: </em><font color="red"><strong>}</strong></font>
<em> 761: </em>
<em> 762: </em>void WhileLoop::codegen(CodeGen &amp;cg)
<em> 763: </em><font color="red"><strong>{</strong></font>
<em> 764: </em>  cg.genWhileLoop(this);
<em> 765: </em><font color="red"><strong>}</strong></font>
<em> 766: </em>
<em> 767: </em>void NodeList::printdata(ostream &amp;o) const
<em> 768: </em><font color="red"><strong>{</strong></font>
<em> 769: </em>  <strong>for</strong> (const_iterator i = begin(); i != end(); ++i) <font color="red"><strong>{</strong></font>
<em> 770: </em>    o &lt;&lt; *i;
<em> 771: </em>  <font color="red"><strong>}</strong></font>
<em> 772: </em><font color="red"><strong>}</strong></font>
<em> 773: </em>
<em> 774: </em>void NodeList::gensymtab(SymTab *p)
<em> 775: </em><font color="red"><strong>{</strong></font>
<em> 776: </em>  <strong>for</strong> (iterator i = begin(); i != end(); ++i) <font color="red"><strong>{</strong></font>
<em> 777: </em>    (*i)-&gt;gensymtab(p);
<em> 778: </em>  <font color="red"><strong>}</strong></font>
<em> 779: </em><font color="red"><strong>}</strong></font>
<em> 780: </em>
<em> 781: </em>void NodeList::typecheck(Node *curr_func)
<em> 782: </em><font color="red"><strong>{</strong></font>
<em> 783: </em>  <strong>for</strong> (iterator i = begin(); i != end(); ++i) <font color="red"><strong>{</strong></font>
<em> 784: </em>    (*i)-&gt;typecheck(curr_func);
<em> 785: </em>  <font color="red"><strong>}</strong></font>  
<em> 786: </em><font color="red"><strong>}</strong></font>
<em> 787: </em>
<em> 788: </em>void NodeList::codegen(CodeGen &amp;cg)
<em> 789: </em><font color="red"><strong>{</strong></font>
<em> 790: </em>  cg.genList(this);
<em> 791: </em><font color="red"><strong>}</strong></font>
<em> 792: </em>
<em> 793: </em>void NodeList::writecode(std::ostream &amp;out) const
<em> 794: </em><font color="red"><strong>{</strong></font>
<em> 795: </em>  <strong>for</strong> (const_iterator i = begin(); i != end(); ++i) <font color="red"><strong>{</strong></font>
<em> 796: </em>    (*i)-&gt;writecode(out);
<em> 797: </em>  <font color="red"><strong>}</strong></font>
<em> 798: </em><font color="red"><strong>}</strong></font>
<em> 799: </em>
<em> 800: </em>NodeList &amp;FunctionExpression::get_arglist() const
<em> 801: </em><font color="red"><strong>{</strong></font>
<em> 802: </em>  <strong>return</strong> ncastr&lt;NodeList&gt;(arglist());
<em> 803: </em><font color="red"><strong>}</strong></font>
<em> 804: </em>
<em> 805: </em>void FunctionExpression::printdata(ostream &amp;o) const
<em> 806: </em><font color="red"><strong>{</strong></font>
<em> 807: </em>  o &lt;&lt; indent &lt;&lt; <font color="red">&quot;Name:&quot;</font> &lt;&lt; _function
<em> 808: </em>    &lt;&lt; indent &lt;&lt; <font color="red">&quot;Args:&quot;</font> &lt;&lt; _arglist;
<em> 809: </em><font color="red"><strong>}</strong></font>
<em> 810: </em>
<em> 811: </em>void FunctionExpression::gensymtab(SymTab *p)
<em> 812: </em><font color="red"><strong>{</strong></font>
<em> 813: </em>  _function-&gt;gensymtab(p);
<em> 814: </em>  _arglist-&gt;gensymtab(p);
<em> 815: </em><font color="red"><strong>}</strong></font>
<em> 816: </em>
<em> 817: </em>ParamList *get_params(Node *n)
<em> 818: </em><font color="red"><strong>{</strong></font>
<em> 819: </em>  FunctionType &amp;ft = tcastr&lt;FunctionType&gt;(n-&gt;type());
<em> 820: </em>  <strong>return</strong> &amp;(ncastr&lt;ParamList&gt;(ft.get_params()));
<em> 821: </em><font color="red"><strong>}</strong></font>
<em> 822: </em>
<em> 823: </em>int nlsize(Node *n)
<em> 824: </em><font color="red"><strong>{</strong></font>
<em> 825: </em>  NodeList &amp;nl = ncastr&lt;NodeList&gt;(n);
<em> 826: </em>  <strong>return</strong> nl.size();
<em> 827: </em><font color="red"><strong>}</strong></font>
<em> 828: </em>
<em> 829: </em>Node *getsymbol(Node *n)
<em> 830: </em><font color="red"><strong>{</strong></font>
<em> 831: </em>  Id &amp;id = ncastr&lt;Id&gt;(n);
<em> 832: </em>  <strong>return</strong> id.symbol();
<em> 833: </em><font color="red"><strong>}</strong></font>
<em> 834: </em>
<em> 835: </em>void FunctionExpression::typecheck(Node *curr_func)
<em> 836: </em><font color="red"><strong>{</strong></font>
<em> 837: </em>  _function-&gt;typecheck(curr_func);
<em> 838: </em>  <strong>if</strong> (!_function-&gt;type()-&gt;is_function()) <font color="red"><strong>{</strong></font>
<em> 839: </em>    Error(_function,<font color="red">&quot;Target of function expression is not a function!&quot;</font>);
<em> 840: </em>  <font color="red"><strong>}</strong></font>
<em> 841: </em>  Node *symbol = getsymbol(_function);
<em> 842: </em>  _type = symbol-&gt;type()-&gt;get_return_type();
<em> 843: </em>  _arglist-&gt;typecheck(curr_func);
<em> 844: </em>  ParamList *params = get_params(symbol);
<em> 845: </em>  int num_args = nlsize(_arglist);
<em> 846: </em>  int num_params = nlsize(params);
<em> 847: </em>  <strong>if</strong> (!params-&gt;has_ellipsis() &amp;&amp; num_args &gt; num_params) <font color="red"><strong>{</strong></font>
<em> 848: </em>    Error(this,<font color="red">&quot;Too many arguments passed to function.&quot;</font>);
<em> 849: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <strong>if</strong> (num_args &lt; num_params) <font color="red"><strong>{</strong></font>
<em> 850: </em>    Error(this,<font color="red">&quot;Too few arguments passed to function.&quot;</font>);
<em> 851: </em>  <font color="red"><strong>}</strong></font>
<em> 852: </em>  NodeList &amp;args = ncastr&lt;NodeList&gt;(_arglist);
<em> 853: </em>  NodeList::iterator param = params-&gt;begin();
<em> 854: </em>  NodeList::iterator arg = args.begin();
<em> 855: </em>  <strong>for</strong> (; param != params-&gt;end(); ++arg, ++param) <font color="red"><strong>{</strong></font>
<em> 856: </em>    coerce_const(*arg,(*param)-&gt;type());
<em> 857: </em>    compare_types(this,(*arg)-&gt;type(),(*param)-&gt;type());
<em> 858: </em>    (*arg)-&gt;set_coerce_to_type((*param)-&gt;type());
<em> 859: </em>  <font color="red"><strong>}</strong></font>
<em> 860: </em>  <font color="#ffa600"><em>// Deal with variable number of arguments here.</em></font>
<em> 861: </em>  <strong>if</strong> (params-&gt;has_ellipsis() &amp;&amp; (num_args &gt; num_params)) <font color="red"><strong>{</strong></font>
<em> 862: </em>    <strong>for</strong> ( ; arg != args.end(); ++arg) <font color="red"><strong>{</strong></font>
<em> 863: </em>      (*arg)-&gt;set_coerce_to_type((*arg)-&gt;type());
<em> 864: </em>    <font color="red"><strong>}</strong></font>
<em> 865: </em>  <font color="red"><strong>}</strong></font>
<em> 866: </em><font color="red"><strong>}</strong></font>
<em> 867: </em>
<em> 868: </em>void FunctionExpression::codegen(CodeGen &amp;cg)
<em> 869: </em><font color="red"><strong>{</strong></font>
<em> 870: </em>  cg.genFunctionExpression(this);
<em> 871: </em><font color="red"><strong>}</strong></font>
<em> 872: </em>
<em> 873: </em>void SymNode::printsyms(ostream &amp;o) const
<em> 874: </em><font color="red"><strong>{</strong></font>
<em> 875: </em>  <strong>if</strong> (do_printsyms(o)) <font color="red"><strong>{</strong></font>
<em> 876: </em>    o &lt;&lt; indent &lt;&lt; incrindent &lt;&lt; <font color="red">&quot;Symbols:&quot;</font> &lt;&lt; _symtab &lt;&lt; decrindent;
<em> 877: </em>  <font color="red"><strong>}</strong></font>
<em> 878: </em><font color="red"><strong>}</strong></font>
<em> 879: </em>
<em> 880: </em>void CompoundStatement::printdata(ostream &amp;o) const
<em> 881: </em><font color="red"><strong>{</strong></font>
<em> 882: </em>  o &lt;&lt; indent &lt;&lt; <font color="red">&quot;Decls:&quot;</font> &lt;&lt; _declaration_list
<em> 883: </em>    &lt;&lt; indent &lt;&lt; <font color="red">&quot;Stmts:&quot;</font> &lt;&lt; _statement_list;
<em> 884: </em>  printsyms(o);
<em> 885: </em><font color="red"><strong>}</strong></font>
<em> 886: </em>
<em> 887: </em>void CompoundStatement::gensymtab(SymTab *p)
<em> 888: </em><font color="red"><strong>{</strong></font>
<em> 889: </em>  _symtab = new SymTab(p);
<em> 890: </em>  _declaration_list-&gt;gensymtab(_symtab);
<em> 891: </em>  _statement_list-&gt;gensymtab(_symtab);
<em> 892: </em><font color="red"><strong>}</strong></font>
<em> 893: </em>
<em> 894: </em>void CompoundStatement::typecheck(Node *curr_func)
<em> 895: </em><font color="red"><strong>{</strong></font>
<em> 896: </em>  _statement_list-&gt;typecheck(curr_func);
<em> 897: </em><font color="red"><strong>}</strong></font>
<em> 898: </em>
<em> 899: </em>void CompoundStatement::flowcontrol(Node *curr_func,bool in_loop)
<em> 900: </em><font color="red"><strong>{</strong></font>
<em> 901: </em>  _statement_list-&gt;flowcontrol(curr_func,in_loop);
<em> 902: </em>  set_has_return_stmt(_statement_list-&gt;has_return_stmt());
<em> 903: </em><font color="red"><strong>}</strong></font>
<em> 904: </em>
<em> 905: </em>void CompoundStatement::codegen(CodeGen &amp;cg)
<em> 906: </em><font color="red"><strong>{</strong></font>
<em> 907: </em>  cg.genCompoundStatement(this);
<em> 908: </em><font color="red"><strong>}</strong></font>
<em> 909: </em>
<em> 910: </em>FunctionDefn::FunctionDefn(Node *decl,Node *body) :
<em> 911: </em>  _body(body)
<em> 912: </em><font color="red"><strong>{</strong></font>
<em> 913: </em>  Declaration &amp;d = dynamic_cast&lt;Declaration&amp;&gt;(*decl);
<em> 914: </em>  _type = d.type();
<em> 915: </em>  _name = d.name();
<em> 916: </em>  _extern = d.is_extern();
<em> 917: </em>  _static = d.is_static();
<em> 918: </em><font color="red"><strong>}</strong></font>
<em> 919: </em>
<em> 920: </em>void FunctionDefn::printdata(ostream &amp;o) const
<em> 921: </em><font color="red"><strong>{</strong></font>
<em> 922: </em>  o &lt;&lt; indent &lt;&lt; <font color="red">&quot;Extern:  &quot;</font> &lt;&lt; _extern
<em> 923: </em>    &lt;&lt; indent &lt;&lt; <font color="red">&quot;Static:  &quot;</font> &lt;&lt; _static
<em> 924: </em>    &lt;&lt; indent &lt;&lt; <font color="red">&quot;Name  :  &quot;</font> &lt;&lt; _name
<em> 925: </em>    &lt;&lt; indent &lt;&lt; <font color="red">&quot;Body  :&quot;</font> &lt;&lt; _body;
<em> 926: </em>  printsyms(o);
<em> 927: </em><font color="red"><strong>}</strong></font>
<em> 928: </em>
<em> 929: </em>void FunctionDefn::gensymtab(SymTab *p)
<em> 930: </em><font color="red"><strong>{</strong></font>
<em> 931: </em>  p-&gt;add(_name,this);
<em> 932: </em>  _symtab = new SymTab(p);
<em> 933: </em>  _type-&gt;gensymtab(_symtab);
<em> 934: </em>  _body-&gt;gensymtab(_symtab);
<em> 935: </em><font color="red"><strong>}</strong></font>
<em> 936: </em>
<em> 937: </em>void FunctionDefn::typecheck(Node *curr_func)
<em> 938: </em><font color="red"><strong>{</strong></font>
<em> 939: </em>  _body-&gt;typecheck(this);
<em> 940: </em><font color="red"><strong>}</strong></font>
<em> 941: </em>
<em> 942: </em>void FunctionDefn::flowcontrol(Node *curr_func,bool in_loop)
<em> 943: </em><font color="red"><strong>{</strong></font>
<em> 944: </em>  _body-&gt;flowcontrol(this,false);
<em> 945: </em>  <strong>if</strong> (!_body-&gt;has_return_stmt()) <font color="red"><strong>{</strong></font>
<em> 946: </em>    Warn(this,<font color="red">&quot;Function &quot;</font> &lt;&lt; name() &lt;&lt; <font color="red">&quot; does not return through all branches.&quot;</font>);
<em> 947: </em>  <font color="red"><strong>}</strong></font>
<em> 948: </em><font color="red"><strong>}</strong></font>
<em> 949: </em>
<em> 950: </em>void FunctionDefn::codegen(CodeGen &amp;cg)
<em> 951: </em><font color="red"><strong>{</strong></font>
<em> 952: </em>  cg.genFunctionDefn(this);
<em> 953: </em><font color="red"><strong>}</strong></font>
<em> 954: </em>
<em> 955: </em>void FunctionDefn::writecode(ostream &amp;out) const
<em> 956: </em><font color="red"><strong>{</strong></font>
<em> 957: </em>  <strong>if</strong> (_code) <font color="red"><strong>{</strong></font>
<em> 958: </em>    _code-&gt;write(out);
<em> 959: </em>  <font color="red"><strong>}</strong></font>
<em> 960: </em><font color="red"><strong>}</strong></font>
<em> 961: </em>
<em> 962: </em>void ReturnStatement::printdata(ostream &amp;o) const
<em> 963: </em><font color="red"><strong>{</strong></font>
<em> 964: </em>  o &lt;&lt; indent &lt;&lt; <font color="red">&quot;Expr:  &quot;</font> &lt;&lt; _expr;
<em> 965: </em><font color="red"><strong>}</strong></font>
<em> 966: </em>
<em> 967: </em>void ReturnStatement::gensymtab(SymTab *p)
<em> 968: </em><font color="red"><strong>{</strong></font>
<em> 969: </em>  _expr-&gt;gensymtab(p);
<em> 970: </em><font color="red"><strong>}</strong></font>
<em> 971: </em>
<em> 972: </em>void ReturnStatement::typecheck(Node *curr_func)
<em> 973: </em><font color="red"><strong>{</strong></font>
<em> 974: </em>  _expr-&gt;typecheck(curr_func);
<em> 975: </em>  Type *return_type = curr_func-&gt;type()-&gt;get_return_type();
<em> 976: </em>  coerce_const(_expr,return_type);
<em> 977: </em>  compare_types(this,_expr-&gt;type(),return_type);
<em> 978: </em>  _expr-&gt;set_coerce_to_type(return_type);
<em> 979: </em><font color="red"><strong>}</strong></font>
<em> 980: </em>
<em> 981: </em>void ReturnStatement::flowcontrol(Node *curr_func,bool in_loop)
<em> 982: </em><font color="red"><strong>{</strong></font>
<em> 983: </em>  set_has_return_stmt(true);
<em> 984: </em><font color="red"><strong>}</strong></font>
<em> 985: </em>
<em> 986: </em>void ReturnStatement::codegen(CodeGen &amp;cg)
<em> 987: </em><font color="red"><strong>{</strong></font>
<em> 988: </em>  cg.genReturn(this);
<em> 989: </em><font color="red"><strong>}</strong></font>
<em> 990: </em>
<em> 991: </em>Declaration::Declaration (String n,Type *t) :
<em> 992: </em>  Node(t), _name(n),
<em> 993: </em>  _extern(false), _static(false), _is_used(false)
<em> 994: </em><font color="red"><strong>{</strong></font>
<em> 995: </em><font color="red"><strong>}</strong></font>
<em> 996: </em>
<em> 997: </em>void Declaration::set_base_type(Type *t)
<em> 998: </em><font color="red"><strong>{</strong></font>
<em> 999: </em>  assert(t);
<em>1000: </em>  <strong>if</strong> (!_type) <font color="red"><strong>{</strong></font>
<em>1001: </em>    _type = t;
<em>1002: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em>1003: </em>    _type-&gt;set_base_type(t);
<em>1004: </em>  <font color="red"><strong>}</strong></font>
<em>1005: </em><font color="red"><strong>}</strong></font>
<em>1006: </em>
<em>1007: </em>void Declaration::add_type(Type *t)
<em>1008: </em><font color="red"><strong>{</strong></font>
<em>1009: </em>  t-&gt;set_base_type(_type);
<em>1010: </em>  _type = t;
<em>1011: </em><font color="red"><strong>}</strong></font>
<em>1012: </em>
<em>1013: </em>void Declaration::printdata(ostream &amp;o) const
<em>1014: </em><font color="red"><strong>{</strong></font>
<em>1015: </em>  o &lt;&lt; indent &lt;&lt; <font color="red">&quot;Extern:  &quot;</font> &lt;&lt; _extern
<em>1016: </em>    &lt;&lt; indent &lt;&lt; <font color="red">&quot;Static:  &quot;</font> &lt;&lt; _static
<em>1017: </em>    &lt;&lt; indent &lt;&lt; <font color="red">&quot;Used  :  &quot;</font> &lt;&lt; _is_used
<em>1018: </em>    &lt;&lt; indent &lt;&lt; <font color="red">&quot;Name  :  &quot;</font> &lt;&lt; _name;
<em>1019: </em><font color="red"><strong>}</strong></font>
<em>1020: </em>
<em>1021: </em>void Declaration::gensymtab(SymTab *p)
<em>1022: </em><font color="red"><strong>{</strong></font>
<em>1023: </em>  p-&gt;add(_name,this);
<em>1024: </em><font color="red"><strong>}</strong></font>
<em>1025: </em>
<em>1026: </em>void StatementList::flowcontrol(Node *curr_func,bool in_loop)
<em>1027: </em><font color="red"><strong>{</strong></font>
<em>1028: </em>  <strong>for</strong> (iterator i = begin(); i != end(); ++i) <font color="red"><strong>{</strong></font>
<em>1029: </em>    <strong>if</strong> ( has_return_stmt() ) <font color="red"><strong>{</strong></font>
<em>1030: </em>      Warn(this,<font color="red">&quot;Function &quot;</font> &lt;&lt; curr_func-&gt;name() &lt;&lt; <font color="red">&quot; has at least one unreachable statement.&quot;</font>);
<em>1031: </em>    <font color="red"><strong>}</strong></font>
<em>1032: </em>    (*i)-&gt;flowcontrol(curr_func,in_loop);
<em>1033: </em>    <strong>if</strong> ( (*i)-&gt;has_return_stmt() ) <font color="red"><strong>{</strong></font>
<em>1034: </em>      set_has_return_stmt(true);
<em>1035: </em>    <font color="red"><strong>}</strong></font>
<em>1036: </em>  <font color="red"><strong>}</strong></font>
<em>1037: </em><font color="red"><strong>}</strong></font>
<em>1038: </em>
<em>1039: </em>void StatementList::codegen(CodeGen &amp;cg)
<em>1040: </em><font color="red"><strong>{</strong></font>
<em>1041: </em>  cg.genStatementList(this);
<em>1042: </em><font color="red"><strong>}</strong></font>
<em>1043: </em>
<em>1044: </em>void TranslationUnit::printdata(std::ostream &amp;o) const
<em>1045: </em><font color="red"><strong>{</strong></font>
<em>1046: </em>  NodeList::printdata(o);
<em>1047: </em>  printsyms(o);
<em>1048: </em><font color="red"><strong>}</strong></font>
<em>1049: </em>
<em>1050: </em>void TranslationUnit::gensymtab(SymTab *p)
<em>1051: </em><font color="red"><strong>{</strong></font>
<em>1052: </em>  <font color="#ffa600"><em>// This should be a top-level item w/no parent.</em></font>
<em>1053: </em>  assert(!p);
<em>1054: </em>  _symtab = new SymTab();
<em>1055: </em>  NodeList::gensymtab(_symtab);
<em>1056: </em><font color="red"><strong>}</strong></font>
<em>1057: </em>
<em>1058: </em>bool TranslationUnit::dochecks(CodeGen &amp;cg)
<em>1059: </em><font color="red"><strong>{</strong></font>
<em>1060: </em>  <strong>return</strong> cg.dochecks(this);
<em>1061: </em><font color="red"><strong>}</strong></font>
<em>1062: </em>
<em>1063: </em>void TranslationUnit::codegen(CodeGen &amp;cg)
<em>1064: </em><font color="red"><strong>{</strong></font>
<em>1065: </em>  cg.genTranslationUnit(this);
<em>1066: </em><font color="red"><strong>}</strong></font>
<em>1067: </em>
<em>1068: </em>
<em>1069: </em>ostream &amp;operator&lt;&lt;(ostream &amp;o,const Type *t)
<em>1070: </em><font color="red"><strong>{</strong></font>
<em>1071: </em>  <strong>if</strong> (!t) <font color="red"><strong>{</strong></font>
<em>1072: </em>    o &lt;&lt; <font color="red">&quot;void&quot;</font>;
<em>1073: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em>1074: </em>    t-&gt;print(o);
<em>1075: </em>  <font color="red"><strong>}</strong></font>
<em>1076: </em>  <strong>return</strong> o;
<em>1077: </em><font color="red"><strong>}</strong></font>
<em>1078: </em>
<em>1079: </em>Type::Type() : _child(0)
<em>1080: </em><font color="red"><strong>{</strong></font>
<em>1081: </em><font color="red"><strong>}</strong></font>
<em>1082: </em>
<em>1083: </em>void Type::set_base_type(Type *t)
<em>1084: </em><font color="red"><strong>{</strong></font>
<em>1085: </em>  <strong>if</strong> (!_child) <font color="red"><strong>{</strong></font>
<em>1086: </em>    _child = t;
<em>1087: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em>1088: </em>    _child-&gt;set_base_type(t);
<em>1089: </em>  <font color="red"><strong>}</strong></font>
<em>1090: </em><font color="red"><strong>}</strong></font>
<em>1091: </em>
<em>1092: </em>void Type::gensymtab(SymTab *parent)
<em>1093: </em><font color="red"><strong>{</strong></font>
<em>1094: </em><font color="red"><strong>}</strong></font>
<em>1095: </em>
<em>1096: </em>unsigned Type::size() const
<em>1097: </em><font color="red"><strong>{</strong></font>
<em>1098: </em>  <strong>throw</strong> runtime_error(<font color="red">&quot;Cannot calculate size for type.&quot;</font>);
<em>1099: </em><font color="red"><strong>}</strong></font>
<em>1100: </em>
<em>1101: </em>unsigned BaseType::size() const
<em>1102: </em><font color="red"><strong>{</strong></font>
<em>1103: </em>  <strong>switch</strong> (_type) <font color="red"><strong>{</strong></font>
<em>1104: </em>  <strong>case</strong> Int:
<em>1105: </em>    <strong>return</strong> IntSize;
<em>1106: </em>  <strong>case</strong> Char:
<em>1107: </em>    <strong>return</strong> CharSize;
<em>1108: </em>  <strong>case</strong> Double:
<em>1109: </em>    <strong>return</strong> DoubleSize;
<em>1110: </em>  default:
<em>1111: </em>    <strong>return</strong> Type::size();
<em>1112: </em>  <font color="red"><strong>}</strong></font>
<em>1113: </em><font color="red"><strong>}</strong></font>
<em>1114: </em>
<em>1115: </em>ostream &amp;BaseType::print(ostream &amp;o) const
<em>1116: </em><font color="red"><strong>{</strong></font>
<em>1117: </em>  <strong>switch</strong> (_type) <font color="red"><strong>{</strong></font>
<em>1118: </em>  <strong>case</strong> Int:
<em>1119: </em>    o &lt;&lt; <font color="red">&quot;int&quot;</font>;
<em>1120: </em>    <strong>break</strong>;
<em>1121: </em>  <strong>case</strong> Char:
<em>1122: </em>    o &lt;&lt; <font color="red">&quot;char&quot;</font>;
<em>1123: </em>    <strong>break</strong>;
<em>1124: </em>  <strong>case</strong> Double:
<em>1125: </em>    o &lt;&lt; <font color="red">&quot;double&quot;</font>;
<em>1126: </em>    <strong>break</strong>;
<em>1127: </em>  <strong>case</strong> None:
<em>1128: </em>    o &lt;&lt; <font color="red">&quot;&lt;none&gt;&quot;</font>;
<em>1129: </em>    <strong>break</strong>;
<em>1130: </em>  <font color="red"><strong>}</strong></font>
<em>1131: </em>  <strong>return</strong> o;
<em>1132: </em><font color="red"><strong>}</strong></font>
<em>1133: </em>
<em>1134: </em>ostream &amp;BaseType::print_outer(ostream &amp;o) const
<em>1135: </em><font color="red"><strong>{</strong></font>
<em>1136: </em>  <strong>return</strong> print(o);
<em>1137: </em><font color="red"><strong>}</strong></font>
<em>1138: </em>
<em>1139: </em>ostream &amp;FunctionType::print(ostream &amp;o) const
<em>1140: </em><font color="red"><strong>{</strong></font>
<em>1141: </em>  o &lt;&lt; <font color="red">&quot;function(&quot;</font>;
<em>1142: </em>  NodeList &amp;nl = dynamic_cast&lt;NodeList &amp;&gt;(*_params);
<em>1143: </em>  bool first = true;
<em>1144: </em>  <strong>for</strong> (NodeList::const_iterator i = nl.begin(); i != nl.end(); ++i) <font color="red"><strong>{</strong></font>
<em>1145: </em>    <strong>if</strong> (!first)
<em>1146: </em>      o &lt;&lt; <font color="red">&quot;,&quot;</font>;
<em>1147: </em>    (*i)-&gt;type()-&gt;print(o);
<em>1148: </em>    first = false;
<em>1149: </em>  <font color="red"><strong>}</strong></font>
<em>1150: </em>  o &lt;&lt; <font color="red">&quot;)-&gt;&quot;</font> &lt;&lt; _child;
<em>1151: </em>  <strong>return</strong> o;
<em>1152: </em><font color="red"><strong>}</strong></font>
<em>1153: </em>
<em>1154: </em>void FunctionType::gensymtab(SymTab *p)
<em>1155: </em><font color="red"><strong>{</strong></font>
<em>1156: </em>  _params-&gt;gensymtab(p);
<em>1157: </em><font color="red"><strong>}</strong></font>
<em>1158: </em>
<em>1159: </em>ostream &amp;FunctionType::print_outer(ostream &amp;o) const
<em>1160: </em><font color="red"><strong>{</strong></font>
<em>1161: </em>  o &lt;&lt; <font color="red">&quot;function&quot;</font>;
<em>1162: </em>  <strong>return</strong> o;
<em>1163: </em><font color="red"><strong>}</strong></font>
<em>1164: </em>
<em>1165: </em>unsigned PointerType::size() const
<em>1166: </em><font color="red"><strong>{</strong></font>
<em>1167: </em>  <strong>return</strong> 4;
<em>1168: </em><font color="red"><strong>}</strong></font>
<em>1169: </em>
<em>1170: </em>ostream &amp;PointerType::print(std::ostream &amp;o) const
<em>1171: </em><font color="red"><strong>{</strong></font>
<em>1172: </em>  o &lt;&lt; <font color="red">&quot;pointer(&quot;</font>;
<em>1173: </em>  _child-&gt;print(o);
<em>1174: </em>  o &lt;&lt; <font color="red">&quot;)&quot;</font>;
<em>1175: </em>  <strong>return</strong> o;
<em>1176: </em><font color="red"><strong>}</strong></font>
<em>1177: </em>    
<em>1178: </em>ostream &amp;PointerType::print_outer(std::ostream &amp;o) const
<em>1179: </em><font color="red"><strong>{</strong></font>
<em>1180: </em>  o &lt;&lt; <font color="red">&quot;pointer&quot;</font>;
<em>1181: </em>  <strong>return</strong> o;
<em>1182: </em><font color="red"><strong>}</strong></font>
<em>1183: </em>
<em>1184: </em>BaseType::BT intType(Type *t)
<em>1185: </em><font color="red"><strong>{</strong></font>
<em>1186: </em>  <strong>if</strong> (BaseType *bt = tcast&lt;BaseType&gt;(t)) <font color="red"><strong>{</strong></font>
<em>1187: </em>    <strong>return</strong> bt-&gt;type();
<em>1188: </em>  <font color="red"><strong>}</strong></font>
<em>1189: </em>  <strong>return</strong> BaseType::None;
<em>1190: </em><font color="red"><strong>}</strong></font>
<em>1191: </em>
<em>1192: </em><font color="#ffa600"><em>// Returns true if the object has an integer type (int or char).</em></font>
<em>1193: </em>bool isIntType(Type *t)
<em>1194: </em><font color="red"><strong>{</strong></font>
<em>1195: </em>  <strong>switch</strong> (intType(t)) <font color="red"><strong>{</strong></font>
<em>1196: </em>  <strong>case</strong> BaseType::None:
<em>1197: </em>    <strong>return</strong> false;
<em>1198: </em>  default:
<em>1199: </em>    <strong>return</strong> true;
<em>1200: </em>  <font color="red"><strong>}</strong></font>
<em>1201: </em><font color="red"><strong>}</strong></font>
<em>1202: </em>
<em>1203: </em><font color="#ffa600"><em>// Returns true if the object has an integer type (int or char).</em></font>
<em>1204: </em>bool isIntType(Node *n)
<em>1205: </em><font color="red"><strong>{</strong></font>
<em>1206: </em>  <strong>return</strong> isIntType(n-&gt;type());
<em>1207: </em><font color="red"><strong>}</strong></font>
<em>1208: </em>
<em>1209: </em><font color="#ffa600"><em>// Returns true if we have a pointer type.</em></font>
<em>1210: </em>bool isPtrType(Type *t)
<em>1211: </em><font color="red"><strong>{</strong></font>
<em>1212: </em>  <strong>return</strong> (tcast&lt;PointerType&gt;(t));
<em>1213: </em><font color="red"><strong>}</strong></font>
<em>1214: </em>
<em>1215: </em>bool isPtrType(Node *n)
<em>1216: </em><font color="red"><strong>{</strong></font>
<em>1217: </em>  <strong>return</strong> isPtrType(n-&gt;type());
<em>1218: </em><font color="red"><strong>}</strong></font>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
</div>
<!-- Symbol Table -->
<a name="Symbol-Table"></a>
<div class="skribesubsectiontitle"><table width="100%"><tr><td bgcolor="#ffffff"><h3><font color="#8381de">5.6 Symbol Table</font>
</h3></td></tr></table>
</div><div class="subsection">
<!-- cc/SymTab.h -->
<a name="cc/SymTab.h"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">5.6.1 cc/SymTab.h</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em>  1: </em><font color="#ffa600"><em>//</em></font>
<em>  2: </em><font color="#ffa600"><em>// Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.</em></font>
<em>  3: </em><font color="#ffa600"><em>//</em></font>
<em>  4: </em><font color="#ffa600"><em>// You may distribute under the terms of the Artistic License, as specified in</em></font>
<em>  5: </em><font color="#ffa600"><em>// the COPYING file.</em></font>
<em>  6: </em><font color="#ffa600"><em>//</em></font>
<em>  7: </em><font color="#ffa600"><em>//</em></font>
<em>  8: </em><font color="#ffa600"><em>// The symbol table.  This works as follows:  All symbols are interned</em></font>
<em>  9: </em><font color="#ffa600"><em>// within a single hash and are given unique integer keys (a symbol </em></font>
<em> 10: </em><font color="#ffa600"><em>// counter value).  The symbol table itself is a vector of linked lists,</em></font>
<em> 11: </em><font color="#ffa600"><em>// where the first element in the list is the current item in scope.</em></font>
<em> 12: </em><font color="#ffa600"><em>// To look up an item, the string is hashed, and an index is returned (if</em></font>
<em> 13: </em><font color="#ffa600"><em>// it does not exist, then we're done- it's not in the symbol table).  We</em></font>
<em> 14: </em><font color="#ffa600"><em>// then use this index to see if there is an entry in the vector.  If so,</em></font>
<em> 15: </em><font color="#ffa600"><em>// we return the front item.</em></font>
<em> 16: </em><font color="#ffa600"><em>//</em></font>
<em> 17: </em><font color="#ffa600"><em>// Each symbol table has a level count which is always one greater than its</em></font>
<em> 18: </em><font color="#ffa600"><em>// parent (0 for the root).  Each symbol stores a level value- if a symbol is</em></font>
<em> 19: </em><font color="#ffa600"><em>// added and it already exists with the same level value, an error is reported.</em></font>
<em> 20: </em><font color="#ffa600"><em>// This allows us to detect duplicate symbols.</em></font>
<em> 21: </em><font color="#ffa600"><em>//</em></font>
<em> 22: </em><font color="#ffa600"><em>// Each new scope allocates a new vector and copies the pointers from the</em></font>
<em> 23: </em><font color="#ffa600"><em>// parent scope (shallow copy).  When new symbols are added, the current</em></font>
<em> 24: </em><font color="#ffa600"><em>// vector is updated and the added linked-list node is inserted at the</em></font>
<em> 25: </em><font color="#ffa600"><em>// front.  This means that the symbol table is persistent:  Adding a new</em></font>
<em> 26: </em><font color="#ffa600"><em>// scope does not affect the symbol tables of any other scopes.</em></font>
<em> 27: </em><font color="#ffa600"><em>//</em></font>
<em> 28: </em>
<em> 29: </em>#ifndef _SYMTAB_H_
<em> 30: </em><font color="#1919af"><strong>#define</strong></font> _SYMTAB_H_
<em> 31: </em>
<em> 32: </em><font color="#1919af"><strong>#include</strong></font> &lt;vector&gt;
<em> 33: </em># include &lt;ext/hash_map&gt;
<em> 34: </em>using namespace __gnu_cxx;
<em> 35: </em>
<em> 36: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;gc/gc_cpp.h&quot;</font>
<em> 37: </em>
<em> 38: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;String.h&quot;</font>
<em> 39: </em>
<em> 40: </em><strong>struct</strong> SymHash : public gc, public hash_map&lt;String,int,StringHash,equal_to&lt;String&gt; &gt; <font color="red"><strong>{</strong></font>
<em> 41: </em>  SymHash() : _nextsym(0) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em> 42: </em>
<em> 43: </em>  int get_symbol(String x);
<em> 44: </em>  int symbol_index(String x) const;
<em> 45: </em>private:
<em> 46: </em>  int _nextsym;
<em> 47: </em><font color="red"><strong>}</strong></font>;
<em> 48: </em>
<em> 49: </em><font color="#ffa600"><em>// This represents a single scope of a symbol table.  A parent (constructor</em></font>
<em> 50: </em><font color="#ffa600"><em>// argument) represents a parent scope.  Note that we store a pointer to the</em></font>
<em> 51: </em><font color="#ffa600"><em>// parent scope, but it's not used for finding a symbol (as described above).</em></font>
<em> 52: </em><font color="#ffa600"><em>// Also, each table has a list of its children so that it's possible to traverse</em></font>
<em> 53: </em><font color="#ffa600"><em>// the complete tree from a root pointer.</em></font>
<em> 54: </em><strong>class</strong> SymTab : public gc <font color="red"><strong>{</strong></font>
<em> 55: </em>public:
<em> 56: </em>  <strong>struct</strong> Symbol <font color="red"><strong>{</strong></font>
<em> 57: </em>    int     _level; <font color="#ffa600"><em>// Level at which it was added.</em></font>
<em> 58: </em>    Node   *_n;     <font color="#ffa600"><em>// The item that the symbol represents.</em></font>
<em> 59: </em>    Symbol *_next;  <font color="#ffa600"><em>// Next element in chain.</em></font>
<em> 60: </em>
<em> 61: </em>    Symbol(int l,Node *n) : _level(l), _n(n), _next(0) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em> 62: </em>    Symbol(int l,Node *n,Symbol *next) : _level(l), _n(n), _next(next) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em> 63: </em>  <font color="red"><strong>}</strong></font>;
<em> 64: </em>  <strong>typedef</strong> vector&lt;Symbol *,traceable_allocator&lt;Symbol *&gt; &gt; Symbols;
<em> 65: </em>  <strong>typedef</strong> vector&lt;SymTab *,traceable_allocator&lt;SymTab *&gt; &gt; Children;
<em> 66: </em>
<em> 67: </em>  <strong>typedef</strong> Symbols::const_iterator const_iterator;
<em> 68: </em>  <strong>typedef</strong> Children::const_iterator const_children_iterator;
<em> 69: </em>
<em> 70: </em>  <font color="#ffa600"><em>// Create a root-level symbol table.  This creates a new symbol hash.</em></font>
<em> 71: </em>  SymTab();
<em> 72: </em>  <font color="#ffa600"><em>// Create a symbol table, inheriting symbols and hash from an outer scope.</em></font>
<em> 73: </em>  SymTab(SymTab *parent);
<em> 74: </em>
<em> 75: </em>  <font color="#ffa600"><em>// Add a symbol.  If raise is true, throws runtime_error if a duplicate is</em></font>
<em> 76: </em>  <font color="#ffa600"><em>// found.  If false, returns false.</em></font>
<em> 77: </em>  <font color="#ffa600"><em>// This throws an exception if the name is not an identifier.</em></font>
<em> 78: </em>  bool add(String name,Node *value,bool raise = true);
<em> 79: </em>
<em> 80: </em>  <font color="#ffa600"><em>// Returns true if the symbol occurs at the same scope</em></font>
<em> 81: </em>  <font color="#ffa600"><em>// as this symbol table.</em></font>
<em> 82: </em>  bool is_local(Symbol *s) const <font color="red"><strong>{</strong></font> assert(s); <strong>return</strong> _level == s-&gt;_level; <font color="red"><strong>}</strong></font>;
<em> 83: </em>
<em> 84: </em>  <font color="#ffa600"><em>// Returns a pointer to the node, or 0 if not found.</em></font>
<em> 85: </em>  Node *find(String s) const;
<em> 86: </em>
<em> 87: </em>  <font color="#ffa600"><em>// Get parent scope.</em></font>
<em> 88: </em>  SymTab *parent() const <font color="red"><strong>{</strong></font> <strong>return</strong> _parent; <font color="red"><strong>}</strong></font>;
<em> 89: </em>
<em> 90: </em>  const_iterator begin() const <font color="red"><strong>{</strong></font> <strong>return</strong> _symbols.begin(); <font color="red"><strong>}</strong></font>;
<em> 91: </em>  const_iterator end() const <font color="red"><strong>{</strong></font> <strong>return</strong> _symbols.end(); <font color="red"><strong>}</strong></font>;
<em> 92: </em>
<em> 93: </em>  const_children_iterator childbegin() const <font color="red"><strong>{</strong></font> <strong>return</strong> _children.begin(); <font color="red"><strong>}</strong></font>;
<em> 94: </em>  const_children_iterator childend() const <font color="red"><strong>{</strong></font> <strong>return</strong> _children.end(); <font color="red"><strong>}</strong></font>;
<em> 95: </em>
<em> 96: </em>  void print(std::ostream &amp;o) const;
<em> 97: </em>private:
<em> 98: </em>  void add_child(SymTab *);
<em> 99: </em>  void adjust_size(unsigned);
<em>100: </em>  friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;,const SymTab *);
<em>101: </em>
<em>102: </em>  Symbols  _symbols;  <font color="#ffa600"><em>// Symbols, indexed by values stored in symhash.</em></font>
<em>103: </em>  int      _level;    <font color="#ffa600"><em>// Current level of this table (0 is root).</em></font>
<em>104: </em>  SymTab  *_parent;   <font color="#ffa600"><em>// Parent scope.</em></font>
<em>105: </em>  Children _children; <font color="#ffa600"><em>// Pointers to child scopes.</em></font>
<em>106: </em>  SymHash *_hash;     <font color="#ffa600"><em>// Symbol hash.</em></font>
<em>107: </em><font color="red"><strong>}</strong></font>;
<em>108: </em>
<em>109: </em><font color="#1919af"><strong>#endif</strong></font>
<em>110: </em>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
<!-- cc/SymTab.C -->
<a name="cc/SymTab.C"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">5.6.2 cc/SymTab.C</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em>  1: </em><font color="#ffa600"><em>//</em></font>
<em>  2: </em><font color="#ffa600"><em>// Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.</em></font>
<em>  3: </em><font color="#ffa600"><em>//</em></font>
<em>  4: </em><font color="#ffa600"><em>// You may distribute under the terms of the Artistic License, as specified in</em></font>
<em>  5: </em><font color="#ffa600"><em>// the COPYING file.</em></font>
<em>  6: </em><font color="#ffa600"><em>//</em></font>
<em>  7: </em><font color="#ffa600"><em>//</em></font>
<em>  8: </em><font color="#ffa600"><em>// Symbol table implementation file- refer to header for a</em></font>
<em>  9: </em><font color="#ffa600"><em>// description of the data structure.</em></font>
<em> 10: </em><font color="#ffa600"><em>//</em></font>
<em> 11: </em>
<em> 12: </em><font color="#1919af"><strong>#include</strong></font> &lt;sstream&gt;
<em> 13: </em><font color="#1919af"><strong>#include</strong></font> &lt;stdexcept&gt;
<em> 14: </em>
<em> 15: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;Node.h&quot;</font>
<em> 16: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;SymTab.h&quot;</font>
<em> 17: </em>
<em> 18: </em>using namespace std;
<em> 19: </em>
<em> 20: </em><font color="#ffa600"><em>// Default symbol table vector init size.</em></font>
<em> 21: </em>const int DefaultSize = 50;
<em> 22: </em>
<em> 23: </em><font color="#ffa600"><em>// Return an index for a given symbol.  This inserts the name</em></font>
<em> 24: </em><font color="#ffa600"><em>// into the hash if it doesn't exist and updates _nextsym accordingly.</em></font>
<em> 25: </em>inline int SymHash::get_symbol(String x)
<em> 26: </em><font color="red"><strong>{</strong></font>
<em> 27: </em>  pair&lt;SymHash::iterator,bool&gt; ip = insert(value_type(x,_nextsym));
<em> 28: </em>  <strong>if</strong> (ip.second) <font color="red"><strong>{</strong></font>
<em> 29: </em>    ++_nextsym;
<em> 30: </em>  <font color="red"><strong>}</strong></font>
<em> 31: </em>  <strong>return</strong> ip.first-&gt;second;
<em> 32: </em><font color="red"><strong>}</strong></font>
<em> 33: </em>
<em> 34: </em><font color="#ffa600"><em>// This returns an index, or -1 if not found.</em></font>
<em> 35: </em>inline int SymHash::symbol_index(String x) const
<em> 36: </em><font color="red"><strong>{</strong></font>
<em> 37: </em>  const_iterator i = find(x);
<em> 38: </em>  <strong>return</strong> (i == end()) ? -1 : i-&gt;second;
<em> 39: </em><font color="red"><strong>}</strong></font>
<em> 40: </em>
<em> 41: </em><font color="#ffa600"><em>// Create a root-level symbol table.</em></font>
<em> 42: </em>SymTab::SymTab() :
<em> 43: </em>  _symbols(DefaultSize),
<em> 44: </em>  _level(0),
<em> 45: </em>  _parent(0),
<em> 46: </em>  _hash(new SymHash)
<em> 47: </em><font color="red"><strong>{</strong></font>
<em> 48: </em><font color="red"><strong>}</strong></font>
<em> 49: </em>
<em> 50: </em><font color="#ffa600"><em>// Create a symbol table, inheriting symbols from an outer scope.</em></font>
<em> 51: </em>SymTab::SymTab(SymTab *parent) :
<em> 52: </em>  _symbols(parent-&gt;_symbols),
<em> 53: </em>  _level(parent-&gt;_level+1),
<em> 54: </em>  _parent(parent),
<em> 55: </em>  _hash(parent-&gt;_hash)
<em> 56: </em><font color="red"><strong>{</strong></font>
<em> 57: </em>  parent-&gt;add_child(this);
<em> 58: </em><font color="red"><strong>}</strong></font>
<em> 59: </em>
<em> 60: </em><font color="#ffa600"><em>// Resize symbol table array if necessary.</em></font>
<em> 61: </em>inline void SymTab::adjust_size(unsigned s)
<em> 62: </em><font color="red"><strong>{</strong></font>
<em> 63: </em>  <strong>if</strong> (_symbols.size() &lt; s) <font color="red"><strong>{</strong></font>
<em> 64: </em>    _symbols.resize(s);
<em> 65: </em>  <font color="red"><strong>}</strong></font>
<em> 66: </em><font color="red"><strong>}</strong></font>
<em> 67: </em>
<em> 68: </em><font color="#ffa600"><em>// Add a symbol.  The basic process is:  Intern the</em></font>
<em> 69: </em><font color="#ffa600"><em>// symbol, adjust the size of the array, if necessary,</em></font>
<em> 70: </em><font color="#ffa600"><em>// then look at the index location:  If empty, we add it.</em></font>
<em> 71: </em><font color="#ffa600"><em>// If not, check for a duplicate symbol (same level).  If okay,</em></font>
<em> 72: </em><font color="#ffa600"><em>// add to head of chain.</em></font>
<em> 73: </em>bool SymTab::add(String name,Node *value,bool raise)
<em> 74: </em><font color="red"><strong>{</strong></font>
<em> 75: </em>  int index = _hash-&gt;get_symbol(name);
<em> 76: </em>  adjust_size(index);
<em> 77: </em>
<em> 78: </em>  <strong>if</strong> (Symbol *first = _symbols[index]) <font color="red"><strong>{</strong></font>
<em> 79: </em>    <font color="#ffa600"><em>// Entry exists.  Do we have a duplicate?</em></font>
<em> 80: </em>    <strong>if</strong> (first-&gt;_level == _level) <font color="red"><strong>{</strong></font>
<em> 81: </em>      <font color="#ffa600"><em>// We have a duplicate.</em></font>
<em> 82: </em>      <strong>if</strong> (raise) <font color="red"><strong>{</strong></font>
<em> 83: </em>        Error(value,<font color="red">&quot;Duplicate identifier.  Original is at &quot;</font> &lt;&lt; first-&gt;_n-&gt;filename() &lt;&lt; <font color="red">&quot;:&quot;</font> &lt;&lt; first-&gt;_n-&gt;linenumber() &lt;&lt; <font color="red">&quot;.&quot;</font>);        
<em> 84: </em>      <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em> 85: </em>        <strong>return</strong> false;
<em> 86: </em>      <font color="red"><strong>}</strong></font>
<em> 87: </em>    <font color="red"><strong>}</strong></font>
<em> 88: </em>    <font color="#ffa600"><em>// Okay- add to front.</em></font>
<em> 89: </em>    Symbol *s = new Symbol(_level,value,first);
<em> 90: </em>    _symbols[index] = s;
<em> 91: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em> 92: </em>    <font color="#ffa600"><em>// Entry is empty- add symbol.</em></font>
<em> 93: </em>    _symbols[index] = new Symbol(_level,value);
<em> 94: </em>  <font color="red"><strong>}</strong></font>
<em> 95: </em>  <strong>return</strong> true;
<em> 96: </em><font color="red"><strong>}</strong></font>
<em> 97: </em>
<em> 98: </em>void SymTab::add_child(SymTab *s)
<em> 99: </em><font color="red"><strong>{</strong></font>
<em>100: </em>  _children.push_back(s);
<em>101: </em><font color="red"><strong>}</strong></font>
<em>102: </em>
<em>103: </em><font color="#ffa600"><em>// Try to find a symbol.  Basic process is:  If the symbol</em></font>
<em>104: </em><font color="#ffa600"><em>// doesn't exist in the hash, then it's not there.  Else,</em></font>
<em>105: </em><font color="#ffa600"><em>// if the symbol table array is too small, then it's not there.</em></font>
<em>106: </em><font color="#ffa600"><em>// Else, if the array location is empty, then it's not there.</em></font>
<em>107: </em><font color="#ffa600"><em>// Else, it's there.</em></font>
<em>108: </em>Node *SymTab::find(String name) const
<em>109: </em><font color="red"><strong>{</strong></font>
<em>110: </em>  int index = _hash-&gt;symbol_index(name);
<em>111: </em>  <strong>if</strong> (index &lt; 0) <font color="red"><strong>{</strong></font>
<em>112: </em>    <strong>return</strong> 0;
<em>113: </em>  <font color="red"><strong>}</strong></font>
<em>114: </em>  <strong>if</strong> ((int)_symbols.size() &lt;= index) <font color="red"><strong>{</strong></font>
<em>115: </em>    <strong>return</strong> 0;
<em>116: </em>  <font color="red"><strong>}</strong></font>
<em>117: </em>  <strong>if</strong> (!_symbols[index]) <font color="red"><strong>{</strong></font>
<em>118: </em>    <strong>return</strong> 0;
<em>119: </em>  <font color="red"><strong>}</strong></font>
<em>120: </em>  <strong>return</strong> _symbols[index]-&gt;_n;
<em>121: </em><font color="red"><strong>}</strong></font>
<em>122: </em>
<em>123: </em>std::ostream &amp;operator&lt;&lt;(std::ostream &amp;o,const SymTab *x)
<em>124: </em><font color="red"><strong>{</strong></font>
<em>125: </em>  <strong>if</strong> (!x) <font color="red"><strong>{</strong></font>
<em>126: </em>    o &lt;&lt; indent &lt;&lt; <font color="red">&quot;&lt;empty&gt;&quot;</font>;
<em>127: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em>128: </em>    x-&gt;print(o);
<em>129: </em>  <font color="red"><strong>}</strong></font>
<em>130: </em>  <strong>return</strong> o;
<em>131: </em><font color="red"><strong>}</strong></font>
<em>132: </em>
<em>133: </em>void SymTab::print(std::ostream &amp;o) const
<em>134: </em><font color="red"><strong>{</strong></font>
<em>135: </em>  <font color="#ffa600"><em>// We print out the symbols in a manner that makes sense to the user,</em></font>
<em>136: </em>  <font color="#ffa600"><em>// so we iterate over each level, printing only symbols of that level.</em></font>
<em>137: </em>  o &lt;&lt; indent &lt;&lt; <font color="red">&quot;Level &quot;</font> &lt;&lt; _level &lt;&lt; incrindent;
<em>138: </em>  <strong>for</strong> (Symbols::const_iterator i = _symbols.begin(); i != _symbols.end(); ++i) <font color="red"><strong>{</strong></font>
<em>139: </em>    <strong>if</strong> (*i) <font color="red"><strong>{</strong></font>
<em>140: </em>      Symbol &amp;s = *(*i);
<em>141: </em>      <strong>if</strong> (s._level == _level) <font color="red"><strong>{</strong></font>
<em>142: </em>        o &lt;&lt; indent &lt;&lt; s._n-&gt;name() &lt;&lt; <font color="red">&quot;:  &quot;</font> &lt;&lt; s._n-&gt;type();
<em>143: </em>      <font color="red"><strong>}</strong></font>
<em>144: </em>    <font color="red"><strong>}</strong></font>
<em>145: </em>  <font color="red"><strong>}</strong></font>
<em>146: </em>  o &lt;&lt; decrindent;
<em>147: </em>  <strong>if</strong> (_parent) <font color="red"><strong>{</strong></font>
<em>148: </em>    _parent-&gt;print(o);
<em>149: </em>  <font color="red"><strong>}</strong></font>
<em>150: </em><font color="red"><strong>}</strong></font>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
</div>
<!-- Code Generation -->
<a name="Code-Generation"></a>
<div class="skribesubsectiontitle"><table width="100%"><tr><td bgcolor="#ffffff"><h3><font color="#8381de">5.7 Code Generation</font>
</h3></td></tr></table>
</div><div class="subsection">
<!-- cc/CodeGen.h -->
<a name="cc/CodeGen.h"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">5.7.1 cc/CodeGen.h</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em>  1: </em><font color="#ffa600"><em>//</em></font>
<em>  2: </em><font color="#ffa600"><em>// Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.</em></font>
<em>  3: </em><font color="#ffa600"><em>//</em></font>
<em>  4: </em><font color="#ffa600"><em>// You may distribute under the terms of the Artistic License, as specified in</em></font>
<em>  5: </em><font color="#ffa600"><em>// the COPYING file.</em></font>
<em>  6: </em><font color="#ffa600"><em>//</em></font>
<em>  7: </em><font color="#ffa600"><em>//</em></font>
<em>  8: </em><font color="#ffa600"><em>// Main code generation class.  This is designed to be re-entrant so</em></font>
<em>  9: </em><font color="#ffa600"><em>// that it can handle multiple threads.  Non-reentrant stuff is encapsulated</em></font>
<em> 10: </em><font color="#ffa600"><em>// within a single mutex class that's not visible in the header.  This</em></font>
<em> 11: </em><font color="#ffa600"><em>// allows the class to be used by pure C, even though the implementation</em></font>
<em> 12: </em><font color="#ffa600"><em>// is in Plasma.</em></font>
<em> 13: </em><font color="#ffa600"><em>//</em></font>
<em> 14: </em>
<em> 15: </em>#ifndef _CODEGEN_H_
<em> 16: </em><font color="#1919af"><strong>#define</strong></font> _CODEGEN_H_
<em> 17: </em>
<em> 18: </em><font color="#1919af"><strong>#include</strong></font> &lt;string&gt;
<em> 19: </em>
<em> 20: </em><strong>struct</strong> Operand;
<em> 21: </em><strong>class</strong> StackMachine;
<em> 22: </em><strong>class</strong> AsmStore;
<em> 23: </em><strong>class</strong> SharedData;
<em> 24: </em><strong>class</strong> ThreadData;
<em> 25: </em><strong>class</strong> Node;
<em> 26: </em><strong>class</strong> CData;
<em> 27: </em><strong>class</strong> Type;
<em> 28: </em><strong>class</strong> SymTab;
<em> 29: </em><strong>class</strong> FunctionDefn;
<em> 30: </em><strong>class</strong> NodeList;
<em> 31: </em><strong>class</strong> StatementList;
<em> 32: </em><strong>class</strong> IfStatement;
<em> 33: </em><strong>class</strong> WhileLoop;
<em> 34: </em><strong>class</strong> ForLoop;
<em> 35: </em><strong>class</strong> BreakStatement;
<em> 36: </em><strong>class</strong> ContinueStatment;
<em> 37: </em><strong>class</strong> StringLiteral;
<em> 38: </em><strong>class</strong> Const;
<em> 39: </em><strong>class</strong> Id;
<em> 40: </em><strong>class</strong> ArrayExpression;
<em> 41: </em><strong>class</strong> FunctionExpression;
<em> 42: </em><strong>class</strong> ReturnStatement;
<em> 43: </em><strong>class</strong> Binop;
<em> 44: </em><strong>class</strong> Negative;
<em> 45: </em><strong>class</strong> Pointer;
<em> 46: </em><strong>class</strong> AddrOf;
<em> 47: </em>
<em> 48: </em><strong>class</strong> CodeGen <font color="red"><strong>{</strong></font>
<em> 49: </em>public:
<em> 50: </em>  <font color="#ffa600"><em>// This allocates a new common-data object.</em></font>
<em> 51: </em>  CodeGen(bool print_comments = true);
<em> 52: </em>  <font color="#ffa600"><em>// This inherits a common-data object.</em></font>
<em> 53: </em>  CodeGen(const CodeGen &amp;);
<em> 54: </em>
<em> 55: </em>  <font color="#ffa600"><em>// Performs necessary checks on the code (typechecking,</em></font>
<em> 56: </em>  <font color="#ffa600"><em>// control-flow analysis, etc.)</em></font>
<em> 57: </em>  bool dochecks(TranslationUnit *unit);
<em> 58: </em>
<em> 59: </em>  void handleGlobals(Node *unit);
<em> 60: </em>
<em> 61: </em>  void write(const std::string &amp;,Node *) const;
<em> 62: </em>
<em> 63: </em>  <font color="#ffa600"><em>// Used by Node for code generation.</em></font>
<em> 64: </em>  void genTranslationUnit(TranslationUnit *);
<em> 65: </em>  void genList(NodeList *);
<em> 66: </em>  void genStatementList(StatementList *);
<em> 67: </em>  void genFunctionDefn(FunctionDefn *);
<em> 68: </em>  void genConditional(IfStatement *);
<em> 69: </em>  void genWhileLoop(WhileLoop *);
<em> 70: </em>  void genForLoop(ForLoop *);
<em> 71: </em>  void genBreak(BreakStatement *);
<em> 72: </em>  void genContinue(ContinueStatement *);
<em> 73: </em>  void genStringLiteral(StringLiteral *);
<em> 74: </em>  void genCompoundStatement(CompoundStatement *);
<em> 75: </em>  void genConst(Const *);
<em> 76: </em>  void genId(Id *);
<em> 77: </em>  void genArrayExpression(ArrayExpression *);
<em> 78: </em>  void genFunctionExpression(FunctionExpression *);
<em> 79: </em>  void genReturn(ReturnStatement *);
<em> 80: </em>  void genBinop(Binop *bo);
<em> 81: </em>  void genNegative(Negative *n);
<em> 82: </em>  void genPointer(Pointer *n);
<em> 83: </em>  void genAddrOf(AddrOf *n);
<em> 84: </em>
<em> 85: </em>  <font color="#ffa600"><em>// Internal use.</em></font>
<em> 86: </em>  bool dochecks_internal(Node *n);
<em> 87: </em>  bool codegen_internal(CodeGen codegen,Node *n);
<em> 88: </em>private:
<em> 89: </em>  AsmStore &amp;code();
<em> 90: </em>  StackMachine &amp;stack();
<em> 91: </em>
<em> 92: </em>  void push_loop_labels(const std::string &amp;break_label,const std::string &amp;continue_label);
<em> 93: </em>  void pop_loop_labels();
<em> 94: </em>  const std::string &amp;break_label() const;
<em> 95: </em>  const std::string &amp;continue_label() const;
<em> 96: </em>
<em> 97: </em>  unsigned asm_var_size(Type *t);
<em> 98: </em>  unsigned calc_var_align(Type *t);
<em> 99: </em>  const char *binop(int) const;
<em>100: </em>  std::string new_label();
<em>101: </em>  std::string new_str_label(String s);
<em>102: </em>  void empty_stack(Node *);
<em>103: </em>  void accept_and_empty_stack(Node *);
<em>104: </em>  int calc_local_var_addrs(SymTab *symtab,int last_fp_loc);
<em>105: </em>  void calc_function_arg_addrs(SymTab *symtab);
<em>106: </em>  int calc_function_var_addrs(FunctionDefn *fd,int last_fp_loc);
<em>107: </em>  Operand accept_and_pop(Node *na);
<em>108: </em>  void binop_assign(Binop *bo);
<em>109: </em>  void binop_arith(Binop *bo);
<em>110: </em>  void binop_compare(Binop *bo);
<em>111: </em>
<em>112: </em>  <font color="#ffa600"><em>// Shared data for code generation.</em></font>
<em>113: </em>  SharedData *_sdata;
<em>114: </em>
<em>115: </em>  <font color="#ffa600"><em>// Per-thread code generation data.</em></font>
<em>116: </em>  ThreadData *_tdata;
<em>117: </em><font color="red"><strong>}</strong></font>;
<em>118: </em>
<em>119: </em><font color="#1919af"><strong>#endif</strong></font>
<em>120: </em>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
<!-- cc/CodeGen.pa -->
<a name="cc/CodeGen.pa"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">5.7.2 cc/CodeGen.pa</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em>  1: </em><font color="#ffa600"><em>//</em></font>
<em>  2: </em><font color="#ffa600"><em>// Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.</em></font>
<em>  3: </em><font color="#ffa600"><em>//</em></font>
<em>  4: </em><font color="#ffa600"><em>// You may distribute under the terms of the Artistic License, as specified in</em></font>
<em>  5: </em><font color="#ffa600"><em>// the COPYING file.</em></font>
<em>  6: </em><font color="#ffa600"><em>//</em></font>
<em>  7: </em><font color="#ffa600"><em>//</em></font>
<em>  8: </em><font color="#ffa600"><em>// Main code generation class.  This is designed to be re-entrant so</em></font>
<em>  9: </em><font color="#ffa600"><em>// that it can handle multiple threads.  Non-reentrant stuff is encapsulated</em></font>
<em> 10: </em><font color="#ffa600"><em>// within a single mutex class that's not visible in the header.  This</em></font>
<em> 11: </em><font color="#ffa600"><em>// allows the class to be used by pure C, even though the implementation</em></font>
<em> 12: </em><font color="#ffa600"><em>// is in Plasma.</em></font>
<em> 13: </em><font color="#ffa600"><em>//</em></font>
<em> 14: </em>
<em> 15: </em><font color="#1919af"><strong>#include</strong></font> &lt;fstream&gt;
<em> 16: </em><font color="#1919af"><strong>#include</strong></font> &lt;sstream&gt;
<em> 17: </em><font color="#1919af"><strong>#include</strong></font> &lt;stdexcept&gt;
<em> 18: </em><font color="#1919af"><strong>#include</strong></font> &lt;iostream&gt;
<em> 19: </em><font color="#1919af"><strong>#include</strong></font> &lt;list&gt;
<em> 20: </em>
<em> 21: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;Types.h&quot;</font>
<em> 22: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;Node.h&quot;</font>
<em> 23: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;SymTab.h&quot;</font>
<em> 24: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;CodeGen.h&quot;</font>
<em> 25: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;AsmStore.h&quot;</font>
<em> 26: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;StackMachine.h&quot;</font>
<em> 27: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;cparse.h&quot;</font>
<em> 28: </em>
<em> 29: </em>using namespace std;
<em> 30: </em>using namespace plasma;
<em> 31: </em>
<em> 32: </em><font color="#1919af"><strong>#define</strong></font> ASM(code,a,c) <font color="red"><strong>{</strong></font> \
<em> 33: </em>  ostringstream s1,s2; \
<em> 34: </em>  s1 &lt;&lt; a; \
<em> 35: </em>  s2 &lt;&lt; c; \
<em> 36: </em>  code.o(s1.str(),s2.str().c_str()); \
<em> 37: </em><font color="red"><strong>}</strong></font>
<em> 38: </em>
<em> 39: </em><font color="#1919af"><strong>#define</strong></font> ASM1(code,a) <font color="red"><strong>{</strong></font> \
<em> 40: </em>  ostringstream s1; \
<em> 41: </em>  s1 &lt;&lt; a; \
<em> 42: </em>  code.o(s1.str()); \
<em> 43: </em><font color="red"><strong>}</strong></font>
<em> 44: </em>
<em> 45: </em><font color="#1919af"><strong>#define</strong></font> CMT(code,cmt) <font color="red"><strong>{</strong></font> \
<em> 46: </em>  ostringstream s1; \
<em> 47: </em>  s1 &lt;&lt; cmt; \
<em> 48: </em>  code.c(s1.str()); \
<em> 49: </em><font color="red"><strong>}</strong></font>
<em> 50: </em>
<em> 51: </em><font color="#ffa600"><em>// This class stores compile location information.</em></font>
<em> 52: </em><strong>struct</strong> CompileLoc : public gc <font color="red"><strong>{</strong></font>
<em> 53: </em>  int   _loc;
<em> 54: </em>  Node *_n;   <font color="#ffa600"><em>// 0 =&gt; local (location is stack relative.</em></font>
<em> 55: </em>
<em> 56: </em>  <font color="#ffa600"><em>// Create a global.</em></font>
<em> 57: </em>  CompileLoc(Node *n) : _loc(0), _n(n) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em> 58: </em>  <font color="#ffa600"><em>// Create a local.</em></font>
<em> 59: </em>  CompileLoc(int l) : _loc(l), _n(0) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em> 60: </em><font color="red"><strong>}</strong></font>;
<em> 61: </em>
<em> 62: </em>ostream &amp;operator&lt;&lt; (ostream &amp;o,const CompileLoc &amp;cl)
<em> 63: </em><font color="red"><strong>{</strong></font>
<em> 64: </em>  <strong>if</strong> (cl._n) <font color="red"><strong>{</strong></font>
<em> 65: </em>    o &lt;&lt; cl._n-&gt;name();
<em> 66: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em> 67: </em>    o &lt;&lt; cl._loc &lt;&lt; <font color="red">&quot;(%ebp)&quot;</font>;
<em> 68: </em>  <font color="red"><strong>}</strong></font>
<em> 69: </em>  <strong>return</strong> o;
<em> 70: </em><font color="red"><strong>}</strong></font>
<em> 71: </em>
<em> 72: </em>ostream &amp;operator&lt;&lt; (ostream &amp;o,const CompileLoc *cl)
<em> 73: </em><font color="red"><strong>{</strong></font>
<em> 74: </em>  o &lt;&lt; *cl;
<em> 75: </em>  <strong>return</strong> o;
<em> 76: </em><font color="red"><strong>}</strong></font>
<em> 77: </em>
<em> 78: </em><strong>typedef</strong> list&lt;string&gt; StringList;
<em> 79: </em>
<em> 80: </em><font color="#ffa600"><em>// Shared code generation resources go here.</em></font>
<em> 81: </em>pMutex <strong>class</strong> SharedData : public gc <font color="red"><strong>{</strong></font>
<em> 82: </em>public:
<em> 83: </em>  SharedData(bool print_comments) : 
<em> 84: </em>    _label(0), 
<em> 85: </em>    _strlabel(0), 
<em> 86: </em>    _print_comments(print_comments),
<em> 87: </em>    _globals(print_comments), 
<em> 88: </em>    _strings(print_comments) 
<em> 89: </em>  <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em> 90: </em>
<em> 91: </em>  pNoMutex bool print_comments() const <font color="red"><strong>{</strong></font> <strong>return</strong> _print_comments; <font color="red"><strong>}</strong></font>;
<em> 92: </em>
<em> 93: </em>  string new_label();
<em> 94: </em>  string new_str_label(String s);
<em> 95: </em>
<em> 96: </em>  void global_o(const string &amp;str,const char *comment = 0) <font color="red"><strong>{</strong></font> _globals.o(str,comment); <font color="red"><strong>}</strong></font>;
<em> 97: </em>
<em> 98: </em>  void write(ostream &amp;os);
<em> 99: </em>private:
<em>100: </em>  int _label;
<em>101: </em>  int _strlabel;
<em>102: </em>  bool _print_comments;
<em>103: </em>
<em>104: </em>  <font color="#ffa600"><em>// Global assembly data.</em></font>
<em>105: </em>  AsmStore _globals;
<em>106: </em>  <font color="#ffa600"><em>// Storage of string literals.</em></font>
<em>107: </em>  AsmStore _strings;
<em>108: </em><font color="red"><strong>}</strong></font>;
<em>109: </em>
<em>110: </em><font color="#ffa600"><em>// Per-thread resources go here.</em></font>
<em>111: </em><strong>struct</strong> ThreadData : public gc <font color="red"><strong>{</strong></font>
<em>112: </em>  AsmStore      _code;
<em>113: </em>  StackMachine  _stack;
<em>114: </em>  string        _end_label;
<em>115: </em>  StringList    _break_labels;
<em>116: </em>  StringList    _continue_labels;
<em>117: </em>
<em>118: </em>  ThreadData (bool pc,int base_fp,const string &amp;el) : 
<em>119: </em>    _code(pc), 
<em>120: </em>    _stack(_code,base_fp),
<em>121: </em>    _end_label(el)
<em>122: </em>  <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>123: </em><font color="red"><strong>}</strong></font>;
<em>124: </em>
<em>125: </em>void SharedData::write(ostream &amp;out)
<em>126: </em><font color="red"><strong>{</strong></font>
<em>127: </em>  _globals.write(out);
<em>128: </em>  _strings.write(out);
<em>129: </em><font color="red"><strong>}</strong></font>
<em>130: </em>
<em>131: </em>string SharedData::new_label()
<em>132: </em><font color="red"><strong>{</strong></font>
<em>133: </em>  ostringstream ss;
<em>134: </em>  ss &lt;&lt; <font color="red">&quot;.L&quot;</font> &lt;&lt; _label++;
<em>135: </em>  <strong>return</strong> ss.str();
<em>136: </em><font color="red"><strong>}</strong></font>
<em>137: </em>
<em>138: </em>string SharedData::new_str_label(String s)
<em>139: </em><font color="red"><strong>{</strong></font>
<em>140: </em>  ostringstream ss;
<em>141: </em>  ss &lt;&lt; <font color="red">&quot;LC&quot;</font> &lt;&lt; _strlabel++;
<em>142: </em>  ASM1(_strings,ss.str() &lt;&lt; <font color="red">&quot;:&quot;</font>);
<em>143: </em>  ASM1(_strings,<font color="red">&quot;  .ascii \&quot;&quot;</font> &lt;&lt; s &lt;&lt; <font color="red">&quot;\\0\&quot;&quot;</font>);
<em>144: </em>  <strong>return</strong> ss.str();
<em>145: </em><font color="red"><strong>}</strong></font>
<em>146: </em>
<em>147: </em>CodeGen::CodeGen(bool print_comments) :
<em>148: </em>  _sdata(new SharedData(print_comments)),
<em>149: </em>  _tdata(0)
<em>150: </em><font color="red"><strong>{</strong></font>
<em>151: </em><font color="red"><strong>}</strong></font>
<em>152: </em>
<em>153: </em>CodeGen::CodeGen(const CodeGen &amp;cg) :
<em>154: </em>  _sdata(cg._sdata),
<em>155: </em>  _tdata(0)
<em>156: </em><font color="red"><strong>{</strong></font>
<em>157: </em><font color="red"><strong>}</strong></font>
<em>158: </em>
<em>159: </em>inline AsmStore &amp;CodeGen::code()
<em>160: </em><font color="red"><strong>{</strong></font>
<em>161: </em>  <strong>return</strong> _tdata-&gt;_code;
<em>162: </em><font color="red"><strong>}</strong></font>
<em>163: </em>
<em>164: </em>inline StackMachine &amp;CodeGen::stack()
<em>165: </em><font color="red"><strong>{</strong></font>
<em>166: </em>  <strong>return</strong> _tdata-&gt;_stack;
<em>167: </em><font color="red"><strong>}</strong></font>
<em>168: </em>
<em>169: </em>inline const string &amp;CodeGen::break_label() const 
<em>170: </em><font color="red"><strong>{</strong></font> 
<em>171: </em>  <strong>return</strong> _tdata-&gt;_break_labels.back(); 
<em>172: </em><font color="red"><strong>}</strong></font>
<em>173: </em>
<em>174: </em>inline const string &amp;CodeGen::continue_label() const 
<em>175: </em><font color="red"><strong>{</strong></font> 
<em>176: </em>  <strong>return</strong> _tdata-&gt;_continue_labels.back(); 
<em>177: </em><font color="red"><strong>}</strong></font>
<em>178: </em>
<em>179: </em><font color="#ffa600"><em>// Push new break and continue labels.</em></font>
<em>180: </em>void CodeGen::push_loop_labels(const string &amp;break_label,const string &amp;continue_label)
<em>181: </em><font color="red"><strong>{</strong></font>
<em>182: </em>  _tdata-&gt;_break_labels.push_back(break_label);
<em>183: </em>  _tdata-&gt;_continue_labels.push_back(continue_label);
<em>184: </em><font color="red"><strong>}</strong></font>
<em>185: </em>
<em>186: </em><font color="#ffa600"><em>// Restore old break and continue labels.</em></font>
<em>187: </em>void CodeGen::pop_loop_labels()
<em>188: </em><font color="red"><strong>{</strong></font>
<em>189: </em>  _tdata-&gt;_break_labels.pop_back();
<em>190: </em>  _tdata-&gt;_continue_labels.pop_back();
<em>191: </em><font color="red"><strong>}</strong></font>
<em>192: </em>
<em>193: </em><font color="#ffa600"><em>// This creates a copy of the main generator, to be used</em></font>
<em>194: </em><font color="#ffa600"><em>// by each thread.</em></font>
<em>195: </em>bool CodeGen::codegen_internal(CodeGen codegen,Node *n)
<em>196: </em><font color="red"><strong>{</strong></font>
<em>197: </em>  <strong>try</strong> <font color="red"><strong>{</strong></font>
<em>198: </em>    n-&gt;codegen(codegen);
<em>199: </em>  <font color="red"><strong>}</strong></font>
<em>200: </em>  <strong>catch</strong> (exception &amp;err) <font color="red"><strong>{</strong></font>
<em>201: </em>    cerr &lt;&lt; err.what() &lt;&lt; endl;
<em>202: </em>    <strong>return</strong> false;
<em>203: </em>  <font color="red"><strong>}</strong></font>
<em>204: </em>  <strong>return</strong> true;
<em>205: </em><font color="red"><strong>}</strong></font>
<em>206: </em>
<em>207: </em><font color="#ffa600"><em>// Initiates code generation by spawning threads for each</em></font>
<em>208: </em><font color="#ffa600"><em>// top-level item.</em></font>
<em>209: </em>void CodeGen::genTranslationUnit(TranslationUnit *unit)
<em>210: </em><font color="red"><strong>{</strong></font>
<em>211: </em>  BoolCheck results(make_boolcheck(true));
<em>212: </em>  <strong>for</strong> (NodeList::iterator i = unit-&gt;begin(); i != unit-&gt;end(); ++i) <font color="red"><strong>{</strong></font>
<em>213: </em>    results.push_back(spawn(codegen_internal(*this,*i)));
<em>214: </em>  <font color="red"><strong>}</strong></font>
<em>215: </em>  <font color="#ffa600"><em>// If any of the results are false, we've got an error.</em></font>
<em>216: </em>  <strong>if</strong> (!results.check()) <font color="red"><strong>{</strong></font>
<em>217: </em>    <strong>throw</strong> runtime_error(<font color="red">&quot;Compilation failed.&quot;</font>);
<em>218: </em>  <font color="red"><strong>}</strong></font>
<em>219: </em><font color="red"><strong>}</strong></font>
<em>220: </em>
<em>221: </em><font color="#ffa600"><em>// Does the checking on a single node.</em></font>
<em>222: </em><font color="#ffa600"><em>// Catches any exceptions and treats this as</em></font>
<em>223: </em><font color="#ffa600"><em>// a checking-phase failure.</em></font>
<em>224: </em>bool CodeGen::dochecks_internal(Node *n)
<em>225: </em><font color="red"><strong>{</strong></font>
<em>226: </em>  <strong>try</strong> <font color="red"><strong>{</strong></font>
<em>227: </em>    <font color="#ffa600"><em>// Perform type checking.</em></font>
<em>228: </em>    n-&gt;typecheck();
<em>229: </em>    <font color="#ffa600"><em>// Perform basic flow-control analysis.</em></font>
<em>230: </em>    n-&gt;flowcontrol();
<em>231: </em>  <font color="red"><strong>}</strong></font>
<em>232: </em>  <strong>catch</strong> (exception &amp;err) <font color="red"><strong>{</strong></font>
<em>233: </em>    cerr &lt;&lt; err.what() &lt;&lt; endl;
<em>234: </em>    <strong>return</strong> false;
<em>235: </em>  <font color="red"><strong>}</strong></font>
<em>236: </em>  <strong>return</strong> true;
<em>237: </em><font color="red"><strong>}</strong></font>
<em>238: </em>
<em>239: </em><font color="#ffa600"><em>// Does the checking phase of the compilation process.</em></font>
<em>240: </em><font color="#ffa600"><em>// We spawn a thread for each top-level item, so that checking</em></font>
<em>241: </em><font color="#ffa600"><em>// is done in parallel.</em></font>
<em>242: </em>bool CodeGen::dochecks(TranslationUnit *unit)
<em>243: </em><font color="red"><strong>{</strong></font>
<em>244: </em>  BoolCheck results(make_boolcheck(true));
<em>245: </em>  <strong>for</strong> (NodeList::iterator i = unit-&gt;begin(); i != unit-&gt;end(); ++i) <font color="red"><strong>{</strong></font>
<em>246: </em>    results.push_back(spawn(dochecks_internal( *i )));
<em>247: </em>  <font color="red"><strong>}</strong></font>
<em>248: </em>  <font color="#ffa600"><em>// If any of the results are false, we've got an error.</em></font>
<em>249: </em>  <strong>if</strong> (!results.check()) <font color="red"><strong>{</strong></font>
<em>250: </em>    <strong>return</strong> false;
<em>251: </em>  <font color="red"><strong>}</strong></font>
<em>252: </em>  <strong>return</strong> true;
<em>253: </em><font color="red"><strong>}</strong></font>
<em>254: </em>
<em>255: </em><font color="#ffa600"><em>// Writes global data information to the _globals code store.</em></font>
<em>256: </em>void CodeGen::handleGlobals(Node *unit)
<em>257: </em><font color="red"><strong>{</strong></font>
<em>258: </em>  _sdata-&gt;global_o(<font color="red">&quot;.global_vars:&quot;</font>);
<em>259: </em>  
<em>260: </em>  SymTab *symtab = unit-&gt;symtab();
<em>261: </em>  
<em>262: </em>  <strong>for</strong> (SymTab::const_iterator i = symtab-&gt;begin(); i != symtab-&gt;end(); ++i) <font color="red"><strong>{</strong></font>
<em>263: </em>    <strong>if</strong> (*i) <font color="red"><strong>{</strong></font>
<em>264: </em>      Node *sym = (*i)-&gt;_n;
<em>265: </em>      <font color="#ffa600"><em>// Create a global compile location indicator.</em></font>
<em>266: </em>      sym-&gt;set_compile_loc(new CompileLoc(sym));
<em>267: </em>      <font color="#ffa600"><em>// Add to global data section if it is a variable in this translation unit.</em></font>
<em>268: </em>      <strong>if</strong> (!sym-&gt;type()-&gt;is_function() &amp;&amp; !sym-&gt;is_extern()) <font color="red"><strong>{</strong></font>
<em>269: </em>        ostringstream ss;
<em>270: </em>        ss &lt;&lt; <font color="red">&quot;  .comm &quot;</font> &lt;&lt; sym-&gt;compile_loc() &lt;&lt; <font color="red">&quot;,&quot;</font> &lt;&lt; asm_var_size(sym-&gt;type());
<em>271: </em>        _sdata-&gt;global_o(ss.str(),0);
<em>272: </em>      <font color="red"><strong>}</strong></font>
<em>273: </em>    <font color="red"><strong>}</strong></font>
<em>274: </em>  <font color="red"><strong>}</strong></font>
<em>275: </em><font color="red"><strong>}</strong></font>
<em>276: </em>
<em>277: </em><font color="#ffa600"><em>// Writes all code to the file specified by the string.</em></font>
<em>278: </em>void CodeGen::write(const string &amp;fn,Node *unit) const
<em>279: </em><font color="red"><strong>{</strong></font>
<em>280: </em>  ofstream out(fn.c_str());
<em>281: </em>  <strong>if</strong> (!out) <font color="red"><strong>{</strong></font>
<em>282: </em>    <strong>throw</strong> runtime_error (<font color="red">&quot;Could not open output file &quot;</font>+fn);
<em>283: </em>  <font color="red"><strong>}</strong></font>
<em>284: </em>
<em>285: </em>  out &lt;&lt; <font color="red">&quot;# Generated by minicc\n&quot;</font>
<em>286: </em>      &lt;&lt; <font color="red">&quot;# Copyright Freescale Semiconductor Inc (c)\n&quot;</font>
<em>287: </em>      &lt;&lt; <font color="red">&quot;  .text\n&quot;</font>;
<em>288: </em>
<em>289: </em>  unit-&gt;writecode(out);
<em>290: </em>
<em>291: </em>  _sdata-&gt;write(out);
<em>292: </em><font color="red"><strong>}</strong></font>
<em>293: </em>
<em>294: </em><font color="#ffa600"><em>// Variable size used by the assembler- includes weird multipler.</em></font>
<em>295: </em>inline unsigned CodeGen::asm_var_size(Type *t) 
<em>296: </em><font color="red"><strong>{</strong></font>
<em>297: </em>  <strong>return</strong> t-&gt;size() * WeirdMultiplier;
<em>298: </em><font color="red"><strong>}</strong></font>
<em>299: </em>
<em>300: </em><font color="#ffa600"><em>// Alignment of a type, in bytes.</em></font>
<em>301: </em>inline unsigned CodeGen::calc_var_align(Type *t)
<em>302: </em><font color="red"><strong>{</strong></font>
<em>303: </em>  <strong>return</strong> t-&gt;size();
<em>304: </em><font color="red"><strong>}</strong></font>
<em>305: </em>
<em>306: </em><font color="#ffa600"><em>// Calculate the addresses of all local variables in the</em></font>
<em>307: </em><font color="#ffa600"><em>// function and attach them to their respective symbols in</em></font>
<em>308: </em><font color="#ffa600"><em>// the function's symbol table(s).</em></font>
<em>309: </em>int CodeGen::calc_function_var_addrs(FunctionDefn *fd,int last_fp_loc)
<em>310: </em><font color="red"><strong>{</strong></font>
<em>311: </em>  SymTab *symtab = fd-&gt;symtab();
<em>312: </em>  calc_function_arg_addrs(symtab);
<em>313: </em>  <font color="#ffa600"><em>// There should only be one child scope for a function (the body).</em></font>
<em>314: </em>  <font color="#ffa600"><em>// So we pass it to start off the process.</em></font>
<em>315: </em>  <strong>return</strong> calc_local_var_addrs(*(symtab-&gt;childbegin()),last_fp_loc);
<em>316: </em><font color="red"><strong>}</strong></font>
<em>317: </em>
<em>318: </em><font color="#ffa600"><em>// Calculate the addresses of all the arguments passed to</em></font>
<em>319: </em><font color="#ffa600"><em>// the function.</em></font>
<em>320: </em>void CodeGen::calc_function_arg_addrs(SymTab *symtab)
<em>321: </em><font color="red"><strong>{</strong></font>
<em>322: </em>  assert(symtab);
<em>323: </em>  <font color="#ffa600"><em>// We iterate over the symbols for this level only- these</em></font>
<em>324: </em>  <font color="#ffa600"><em>// should correspond to the function's parameters.</em></font>
<em>325: </em>  int pn = 0;
<em>326: </em>  <strong>for</strong> (SymTab::const_iterator i = symtab-&gt;begin(); i != symtab-&gt;end(); ++i) <font color="red"><strong>{</strong></font>
<em>327: </em>    <strong>if</strong> (*i &amp;&amp; symtab-&gt;is_local(*i)) <font color="red"><strong>{</strong></font>
<em>328: </em>      Node *n = (*i)-&gt;_n;
<em>329: </em>      n-&gt;set_compile_loc(new CompileLoc(WordSize*2+pn*WordSize));
<em>330: </em>      ++pn;
<em>331: </em>      <strong>if</strong> (!n-&gt;is_used()) <font color="red"><strong>{</strong></font>
<em>332: </em>        Warn(n,<font color="red">&quot;Function argument &quot;</font> &lt;&lt; n-&gt;name() &lt;&lt; <font color="red">&quot; is never used.&quot;</font>);
<em>333: </em>      <font color="red"><strong>}</strong></font>
<em>334: </em>    <font color="red"><strong>}</strong></font>
<em>335: </em>  <font color="red"><strong>}</strong></font>  
<em>336: </em><font color="red"><strong>}</strong></font>
<em>337: </em>
<em>338: </em><font color="#ffa600"><em>// Calculate the locations of all the local variables defined</em></font>
<em>339: </em><font color="#ffa600"><em>// in the function's body and all nested scopes therein.</em></font>
<em>340: </em><font color="#ffa600"><em>//</em></font>
<em>341: </em><font color="#ffa600"><em>// This model of allocation assumes a 'worst-case' scenario</em></font>
<em>342: </em><font color="#ffa600"><em>// where all branches and nested scopes of the function are</em></font>
<em>343: </em><font color="#ffa600"><em>// executed; thus the space required for all the local</em></font>
<em>344: </em><font color="#ffa600"><em>// variables is allocated on the process' stack at the</em></font>
<em>345: </em><font color="#ffa600"><em>// beginning of the function.</em></font>
<em>346: </em><font color="#ffa600"><em>// </em></font>
<em>347: </em><font color="#ffa600"><em>// Note, however, that lexical scopes that cannot exist</em></font>
<em>348: </em><font color="#ffa600"><em>// at the same time may overlap in memory.  For instance,</em></font>
<em>349: </em><font color="#ffa600"><em>// examine the following 'if' statement:</em></font>
<em>350: </em><font color="#ffa600"><em>// </em></font>
<em>351: </em><font color="#ffa600"><em>// if (a &gt; 1) {</em></font>
<em>352: </em><font color="#ffa600"><em>//   int i;</em></font>
<em>353: </em><font color="#ffa600"><em>// } else {</em></font>
<em>354: </em><font color="#ffa600"><em>//   int j;</em></font>
<em>355: </em><font color="#ffa600"><em>// }</em></font>
<em>356: </em><font color="#ffa600"><em>//</em></font>
<em>357: </em><font color="#ffa600"><em>// Here 'i' and 'j' will actually occupy the same place in</em></font>
<em>358: </em><font color="#ffa600"><em>// memory because it is impossible for both of them to</em></font>
<em>359: </em><font color="#ffa600"><em>// exist in memory at the same time.</em></font>
<em>360: </em>int CodeGen::calc_local_var_addrs(SymTab *symtab,int last_fp_loc)
<em>361: </em><font color="red"><strong>{</strong></font>
<em>362: </em>  int align, bytes_overboard;
<em>363: </em>  <strong>for</strong> (SymTab::const_iterator i = symtab-&gt;begin(); i != symtab-&gt;end(); ++i) <font color="red"><strong>{</strong></font>
<em>364: </em>    <strong>if</strong> (*i &amp;&amp; symtab-&gt;is_local(*i)) <font color="red"><strong>{</strong></font>
<em>365: </em>      Node *n = (*i)-&gt;_n;
<em>366: </em>      <strong>if</strong> (n-&gt;is_extern()) <font color="red"><strong>{</strong></font>
<em>367: </em>        n-&gt;set_compile_loc(new CompileLoc(n));
<em>368: </em>        <strong>continue</strong>;
<em>369: </em>      <font color="red"><strong>}</strong></font>
<em>370: </em>      last_fp_loc -= n-&gt;type()-&gt;size();
<em>371: </em>      
<em>372: </em>      <font color="#ffa600"><em>// Adjust locatio nfor alignment.</em></font>
<em>373: </em>      align = calc_var_align(n-&gt;type());
<em>374: </em>      bytes_overboard = (-last_fp_loc) % align;
<em>375: </em>      <strong>if</strong> (bytes_overboard) <font color="red"><strong>{</strong></font>
<em>376: </em>        last_fp_loc -= (align - bytes_overboard);
<em>377: </em>      <font color="red"><strong>}</strong></font>
<em>378: </em>      n-&gt;set_compile_loc(new CompileLoc(last_fp_loc));
<em>379: </em>      <strong>if</strong> (!n-&gt;is_used()) <font color="red"><strong>{</strong></font>
<em>380: </em>        Warn(n,<font color="red">&quot;Local variable &quot;</font> &lt;&lt; n-&gt;name() &lt;&lt; <font color="red">&quot; is never used.&quot;</font>);
<em>381: </em>      <font color="red"><strong>}</strong></font>
<em>382: </em>    <font color="red"><strong>}</strong></font>
<em>383: </em>  <font color="red"><strong>}</strong></font>
<em>384: </em>  int max_last_fp = last_fp_loc;
<em>385: </em>  <strong>for</strong> (SymTab::const_children_iterator i = symtab-&gt;childbegin(); i != symtab-&gt;childend(); ++i) <font color="red"><strong>{</strong></font>
<em>386: </em>    int cur_last_fp = calc_local_var_addrs(*i,last_fp_loc);
<em>387: </em>    <strong>if</strong> (cur_last_fp &lt; max_last_fp) <font color="red"><strong>{</strong></font>
<em>388: </em>      max_last_fp = cur_last_fp;
<em>389: </em>    <font color="red"><strong>}</strong></font>
<em>390: </em>  <font color="red"><strong>}</strong></font>
<em>391: </em>  <font color="#ffa600"><em>// Adjust location for alignment, to keep the stack</em></font>
<em>392: </em>  <font color="#ffa600"><em>// alignment on a word-sized boundary.</em></font>
<em>393: </em>  PointerType pt;
<em>394: </em>  align = calc_var_align(&amp;pt);
<em>395: </em>  bytes_overboard = (-max_last_fp) % align;
<em>396: </em>  <strong>if</strong> (bytes_overboard) <font color="red"><strong>{</strong></font>
<em>397: </em>    max_last_fp -= (align - bytes_overboard);
<em>398: </em>  <font color="red"><strong>}</strong></font>
<em>399: </em>  <strong>return</strong> max_last_fp;
<em>400: </em><font color="red"><strong>}</strong></font>
<em>401: </em>
<em>402: </em>const char *CodeGen::binop(int op) const
<em>403: </em><font color="red"><strong>{</strong></font>
<em>404: </em>  <strong>switch</strong> (op) <font color="red"><strong>{</strong></font>
<em>405: </em>  <strong>case</strong> EQ:
<em>406: </em>    <strong>return</strong> <font color="red">&quot;sete&quot;</font>;
<em>407: </em>  <strong>case</strong> NOT_EQ:
<em>408: </em>    <strong>return</strong> <font color="red">&quot;setne&quot;</font>;
<em>409: </em>  <strong>case</strong> GREATER_EQ:
<em>410: </em>    <strong>return</strong> <font color="red">&quot;setge&quot;</font>;
<em>411: </em>  <strong>case</strong> LESS_EQ:
<em>412: </em>    <strong>return</strong> <font color="red">&quot;setle&quot;</font>;
<em>413: </em>  <strong>case</strong> GREATER:
<em>414: </em>    <strong>return</strong> <font color="red">&quot;setg&quot;</font>;
<em>415: </em>  <strong>case</strong> LESS:
<em>416: </em>    <strong>return</strong> <font color="red">&quot;setl&quot;</font>;
<em>417: </em>  <strong>case</strong> PLUS:
<em>418: </em>  <strong>case</strong> ADD_ASSIGN:
<em>419: </em>    <strong>return</strong> <font color="red">&quot;add&quot;</font>;
<em>420: </em>  <strong>case</strong> MINUS:
<em>421: </em>  <strong>case</strong> SUB_ASSIGN:
<em>422: </em>    <strong>return</strong> <font color="red">&quot;sub&quot;</font>;
<em>423: </em>  <strong>case</strong> ASTERISK:
<em>424: </em>    <strong>return</strong> <font color="red">&quot;imul&quot;</font>;
<em>425: </em>  <strong>case</strong> ASSIGN:
<em>426: </em>    <strong>return</strong> <font color="red">&quot;mov&quot;</font>;
<em>427: </em>  default:
<em>428: </em>    Error1(<font color="red">&quot;Unknown binary operator &quot;</font> &lt;&lt; op);
<em>429: </em>  <font color="red"><strong>}</strong></font>
<em>430: </em><font color="red"><strong>}</strong></font>
<em>431: </em>
<em>432: </em>string CodeGen::new_label()
<em>433: </em><font color="red"><strong>{</strong></font>
<em>434: </em>  <strong>return</strong> _sdata-&gt;new_label();
<em>435: </em><font color="red"><strong>}</strong></font>
<em>436: </em>
<em>437: </em>string CodeGen::new_str_label(String s)
<em>438: </em><font color="red"><strong>{</strong></font>
<em>439: </em>  <strong>return</strong> _sdata-&gt;new_str_label(s);
<em>440: </em><font color="red"><strong>}</strong></font>
<em>441: </em>
<em>442: </em><font color="#ffa600"><em>// Pops the top value from the stack machine's stack and</em></font>
<em>443: </em><font color="#ffa600"><em>// discard it.  This is used when a statement has a return</em></font>
<em>444: </em><font color="#ffa600"><em>// value (for instance, the line 'a = b + 1;') and its</em></font>
<em>445: </em><font color="#ffa600"><em>// return value has been pushed onto the stack but there's</em></font>
<em>446: </em><font color="#ffa600"><em>// nothing to pop it off.</em></font>
<em>447: </em>void CodeGen::empty_stack(Node *n)
<em>448: </em><font color="red"><strong>{</strong></font>
<em>449: </em>  <strong>if</strong> (!stack().empty()) <font color="red"><strong>{</strong></font>
<em>450: </em>    stack().pop(n-&gt;type());
<em>451: </em>    stack().done();
<em>452: </em>    <strong>if</strong> (!stack().empty()) <font color="red"><strong>{</strong></font>
<em>453: </em>      <strong>throw</strong> runtime_error(<font color="red">&quot;Register stack isn't empty after pop in empty_stack().&quot;</font>);
<em>454: </em>    <font color="red"><strong>}</strong></font>
<em>455: </em>  <font color="red"><strong>}</strong></font>
<em>456: </em><font color="red"><strong>}</strong></font>
<em>457: </em>
<em>458: </em><font color="#ffa600"><em>// Visit the node and then empty the stack machine of the</em></font>
<em>459: </em><font color="#ffa600"><em>// node's return value, if one exists.</em></font>
<em>460: </em>void CodeGen::accept_and_empty_stack(Node *n)
<em>461: </em><font color="red"><strong>{</strong></font>
<em>462: </em>  n-&gt;codegen(*this);
<em>463: </em>  empty_stack(n);
<em>464: </em><font color="red"><strong>}</strong></font>
<em>465: </em>
<em>466: </em><font color="#ffa600"><em>// Handle an arbitrary list of objects.</em></font>
<em>467: </em>void CodeGen::genList(NodeList *nl)
<em>468: </em><font color="red"><strong>{</strong></font>
<em>469: </em>  <strong>for</strong> (NodeList::iterator i = nl-&gt;begin(); i != nl-&gt;end(); ++i) <font color="red"><strong>{</strong></font>
<em>470: </em>    (*i)-&gt;codegen(*this);
<em>471: </em>  <font color="red"><strong>}</strong></font>
<em>472: </em><font color="red"><strong>}</strong></font>
<em>473: </em>
<em>474: </em><font color="#ffa600"><em>// Handle a statement list.</em></font>
<em>475: </em>void CodeGen::genStatementList(StatementList *sl)
<em>476: </em><font color="red"><strong>{</strong></font>
<em>477: </em>  <strong>for</strong> (NodeList::iterator i = sl-&gt;begin(); i != sl-&gt;end(); ++i) <font color="red"><strong>{</strong></font>
<em>478: </em>    accept_and_empty_stack(*i);
<em>479: </em>  <font color="red"><strong>}</strong></font>
<em>480: </em><font color="red"><strong>}</strong></font>
<em>481: </em>
<em>482: </em><font color="#ffa600"><em>// Handle a function definition.</em></font>
<em>483: </em>void CodeGen::genFunctionDefn(FunctionDefn *fd)
<em>484: </em><font color="red"><strong>{</strong></font>
<em>485: </em>  int stack_frame_size = calc_function_var_addrs(fd,0);
<em>486: </em>
<em>487: </em>  <font color="#ffa600"><em>// This creates the stack pointer and the code repository.</em></font>
<em>488: </em>  _tdata = new ThreadData(_sdata-&gt;print_comments(),
<em>489: </em>                          stack_frame_size,
<em>490: </em>                          new_label() + <font color="red">&quot;_function_end&quot;</font>);
<em>491: </em>
<em>492: </em>  AsmStore preamble;
<em>493: </em>
<em>494: </em>  CMT(preamble,<font color="red">&quot;---- BEGIN FUNCTION:  &quot;</font> &lt;&lt; fd-&gt;name() &lt;&lt; <font color="red">&quot; ----&quot;</font>);
<em>495: </em>  CMT(preamble,<font color="red">&quot;Function type:  &quot;</font> &lt;&lt; fd-&gt;type());
<em>496: </em>
<em>497: </em>  <strong>if</strong> (!fd-&gt;is_static()) <font color="red"><strong>{</strong></font>
<em>498: </em>    ASM1(preamble,<font color="red">&quot;  .global &quot;</font> &lt;&lt; fd-&gt;name());
<em>499: </em>  <font color="red"><strong>}</strong></font>
<em>500: </em>  ASM1(preamble,fd-&gt;name() &lt;&lt; <font color="red">&quot;:&quot;</font>);
<em>501: </em>  ASM(preamble,<font color="red">&quot;  pushl %ebp&quot;</font>,<font color="red">&quot;Save old frame pointer.&quot;</font>);
<em>502: </em>  ASM(preamble,<font color="red">&quot;  movl %esp, %ebp&quot;</font>,<font color="red">&quot;Set new frame pointer.&quot;</font>);
<em>503: </em>
<em>504: </em>  fd-&gt;body()-&gt;codegen(*this);
<em>505: </em>
<em>506: </em>  <font color="#ffa600"><em>// Figure out the final size of the stack frame, taking into</em></font>
<em>507: </em>  <font color="#ffa600"><em>// account the stack machine's temporary variables, and</em></font>
<em>508: </em>  <font color="#ffa600"><em>// insert the code at the beginning of the function.</em></font>
<em>509: </em>  <strong>if</strong> (stack().get_max_fp()) <font color="red"><strong>{</strong></font>
<em>510: </em>    ASM(preamble,<font color="red">&quot;  subl $&quot;</font> &lt;&lt; -stack().get_max_fp() &lt;&lt; <font color="red">&quot;, %esp&quot;</font>,
<em>511: </em>        <font color="red">&quot;Allocate space for local+temp variables.&quot;</font>);
<em>512: </em>  <font color="red"><strong>}</strong></font>
<em>513: </em>
<em>514: </em>  <font color="#ffa600"><em>// Save any callee-save registers that may have been used.</em></font>
<em>515: </em>  stack().save_callee_saves(preamble);
<em>516: </em>
<em>517: </em>  <font color="#ffa600"><em>// Add previously generated code.</em></font>
<em>518: </em>  code().splice_front(preamble);
<em>519: </em>
<em>520: </em>  code().o(_tdata-&gt;_end_label + <font color="red">&quot;:&quot;</font>);
<em>521: </em>
<em>522: </em>  <font color="#ffa600"><em>// Restore any callee-save registers that may have been used.</em></font>
<em>523: </em>  stack().load_callee_saves();
<em>524: </em>  ASM(code(),<font color="red">&quot;  movl %ebp, %esp&quot;</font>,<font color="red">&quot;Deallocate stack frame.&quot;</font>);
<em>525: </em>  ASM(code(),<font color="red">&quot;  popl %ebp&quot;</font>,<font color="red">&quot;Restore old stack frame.&quot;</font>);
<em>526: </em>  ASM1(code(),<font color="red">&quot;  ret&quot;</font>);
<em>527: </em>
<em>528: </em>  CMT(code(),<font color="red">&quot;---- END FUNCTION:  &quot;</font> &lt;&lt; fd-&gt;name() &lt;&lt; <font color="red">&quot; ----&quot;</font>);
<em>529: </em>
<em>530: </em>  fd-&gt;setcode(&amp;code());
<em>531: </em><font color="red"><strong>}</strong></font>
<em>532: </em>
<em>533: </em>void CodeGen::genCompoundStatement(CompoundStatement *cs)
<em>534: </em><font color="red"><strong>{</strong></font>
<em>535: </em>  cs-&gt;statement_list()-&gt;codegen(*this);
<em>536: </em><font color="red"><strong>}</strong></font>
<em>537: </em>
<em>538: </em><font color="#ffa600"><em>// Generate code for a conditional.</em></font>
<em>539: </em>void CodeGen::genConditional(IfStatement *ifs)
<em>540: </em><font color="red"><strong>{</strong></font>
<em>541: </em>  string done_label = new_label() + <font color="red">&quot;_done&quot;</font>;
<em>542: </em>  string else_label = (ifs-&gt;else_blk()) ?
<em>543: </em>    new_label() + <font color="red">&quot;_else&quot;</font>
<em>544: </em>    : done_label;
<em>545: </em>
<em>546: </em>  code().c(<font color="red">&quot;IF statement - begin&quot;</font>);
<em>547: </em>  ifs-&gt;expr()-&gt;codegen(*this);
<em>548: </em>  Operand comparer = stack().pop();
<em>549: </em>  stack().done();
<em>550: </em>  ASM(code(),<font color="red">&quot;  testl &quot;</font> &lt;&lt; comparer &lt;&lt; <font color="red">&quot;, &quot;</font> &lt;&lt; comparer,<font color="red">&quot;Test the result.&quot;</font>);
<em>551: </em>  ASM(code(),<font color="red">&quot;  jz &quot;</font> &lt;&lt; else_label,<font color="red">&quot;If result is zero, jump to else clause.&quot;</font>);
<em>552: </em>
<em>553: </em>  CMT(code(),<font color="red">&quot;IF statement - THEN clause - begin&quot;</font>);
<em>554: </em>  accept_and_empty_stack(ifs-&gt;then_blk());
<em>555: </em>
<em>556: </em>  CMT(code(),<font color="red">&quot;IF statement - THEN clause - end&quot;</font>);
<em>557: </em>  ASM1(code(),<font color="red">&quot;  jmp &quot;</font> &lt;&lt; done_label);
<em>558: </em>  <strong>if</strong> (Node *else_blk = ifs-&gt;else_blk()) <font color="red"><strong>{</strong></font>
<em>559: </em>    CMT(code(),<font color="red">&quot;IF statement - ELSE clause - begin&quot;</font>);
<em>560: </em>    ASM1(code(),else_label &lt;&lt; <font color="red">&quot;:&quot;</font>);
<em>561: </em>    accept_and_empty_stack(else_blk);
<em>562: </em>    CMT(code(),<font color="red">&quot;IF statement - ELSE clause - end&quot;</font>);
<em>563: </em>  <font color="red"><strong>}</strong></font>
<em>564: </em>  ASM1(code(),done_label &lt;&lt; <font color="red">&quot;:&quot;</font>);
<em>565: </em>  code().c(<font color="red">&quot;IF statement - end&quot;</font>);
<em>566: </em><font color="red"><strong>}</strong></font>
<em>567: </em>
<em>568: </em><font color="#ffa600"><em>// Generate code for a while loop.</em></font>
<em>569: </em>void CodeGen::genWhileLoop(WhileLoop *wl)
<em>570: </em><font color="red"><strong>{</strong></font>
<em>571: </em>  string test_label = new_label() + <font color="red">&quot;_test&quot;</font>;
<em>572: </em>  string done_label = new_label() + <font color="red">&quot;_done&quot;</font>;
<em>573: </em>
<em>574: </em>  push_loop_labels(done_label,test_label);
<em>575: </em>
<em>576: </em>  CMT(code(),<font color="red">&quot;WHILE loop - begin&quot;</font>);
<em>577: </em>
<em>578: </em>  ASM1(code(),test_label &lt;&lt; <font color="red">&quot;:&quot;</font>);
<em>579: </em>  wl-&gt;expr()-&gt;codegen(*this);
<em>580: </em>
<em>581: </em>  Operand comparer = stack().pop();
<em>582: </em>  stack().done();
<em>583: </em>
<em>584: </em>  ASM(code(),<font color="red">&quot;  testl &quot;</font> &lt;&lt; comparer &lt;&lt; <font color="red">&quot;, &quot;</font> &lt;&lt; comparer,<font color="red">&quot;Test the result.&quot;</font>);
<em>585: </em>  ASM(code(),<font color="red">&quot;  jz &quot;</font> &lt;&lt; done_label,<font color="red">&quot;If result is zero, leave while loop.&quot;</font>);
<em>586: </em>  accept_and_empty_stack(wl-&gt;stmt());
<em>587: </em>  ASM(code(),<font color="red">&quot;  jmp &quot;</font> &lt;&lt; test_label,<font color="red">&quot;Jump to start of while loop.&quot;</font>);
<em>588: </em>  ASM1(code(),done_label &lt;&lt; <font color="red">&quot;:&quot;</font>);
<em>589: </em>  
<em>590: </em>  CMT(code(),<font color="red">&quot;WHILE loop - end&quot;</font>);
<em>591: </em>  pop_loop_labels();
<em>592: </em><font color="red"><strong>}</strong></font>
<em>593: </em>
<em>594: </em><font color="#ffa600"><em>// Generate code for a for loop.</em></font>
<em>595: </em>void CodeGen::genForLoop(ForLoop *fl)
<em>596: </em><font color="red"><strong>{</strong></font>
<em>597: </em>  string test_label = new_label() + <font color="red">&quot;_test&quot;</font>;
<em>598: </em>  string done_label = new_label() + <font color="red">&quot;_done&quot;</font>;
<em>599: </em>
<em>600: </em>  push_loop_labels(done_label,test_label);
<em>601: </em>
<em>602: </em>  CMT(code(),<font color="red">&quot;FOR loop - begin&quot;</font>);
<em>603: </em>
<em>604: </em>  accept_and_empty_stack(fl-&gt;begin());
<em>605: </em>  
<em>606: </em>  ASM1(code(),test_label &lt;&lt; <font color="red">&quot;:&quot;</font>);
<em>607: </em>  fl-&gt;expr()-&gt;codegen(*this);
<em>608: </em>
<em>609: </em>  Operand comparer = stack().pop();
<em>610: </em>  stack().done();
<em>611: </em>
<em>612: </em>  ASM(code(),<font color="red">&quot;  testl &quot;</font> &lt;&lt; comparer &lt;&lt; <font color="red">&quot;, &quot;</font> &lt;&lt; comparer,<font color="red">&quot;Test the result.&quot;</font>);
<em>613: </em>  ASM(code(),<font color="red">&quot;  jz &quot;</font> &lt;&lt; done_label,<font color="red">&quot;If result is zero, leave for loop.&quot;</font>);
<em>614: </em>  accept_and_empty_stack(fl-&gt;stmt());
<em>615: </em>  accept_and_empty_stack(fl-&gt;end());
<em>616: </em>
<em>617: </em>  ASM(code(),<font color="red">&quot;  jmp &quot;</font> &lt;&lt; test_label,<font color="red">&quot;Jump to start of for loop.&quot;</font>);
<em>618: </em>  ASM1(code(),done_label &lt;&lt; <font color="red">&quot;:&quot;</font>);
<em>619: </em>  
<em>620: </em>  CMT(code(),<font color="red">&quot;FOR loop - end&quot;</font>);
<em>621: </em>  pop_loop_labels();
<em>622: </em><font color="red"><strong>}</strong></font>
<em>623: </em>
<em>624: </em><font color="#ffa600"><em>// Generate code for a break statement.</em></font>
<em>625: </em>void CodeGen::genBreak(BreakStatement *)
<em>626: </em><font color="red"><strong>{</strong></font>
<em>627: </em>  ASM(code(),<font color="red">&quot;  jmp &quot;</font> &lt;&lt; break_label(),
<em>628: </em>      <font color="red">&quot;Loop:  break statement.&quot;</font>);
<em>629: </em><font color="red"><strong>}</strong></font>
<em>630: </em>
<em>631: </em><font color="#ffa600"><em>// Generate code for a continue statement.</em></font>
<em>632: </em>void CodeGen::genContinue(ContinueStatement *)
<em>633: </em><font color="red"><strong>{</strong></font>
<em>634: </em>  ASM(code(),<font color="red">&quot;  jmp &quot;</font> &lt;&lt; continue_label(),
<em>635: </em>      <font color="red">&quot;Loop:  continue statement.&quot;</font>);
<em>636: </em><font color="red"><strong>}</strong></font>
<em>637: </em>
<em>638: </em><font color="#ffa600"><em>// Generate code for a string literal.</em></font>
<em>639: </em>void CodeGen::genStringLiteral(StringLiteral *sl)
<em>640: </em><font color="red"><strong>{</strong></font>
<em>641: </em>  string label_str = new_str_label(sl-&gt;get());
<em>642: </em>  
<em>643: </em>  ASM(code(),<font color="red">&quot;  movl $&quot;</font> &lt;&lt; label_str 
<em>644: </em>      &lt;&lt; <font color="red">&quot;, &quot;</font> &lt;&lt; stack().push(sl-&gt;type()),
<em>645: </em>      <font color="red">&quot;Get addr of string literal.&quot;</font>);
<em>646: </em><font color="red"><strong>}</strong></font>
<em>647: </em>
<em>648: </em><font color="#ffa600"><em>// Generate code for a numeric constant.</em></font>
<em>649: </em>void CodeGen::genConst(Const *c)
<em>650: </em><font color="red"><strong>{</strong></font>
<em>651: </em>  ASM(code(),<font color="red">&quot;  movl $&quot;</font> &lt;&lt; c-&gt;value() 
<em>652: </em>      &lt;&lt; <font color="red">&quot;, &quot;</font> &lt;&lt; stack().push(c-&gt;type()),
<em>653: </em>      <font color="red">&quot;Load numeric constant &quot;</font> &lt;&lt; c-&gt;value());
<em>654: </em><font color="red"><strong>}</strong></font>
<em>655: </em>
<em>656: </em><font color="#ffa600"><em>// Generate code for a variable.</em></font>
<em>657: </em>void CodeGen::genId(Id *id)
<em>658: </em><font color="red"><strong>{</strong></font>
<em>659: </em>  <font color="#ffa600"><em>// If we're only supposed to push our address on the</em></font>
<em>660: </em>  <font color="#ffa600"><em>// stack, not our actual value, do that and exit.</em></font>
<em>661: </em>  Node *symbol = id-&gt;symbol();
<em>662: </em>  <strong>if</strong> (id-&gt;output_addr()) <font color="red"><strong>{</strong></font>
<em>663: </em>    ASM(code(),<font color="red">&quot;  leal &quot;</font> &lt;&lt; symbol-&gt;compile_loc() &lt;&lt; <font color="red">&quot;, &quot;</font>
<em>664: </em>        &lt;&lt; stack().push(),
<em>665: </em>        <font color="red">&quot;Get address of &quot;</font> &lt;&lt; symbol-&gt;name());
<em>666: </em>    <strong>return</strong>;
<em>667: </em>  <font color="red"><strong>}</strong></font>
<em>668: </em>  const char *inst = (id-&gt;type()-&gt;size() == CharSize) ? <font color="red">&quot;movzbl&quot;</font> : <font color="red">&quot;movl&quot;</font>;
<em>669: </em>  ASM(code(),<font color="red">&quot;  &quot;</font> &lt;&lt; inst &lt;&lt; <font color="red">&quot; &quot;</font> &lt;&lt; symbol-&gt;compile_loc() &lt;&lt; <font color="red">&quot;, &quot;</font> 
<em>670: </em>      &lt;&lt; stack().push(id-&gt;type()),<font color="red">&quot;Get value of &quot;</font> &lt;&lt; symbol-&gt;name());  
<em>671: </em><font color="red"><strong>}</strong></font>
<em>672: </em>
<em>673: </em><font color="#ffa600"><em>// Generate code for an array expression.</em></font>
<em>674: </em>void CodeGen::genArrayExpression(ArrayExpression *ae)
<em>675: </em><font color="red"><strong>{</strong></font>
<em>676: </em>  ae-&gt;expr()-&gt;codegen(*this);
<em>677: </em>  ae-&gt;index()-&gt;codegen(*this);
<em>678: </em>
<em>679: </em>  Operand reg_index = stack().pop(ae-&gt;index()-&gt;type());
<em>680: </em>  Operand reg_expr  = stack().pop(ae-&gt;expr()-&gt;type());
<em>681: </em>  Operand reg_to = stack().push(ae-&gt;type());
<em>682: </em>  int size = ae-&gt;type()-&gt;size();
<em>683: </em>
<em>684: </em>  ostringstream addr_str;
<em>685: </em>  addr_str &lt;&lt; <font color="red">&quot;(&quot;</font> &lt;&lt; reg_expr &lt;&lt; <font color="red">&quot;,&quot;</font> &lt;&lt; reg_index &lt;&lt; <font color="red">&quot;,&quot;</font> &lt;&lt; size &lt;&lt; <font color="red">&quot;)&quot;</font>;
<em>686: </em>  stack().done();
<em>687: </em>
<em>688: </em>  <strong>if</strong> (ae-&gt;output_addr()) <font color="red"><strong>{</strong></font>
<em>689: </em>    ASM(code(),<font color="red">&quot;  leal &quot;</font> &lt;&lt; addr_str.str() &lt;&lt; <font color="red">&quot;, &quot;</font> &lt;&lt; reg_to,
<em>690: </em>        <font color="red">&quot;Load address of pointer array index.&quot;</font>);
<em>691: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em>692: </em>    const char *inst = (ae-&gt;type()-&gt;size() == CharSize) ? <font color="red">&quot;movzbl&quot;</font> : <font color="red">&quot;movl&quot;</font>;
<em>693: </em>    ASM(code(),<font color="red">&quot;  &quot;</font> &lt;&lt; inst &lt;&lt; <font color="red">&quot; &quot;</font> &lt;&lt; addr_str.str() &lt;&lt; <font color="red">&quot;, &quot;</font> &lt;&lt; reg_to,
<em>694: </em>        <font color="red">&quot;Pointer array index dereference.&quot;</font>);
<em>695: </em>  <font color="red"><strong>}</strong></font>
<em>696: </em><font color="red"><strong>}</strong></font>
<em>697: </em>
<em>698: </em><font color="#ffa600"><em>// Accept the given node and pop its value into a register and</em></font>
<em>699: </em><font color="#ffa600"><em>// return the register.  Implicit type conversion is performed,</em></font>
<em>700: </em><font color="#ffa600"><em>// if necessary, by the stack machine.</em></font>
<em>701: </em><font color="#ffa600"><em>//</em></font>
<em>702: </em><font color="#ffa600"><em>// Also, if the node is determined to be a numeric constant,</em></font>
<em>703: </em><font color="#ffa600"><em>// the literal value of the constant (e.g., '$15') is returned,</em></font>
<em>704: </em><font color="#ffa600"><em>// for purposes of optimization.</em></font>
<em>705: </em>Operand CodeGen::accept_and_pop(Node *n)
<em>706: </em><font color="red"><strong>{</strong></font>
<em>707: </em>  <strong>if</strong> (n-&gt;is_const()) <font color="red"><strong>{</strong></font>
<em>708: </em>    <strong>return</strong> Operand(n-&gt;value(),Operand::Immed);
<em>709: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em>710: </em>    n-&gt;codegen(*this);
<em>711: </em>    <strong>return</strong> stack().pop(n-&gt;coerce_to_type());
<em>712: </em>  <font color="red"><strong>}</strong></font>
<em>713: </em><font color="red"><strong>}</strong></font>
<em>714: </em>
<em>715: </em><font color="#ffa600"><em>// Generate code for a function call.</em></font>
<em>716: </em>void CodeGen::genFunctionExpression(FunctionExpression *fe)
<em>717: </em><font color="red"><strong>{</strong></font>
<em>718: </em>  Node *symbol = fe-&gt;function()-&gt;symbol();
<em>719: </em>  CMT(code(),<font color="red">&quot;FUNCTION CALL to &quot;</font> &lt;&lt; symbol-&gt;name() &lt;&lt; <font color="red">&quot;() - begin&quot;</font>);
<em>720: </em>
<em>721: </em>  <font color="#ffa600"><em>// If we're using any caller-save registers, free them up.</em></font>
<em>722: </em>  stack().save_caller_saves();
<em>723: </em>
<em>724: </em>  <font color="#ffa600"><em>// Push args on in reverse order.</em></font>
<em>725: </em>  NodeList &amp;args = fe-&gt;get_arglist();
<em>726: </em>  int argnum = args.size();
<em>727: </em>  <strong>for</strong> (NodeList::reverse_iterator i = args.rbegin(); i != args.rend(); ++i) <font color="red"><strong>{</strong></font>
<em>728: </em>    Operand arg_reg = accept_and_pop(*i);
<em>729: </em>    ASM(code(),<font color="red">&quot;  pushl &quot;</font> &lt;&lt; arg_reg,<font color="red">&quot;Push arg &quot;</font> &lt;&lt; argnum);
<em>730: </em>    stack().done();
<em>731: </em>    --argnum;
<em>732: </em>  <font color="red"><strong>}</strong></font>
<em>733: </em>
<em>734: </em>  ASM(code(),<font color="red">&quot;  call &quot;</font> &lt;&lt; symbol-&gt;compile_loc(),
<em>735: </em>      <font color="red">&quot;Call &quot;</font> &lt;&lt; symbol-&gt;name() &lt;&lt; <font color="red">&quot;()&quot;</font>);
<em>736: </em>
<em>737: </em>  <font color="#ffa600"><em>// The function will place its return value in register %eax.</em></font>
<em>738: </em>  <font color="#ffa600"><em>// So, we'll push a register from the stack and ask it to give</em></font>
<em>739: </em>  <font color="#ffa600"><em>// us %eax.</em></font>
<em>740: </em>  Operand result = stack().push(symbol-&gt;type()-&gt;get_return_type(),Operand::eax);
<em>741: </em>  
<em>742: </em>  <font color="#ffa600"><em>// If we got eax, don't do anything, because our return</em></font>
<em>743: </em>  <font color="#ffa600"><em>// value is already in there.  Otherwise, move it.</em></font>
<em>744: </em>  <font color="#ffa600"><em>//</em></font>
<em>745: </em>  <font color="#ffa600"><em>// (Note that with current implementationm, we should always</em></font>
<em>746: </em>  <font color="#ffa600"><em>// get %eax).</em></font>
<em>747: </em>  <strong>if</strong> (result != Operand(Operand::eax)) <font color="red"><strong>{</strong></font>
<em>748: </em>    ASM(code(),<font color="red">&quot;  movl %eax, &quot;</font> &lt;&lt; result,<font color="red">&quot;Copy return value.&quot;</font>);
<em>749: </em>  <font color="red"><strong>}</strong></font>
<em>750: </em>  int arg_stack_size = args.size() * WordSize;
<em>751: </em>
<em>752: </em>  <strong>if</strong> (arg_stack_size &gt; 0) <font color="red"><strong>{</strong></font>
<em>753: </em>    ASM(code(),<font color="red">&quot;  addl $&quot;</font> &lt;&lt; arg_stack_size &lt;&lt; <font color="red">&quot;, %esp&quot;</font>,
<em>754: </em>        <font color="red">&quot;Deallocate argument stack.&quot;</font>);
<em>755: </em>  <font color="red"><strong>}</strong></font>
<em>756: </em>
<em>757: </em>  CMT(code(),<font color="red">&quot;FUNCTION CALL to &quot;</font> &lt;&lt; symbol-&gt;name() &lt;&lt; <font color="red">&quot;() - end&quot;</font>);
<em>758: </em><font color="red"><strong>}</strong></font>
<em>759: </em>
<em>760: </em><font color="#ffa600"><em>// Generate code for a return statement.</em></font>
<em>761: </em>void CodeGen::genReturn(ReturnStatement *rs)
<em>762: </em><font color="red"><strong>{</strong></font>
<em>763: </em>  Operand return_reg = accept_and_pop(rs-&gt;expr());
<em>764: </em>
<em>765: </em>  ASM(code(),<font color="red">&quot;  movl &quot;</font> &lt;&lt; return_reg &lt;&lt; <font color="red">&quot;, %eax&quot;</font>,<font color="red">&quot;Set return value.&quot;</font>);
<em>766: </em>  ASM(code(),<font color="red">&quot;  jmp &quot;</font> &lt;&lt; _tdata-&gt;_end_label,<font color="red">&quot;Exit function.&quot;</font>);
<em>767: </em>
<em>768: </em>  stack().done();
<em>769: </em><font color="red"><strong>}</strong></font>
<em>770: </em>
<em>771: </em><font color="#ffa600"><em>// Returns a type suffix based upon a supplied type size.</em></font>
<em>772: </em>const char *type_suffix(int size)
<em>773: </em><font color="red"><strong>{</strong></font>
<em>774: </em>  <strong>return</strong> (size == 4) ? <font color="red">&quot;l&quot;</font> : <font color="red">&quot;b&quot;</font>;
<em>775: </em><font color="red"><strong>}</strong></font>
<em>776: </em>
<em>777: </em><font color="#ffa600"><em>// Performs an assignment operation (=, +=, etc) on the given</em></font>
<em>778: </em><font color="#ffa600"><em>// Binop node.</em></font>
<em>779: </em>void CodeGen::binop_assign(Binop *bo)
<em>780: </em><font color="red"><strong>{</strong></font>
<em>781: </em>  bo-&gt;left()-&gt;codegen(*this);
<em>782: </em>  Operand right_reg = accept_and_pop(bo-&gt;right());
<em>783: </em>  Operand left_reg = stack().pop();
<em>784: </em>
<em>785: </em>  string instr = string(binop(bo-&gt;op())) + type_suffix(bo-&gt;type()-&gt;size());
<em>786: </em>
<em>787: </em>  bool is_char = (bo-&gt;type()-&gt;size() == CharSize);
<em>788: </em>
<em>789: </em>  <strong>if</strong> (is_char) <font color="red"><strong>{</strong></font>
<em>790: </em>    right_reg.setlo();
<em>791: </em>  <font color="red"><strong>}</strong></font>
<em>792: </em>
<em>793: </em>  ASM(code(),<font color="red">&quot;  &quot;</font> &lt;&lt; instr &lt;&lt; <font color="red">&quot; &quot;</font> &lt;&lt; right_reg &lt;&lt; <font color="red">&quot;, (&quot;</font> &lt;&lt; left_reg &lt;&lt; <font color="red">&quot;)&quot;</font>,
<em>794: </em>      <font color="red">&quot;Perform assignment '&quot;</font> &lt;&lt; bo-&gt;op_str() &lt;&lt; <font color="red">&quot;'&quot;</font>);
<em>795: </em>
<em>796: </em>  <font color="#ffa600"><em>// Note:  Very inefficient code, especially if result isn't used afterwards.</em></font>
<em>797: </em>  const char *inst = (is_char) ? <font color="red">&quot;movzbl&quot;</font> : <font color="red">&quot;movl&quot;</font>;
<em>798: </em>  ASM(code(),<font color="red">&quot;  &quot;</font> &lt;&lt; inst &lt;&lt; <font color="red">&quot; (&quot;</font> &lt;&lt; left_reg &lt;&lt; <font color="red">&quot;), &quot;</font> &lt;&lt; stack().push(bo-&gt;type()),
<em>799: </em>      <font color="red">&quot;Copy assignment result to register.&quot;</font>);
<em>800: </em>  stack().done();
<em>801: </em><font color="red"><strong>}</strong></font>
<em>802: </em>
<em>803: </em><font color="#ffa600"><em>// Performs an arithmetic operation (+, -, etc) on the given</em></font>
<em>804: </em><font color="#ffa600"><em>// Binop node.</em></font>
<em>805: </em>void CodeGen::binop_arith(Binop *bo)
<em>806: </em><font color="red"><strong>{</strong></font>
<em>807: </em>  bo-&gt;left()-&gt;codegen(*this);
<em>808: </em>  Operand right_reg = accept_and_pop(bo-&gt;right());
<em>809: </em>  Operand left_reg = stack().pop(bo-&gt;left()-&gt;coerce_to_type());
<em>810: </em>
<em>811: </em>  string instr = string(binop(bo-&gt;op())) + type_suffix(bo-&gt;type()-&gt;size());  
<em>812: </em>
<em>813: </em>  bool is_char = (bo-&gt;type()-&gt;size() == CharSize);
<em>814: </em>
<em>815: </em>  <strong>if</strong> (is_char) <font color="red"><strong>{</strong></font>
<em>816: </em>    right_reg.setlo();
<em>817: </em>    left_reg.setlo();
<em>818: </em>  <font color="red"><strong>}</strong></font>
<em>819: </em>
<em>820: </em>  ASM(code(),<font color="red">&quot;  &quot;</font> &lt;&lt; instr &lt;&lt; <font color="red">&quot; &quot;</font> &lt;&lt; right_reg &lt;&lt; <font color="red">&quot;, &quot;</font> &lt;&lt; left_reg,
<em>821: </em>      <font color="red">&quot;Perform '&quot;</font> &lt;&lt; bo-&gt;op_str() &lt;&lt; <font color="red">&quot;'&quot;</font>);
<em>822: </em>  stack().done();
<em>823: </em>
<em>824: </em>  <font color="#ffa600"><em>// Here we are relying on the fact that left_reg is now free</em></font>
<em>825: </em>  <font color="#ffa600"><em>// from the last pop(), so we should be able to push it</em></font>
<em>826: </em>  <font color="#ffa600"><em>// back onto the stack machine.</em></font>
<em>827: </em>  Operand new_reg = stack().push(bo-&gt;type(),left_reg.value());
<em>828: </em>  <strong>if</strong> (new_reg != left_reg) <font color="red"><strong>{</strong></font>
<em>829: </em>    <strong>throw</strong> runtime_error(<font color="red">&quot;Binop push() isn't the same as last pop()!&quot;</font>);
<em>830: </em>  <font color="red"><strong>}</strong></font>
<em>831: </em><font color="red"><strong>}</strong></font>
<em>832: </em>
<em>833: </em><font color="#ffa600"><em>// Performs a comparison operation (&gt;, ==, etc) on the given</em></font>
<em>834: </em><font color="#ffa600"><em>// Binop node.</em></font>
<em>835: </em>void CodeGen::binop_compare(Binop *bo)
<em>836: </em><font color="red"><strong>{</strong></font>
<em>837: </em>  bo-&gt;left()-&gt;codegen(*this);
<em>838: </em>  Operand right_reg = accept_and_pop(bo-&gt;right());
<em>839: </em>  Operand left_reg = stack().pop(bo-&gt;left()-&gt;coerce_to_type());
<em>840: </em>  stack().done();
<em>841: </em>
<em>842: </em>  ASM(code(),<font color="red">&quot;  cmpl &quot;</font> &lt;&lt; right_reg &lt;&lt; <font color="red">&quot;, &quot;</font> &lt;&lt; left_reg,
<em>843: </em>      <font color="red">&quot;Compare &quot;</font> &lt;&lt; left_reg &lt;&lt; <font color="red">&quot; to &quot;</font> &lt;&lt; right_reg);
<em>844: </em>
<em>845: </em>  <font color="#ffa600"><em>// TODO: this could cause errors, if push() generates</em></font>
<em>846: </em>  <font color="#ffa600"><em>// mov instructions...  not sure if mov instructions</em></font>
<em>847: </em>  <font color="#ffa600"><em>// change the flags though, they probably shouldn't</em></font>
<em>848: </em>  <font color="#ffa600"><em>// since they're not arithmetic operations.</em></font>
<em>849: </em>  BaseType bt_char(BaseType::Char);
<em>850: </em>  Operand reg = stack().push(&amp;bt_char);
<em>851: </em>  Operand byte_reg = reg;
<em>852: </em>  byte_reg.setlo();
<em>853: </em>  ASM(code(),<font color="red">&quot;  &quot;</font> &lt;&lt; binop(bo-&gt;op()) &lt;&lt; <font color="red">&quot; &quot;</font> &lt;&lt; byte_reg,
<em>854: </em>      <font color="red">&quot;Perform '&quot;</font> &lt;&lt; bo-&gt;op_str() &lt;&lt; <font color="red">&quot;'&quot;</font>);
<em>855: </em>  ASM(code(),<font color="red">&quot;  movzbl &quot;</font> &lt;&lt; byte_reg &lt;&lt; <font color="red">&quot;, &quot;</font> &lt;&lt; reg,
<em>856: </em>      <font color="red">&quot;Zero-extend the boolean result.&quot;</font>);
<em>857: </em><font color="red"><strong>}</strong></font>
<em>858: </em>
<em>859: </em><font color="#ffa600"><em>// Generate code for a binary operation.</em></font>
<em>860: </em>void CodeGen::genBinop(Binop *bo)
<em>861: </em><font color="red"><strong>{</strong></font>
<em>862: </em>  <strong>if</strong> (bo-&gt;is_assign_op()) <font color="red"><strong>{</strong></font>
<em>863: </em>    binop_assign(bo);
<em>864: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <strong>if</strong> (bo-&gt;is_compare_op()) <font color="red"><strong>{</strong></font>
<em>865: </em>    binop_compare(bo);
<em>866: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em>867: </em>    binop_arith(bo);
<em>868: </em>  <font color="red"><strong>}</strong></font>
<em>869: </em><font color="red"><strong>}</strong></font>
<em>870: </em>
<em>871: </em><font color="#ffa600"><em>// Generate code for a negative object.</em></font>
<em>872: </em>void CodeGen::genNegative(Negative *n)
<em>873: </em><font color="red"><strong>{</strong></font>
<em>874: </em>  n-&gt;expr()-&gt;codegen(*this);
<em>875: </em>  ASM(code(),<font color="red">&quot;  negl &quot;</font> &lt;&lt; stack().peek(),
<em>876: </em>      <font color="red">&quot;Perform unary negation.&quot;</font>);
<em>877: </em><font color="red"><strong>}</strong></font>
<em>878: </em>
<em>879: </em><font color="#ffa600"><em>// Generate code for a pointer operation.</em></font>
<em>880: </em>void CodeGen::genPointer(Pointer *p)
<em>881: </em><font color="red"><strong>{</strong></font>
<em>882: </em>  p-&gt;expr()-&gt;codegen(*this);
<em>883: </em>
<em>884: </em>  <strong>if</strong> (p-&gt;output_addr()) <font color="red"><strong>{</strong></font>
<em>885: </em>    ASM(code(),<font color="red">&quot; &quot;</font>,<font color="red">&quot;(Getting pointer target address via '*' here.)&quot;</font>);
<em>886: </em>    <strong>return</strong>;
<em>887: </em>  <font color="red"><strong>}</strong></font>
<em>888: </em>  Operand reg_from = stack().pop(p-&gt;expr()-&gt;type());
<em>889: </em>  Operand reg_to = stack().push(p-&gt;type());
<em>890: </em>  
<em>891: </em>  bool is_char = (p-&gt;type()-&gt;size() == CharSize);
<em>892: </em>  const char *inst = (is_char) ? <font color="red">&quot;movzbl&quot;</font> : <font color="red">&quot;movl&quot;</font>;
<em>893: </em>
<em>894: </em>  ASM(code(),<font color="red">&quot;  &quot;</font> &lt;&lt; inst &lt;&lt; <font color="red">&quot; (&quot;</font> &lt;&lt; reg_from &lt;&lt; <font color="red">&quot;), &quot;</font> &lt;&lt; reg_to,
<em>895: </em>      <font color="red">&quot;Pointer dereference.&quot;</font>);
<em>896: </em>  stack().done();
<em>897: </em><font color="red"><strong>}</strong></font>
<em>898: </em>
<em>899: </em><font color="#ffa600"><em>// Generate code for an address-of operation.</em></font>
<em>900: </em>void CodeGen::genAddrOf(AddrOf *ao)
<em>901: </em><font color="red"><strong>{</strong></font>
<em>902: </em>  ao-&gt;expr()-&gt;codegen(*this);
<em>903: </em>
<em>904: </em>  ASM(code(),<font color="red">&quot; &quot;</font>,<font color="red">&quot;(Address-of operator '&amp;' used here.)&quot;</font>);
<em>905: </em>  stack().force_type_change(ao-&gt;type());
<em>906: </em><font color="red"><strong>}</strong></font>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
</div>
<!-- Register Allocation -->
<a name="Register-Allocation"></a>
<div class="skribesubsectiontitle"><table width="100%"><tr><td bgcolor="#ffffff"><h3><font color="#8381de">5.8 Register Allocation</font>
</h3></td></tr></table>
</div><div class="subsection">
<!-- cc/StackMachine.h -->
<a name="cc/StackMachine.h"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">5.8.1 cc/StackMachine.h</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em>  1: </em><font color="#ffa600"><em>//</em></font>
<em>  2: </em><font color="#ffa600"><em>// Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.</em></font>
<em>  3: </em><font color="#ffa600"><em>//</em></font>
<em>  4: </em><font color="#ffa600"><em>// You may distribute under the terms of the Artistic License, as specified in</em></font>
<em>  5: </em><font color="#ffa600"><em>// the COPYING file.</em></font>
<em>  6: </em><font color="#ffa600"><em>//</em></font>
<em>  7: </em><font color="#ffa600"><em>//</em></font>
<em>  8: </em><font color="#ffa600"><em>// This class abstracts x86 registers into a stack</em></font>
<em>  9: </em><font color="#ffa600"><em>// machine for use by the code generator.</em></font>
<em> 10: </em><font color="#ffa600"><em>//</em></font>
<em> 11: </em>
<em> 12: </em>#ifndef _STACK_MACHINE_H_
<em> 13: </em><font color="#1919af"><strong>#define</strong></font> _STACK_MACHINE_H_
<em> 14: </em>
<em> 15: </em><font color="#1919af"><strong>#include</strong></font> &lt;vector&gt;
<em> 16: </em><font color="#1919af"><strong>#include</strong></font> &lt;string&gt;
<em> 17: </em>
<em> 18: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;Types.h&quot;</font>
<em> 19: </em>
<em> 20: </em><strong>class</strong> Type;
<em> 21: </em><strong>class</strong> AsmStore;
<em> 22: </em>
<em> 23: </em><font color="#ffa600"><em>// Simple class for storing a register or immediate value</em></font>
<em> 24: </em><font color="#ffa600"><em>// operand.</em></font>
<em> 25: </em><strong>struct</strong> Operand <font color="red"><strong>{</strong></font>
<em> 26: </em>  enum Flag <font color="red"><strong>{</strong></font> Reg = 1, Byte = 2, Mem = 4, Immed = 8 <font color="red"><strong>}</strong></font>;
<em> 27: </em>  enum Regs <font color="red"><strong>{</strong></font>
<em> 28: </em>    None = -1,
<em> 29: </em>    FirstReg = 0,
<em> 30: </em>    eax = 0,
<em> 31: </em>    ebx,
<em> 32: </em>    ecx,
<em> 33: </em>    edx,
<em> 34: </em>    esi,
<em> 35: </em>    edi,
<em> 36: </em>    LastReg,
<em> 37: </em>  <font color="red"><strong>}</strong></font>;
<em> 38: </em>
<em> 39: </em>  enum ByteRegs <font color="red"><strong>{</strong></font> al, bl, cl, dl <font color="red"><strong>}</strong></font>;
<em> 40: </em>
<em> 41: </em>  Operand() : _flags(0), _value(0) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em> 42: </em>  Operand(int value,Flag type = Reg) : 
<em> 43: </em>    _flags(type),
<em> 44: </em>    _value(value) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em> 45: </em>  bool is_reg() const <font color="red"><strong>{</strong></font> <strong>return</strong> _flags &amp; Reg; <font color="red"><strong>}</strong></font>;
<em> 46: </em>  bool is_mem() const <font color="red"><strong>{</strong></font> <strong>return</strong> _flags &amp; Mem; <font color="red"><strong>}</strong></font>;
<em> 47: </em>  bool is_immed() const <font color="red"><strong>{</strong></font> <strong>return</strong> _flags &amp; Immed; <font color="red"><strong>}</strong></font>;
<em> 48: </em>  bool is_bytereg() const <font color="red"><strong>{</strong></font> <strong>return</strong> _flags &amp; Byte; <font color="red"><strong>}</strong></font>;
<em> 49: </em>  int value() const <font color="red"><strong>{</strong></font> <strong>return</strong> _value; <font color="red"><strong>}</strong></font>;
<em> 50: </em>  <font color="#ffa600"><em>// Convert register to requivalent byte-access register.</em></font>
<em> 51: </em>  void setlo();
<em> 52: </em>
<em> 53: </em>  bool operator==(Operand x) const <font color="red"><strong>{</strong></font> <strong>return</strong> (_flags == x._flags &amp;&amp; _value == x._value); <font color="red"><strong>}</strong></font>;
<em> 54: </em>  bool operator!=(Operand x) const <font color="red"><strong>{</strong></font> <strong>return</strong> !operator==(x); <font color="red"><strong>}</strong></font>;
<em> 55: </em>
<em> 56: </em>  friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;,Operand);
<em> 57: </em>private:
<em> 58: </em>
<em> 59: </em>  int  _flags;
<em> 60: </em>  int  _value;
<em> 61: </em><font color="red"><strong>}</strong></font>;
<em> 62: </em>
<em> 63: </em>void printRegs(const IntVect &amp;);
<em> 64: </em>
<em> 65: </em><strong>class</strong> StackMachine <font color="red"><strong>{</strong></font>
<em> 66: </em>public:
<em> 67: </em>  StackMachine(AsmStore &amp;code,int base_fp);
<em> 68: </em>
<em> 69: </em>  <font color="#ffa600"><em>// Output an assembly string to the parent</em></font>
<em> 70: </em>  <font color="#ffa600"><em>// code generator.</em></font>
<em> 71: </em>  void o(const std::string &amp;str,const char *comment = 0);
<em> 72: </em>  <font color="#ffa600"><em>// Saves the caller-save registers, which should be done</em></font>
<em> 73: </em>  <font color="#ffa600"><em>// before the current function makes a function call, so that</em></font>
<em> 74: </em>  <font color="#ffa600"><em>// the registers don't get corrupted by the called function.</em></font>
<em> 75: </em>  void save_caller_saves();
<em> 76: </em>  <font color="#ffa600"><em>// Emits code that pushes the callee-save registers</em></font>
<em> 77: </em>  <font color="#ffa600"><em>// used by the stack machine onto the process' stack.</em></font>
<em> 78: </em>  void save_callee_saves(AsmStore &amp;);
<em> 79: </em>  <font color="#ffa600"><em>// Emits code that pops the callee-save registers used by</em></font>
<em> 80: </em>  <font color="#ffa600"><em>// the stack machine off the process' stack.  </em></font>
<em> 81: </em>  void load_callee_saves();
<em> 82: </em>  <font color="#ffa600"><em>// Finds a free eligible register (or frees one if all are</em></font>
<em> 83: </em>  <font color="#ffa600"><em>// being used) and returns it, pushing the register onto the</em></font>
<em> 84: </em>  <font color="#ffa600"><em>// stack machine's stack.</em></font>
<em> 85: </em>  <font color="#ffa600"><em>//</em></font>
<em> 86: </em>  <font color="#ffa600"><em>// This method associates the stack entry with the given Type</em></font>
<em> 87: </em>  <font color="#ffa600"><em>// object; if none is supplied, then an 'int' type is used</em></font>
<em> 88: </em>  <font color="#ffa600"><em>// by default.</em></font>
<em> 89: </em>  <font color="#ffa600"><em>//</em></font>
<em> 90: </em>  <font color="#ffa600"><em>// If preferred_reg is passed, this function will try its</em></font>
<em> 91: </em>  <font color="#ffa600"><em>// best to return preferred_reg, if it's available.</em></font>
<em> 92: </em>  Operand push(Type *type = 0,int preferred_reg = Operand::None,const IntVect *valid_regs = 0);
<em> 93: </em>  <font color="#ffa600"><em>// Pops the top element off the stack machine's stack, coerces</em></font>
<em> 94: </em>  <font color="#ffa600"><em>// it to the given type if necessary, and returns a register in</em></font>
<em> 95: </em>  <font color="#ffa600"><em>// which the element's value now resides.</em></font>
<em> 96: </em>  <font color="#ffa600"><em>//</em></font>
<em> 97: </em>  <font color="#ffa600"><em>// If no type is specified, pop() returns the value of the</em></font>
<em> 98: </em>  <font color="#ffa600"><em>// element as-is.</em></font>
<em> 99: </em>  Operand pop(Type *type = 0,const IntVect *valid_regs = 0);
<em>100: </em>  <font color="#ffa600"><em>// Returns the top element of the stack, but doesn't pop</em></font>
<em>101: </em>  <font color="#ffa600"><em>// it.  Note that this is not guaranteed to be a register; it</em></font>
<em>102: </em>  <font color="#ffa600"><em>// could be a memory location!</em></font>
<em>103: </em>  Operand StackMachine::peek();
<em>104: </em>  <font color="#ffa600"><em>// Returns true if the stack machine is empty.</em></font>
<em>105: </em>  bool empty() const <font color="red"><strong>{</strong></font> <strong>return</strong> _stack.empty(); <font color="red"><strong>}</strong></font>;
<em>106: </em>  <font color="#ffa600"><em>// Frees all registers that are marked as being in</em></font>
<em>107: </em>  <font color="#ffa600"><em>// intermediate use (i.e., have been pop()'d).</em></font>
<em>108: </em>  void done();
<em>109: </em>  <font color="#ffa600"><em>// Returns the maximum point in the process' stack, relative</em></font>
<em>110: </em>  <font color="#ffa600"><em>// to the current function's frame pointer, that the stack</em></font>
<em>111: </em>  <font color="#ffa600"><em>// machine is using for temporary variables.</em></font>
<em>112: </em>  int get_max_fp() const;
<em>113: </em>  <font color="#ffa600"><em>// Returns the low-order byte of the given register.  If the</em></font>
<em>114: </em>  <font color="#ffa600"><em>// register isn't byte-compatible (i.e., isn't %eax, %ebx, %ecx,</em></font>
<em>115: </em>  <font color="#ffa600"><em>// or %edx), then an exception is raised.</em></font>
<em>116: </em>  <font color="#ffa600"><em>//</em></font>
<em>117: </em>  <font color="#ffa600"><em>// Example: stack.lo('%eax') == '%al'.</em></font>
<em>118: </em>  const char *lo(Operand);
<em>119: </em>  <font color="#ffa600"><em>// Forces a type change of the top element of the stack.</em></font>
<em>120: </em>  void force_type_change(Type *type);
<em>121: </em>
<em>122: </em>  <strong>static</strong> bool staticInits();
<em>123: </em>private:
<em>124: </em>  <strong>struct</strong> Item <font color="red"><strong>{</strong></font>
<em>125: </em>    Operand  _op;
<em>126: </em>    Type    *_type;
<em>127: </em>    
<em>128: </em>    Item() : _type(0) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>129: </em>
<em>130: </em>    bool is_reg() const <font color="red"><strong>{</strong></font> <strong>return</strong> _op.is_reg(); <font color="red"><strong>}</strong></font>;
<em>131: </em>    bool is_mem() const <font color="red"><strong>{</strong></font> <strong>return</strong> _op.is_mem(); <font color="red"><strong>}</strong></font>;
<em>132: </em>    int value() const <font color="red"><strong>{</strong></font> <strong>return</strong> _op.value(); <font color="red"><strong>}</strong></font>;
<em>133: </em>  <font color="red"><strong>}</strong></font>;
<em>134: </em>  <strong>typedef</strong> std::vector&lt;Item&gt; Stack;
<em>135: </em>
<em>136: </em>  int get_free_reg(const IntVect &amp;valid_regs,int preferred_reg = Operand::None);
<em>137: </em>  const IntVect &amp;get_type_valid_regs(Type *t) const;
<em>138: </em>  int copy_reg_to_temp(const IntVect &amp;valid_regs,const char *comment_str = 0);
<em>139: </em>  Operand coerce_type(Operand curr_reg,Type *from,Type *to);
<em>140: </em>  Operand pop_internal(const IntVect &amp;valid_regs);
<em>141: </em>
<em>142: </em>  <font color="#ffa600"><em>// All registers in the system, in a vector so that</em></font>
<em>143: </em>  <font color="#ffa600"><em>// we can easily make copies.</em></font>
<em>144: </em>  <strong>static</strong> IntVect _all_regs;
<em>145: </em>  <font color="#ffa600"><em>// List of the caller-save registers.</em></font>
<em>146: </em>  <strong>static</strong> IntVect _caller_save_regs;
<em>147: </em>  <font color="#ffa600"><em>// List of the callee-save registers.</em></font>
<em>148: </em>  <strong>static</strong> IntVect _callee_save_regs;
<em>149: </em>  <font color="#ffa600"><em>// List of registers that allow low-order byte access.</em></font>
<em>150: </em>  <strong>static</strong> IntVect _byte_compat_regs;
<em>151: </em>  <font color="#ffa600"><em>// Default type for any object pushed onto the stack.</em></font>
<em>152: </em>  <strong>static</strong> Type *_default_type;
<em>153: </em>  <font color="#ffa600"><em>// Available registers.</em></font>
<em>154: </em>  IntVect _regs_free;
<em>155: </em>  <font color="#ffa600"><em>// Registers that aren't in use, except that they</em></font>
<em>156: </em>  <font color="#ffa600"><em>// have a result value.</em></font>
<em>157: </em>  IntVect _regs_almost_free;
<em>158: </em>  <font color="#ffa600"><em>// Temporary variable memory locations that are unused.</em></font>
<em>159: </em>  IntVect _mem_free;
<em>160: </em>  <font color="#ffa600"><em>// The stack machine's stack.  Element at the back is</em></font>
<em>161: </em>  <font color="#ffa600"><em>// the top of the stack.</em></font>
<em>162: </em>  Stack _stack;
<em>163: </em>  <font color="#ffa600"><em>// Location of next temporary memory location to be</em></font>
<em>164: </em>  <font color="#ffa600"><em>// used for temporary variables, relative to the current</em></font>
<em>165: </em>  <font color="#ffa600"><em>// function's frame pointer.</em></font>
<em>166: </em>  int _next_temp;
<em>167: </em>  <font color="#ffa600"><em>// Code output storage.</em></font>
<em>168: </em>  AsmStore &amp;_code;
<em>169: </em>  <font color="#ffa600"><em>// A list of the callee-save registers that have been used</em></font>
<em>170: </em>  <font color="#ffa600"><em>// so far by this function.  Once processing is finished,</em></font>
<em>171: </em>  <font color="#ffa600"><em>// these registers will be pushed onto the process' stack</em></font>
<em>172: </em>  <font color="#ffa600"><em>// at the beginning of the function and popped off just</em></font>
<em>173: </em>  <font color="#ffa600"><em>// before the function terminates.</em></font>
<em>174: </em>  IntVect _callee_save_regs_used;
<em>175: </em><font color="red"><strong>}</strong></font>;
<em>176: </em>
<em>177: </em><font color="#1919af"><strong>#endif</strong></font>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
<!-- cc/StackMachine.C -->
<a name="cc/StackMachine.C"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">5.8.2 cc/StackMachine.C</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em>  1: </em><font color="#ffa600"><em>//</em></font>
<em>  2: </em><font color="#ffa600"><em>// Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.</em></font>
<em>  3: </em><font color="#ffa600"><em>//</em></font>
<em>  4: </em><font color="#ffa600"><em>// You may distribute under the terms of the Artistic License, as specified in</em></font>
<em>  5: </em><font color="#ffa600"><em>// the COPYING file.</em></font>
<em>  6: </em><font color="#ffa600"><em>//</em></font>
<em>  7: </em><font color="#ffa600"><em>//     This class attempts to abstract the x86 registers into a stack</em></font>
<em>  8: </em><font color="#ffa600"><em>//     machine.  Calling push() gives you a register that isn't currently</em></font>
<em>  9: </em><font color="#ffa600"><em>//     in use by the stack machine, pop() gives you a register with the</em></font>
<em> 10: </em><font color="#ffa600"><em>//     value of the most recently pushed element.</em></font>
<em> 11: </em>
<em> 12: </em><font color="#ffa600"><em>//     Through this method the stack machine can be used to compute</em></font>
<em> 13: </em><font color="#ffa600"><em>//     values the same way a reverse polish notation (RPN) calculator</em></font>
<em> 14: </em><font color="#ffa600"><em>//     does.</em></font>
<em> 15: </em>
<em> 16: </em><font color="#ffa600"><em>//     When push() and pop() are called, it may be the case that no</em></font>
<em> 17: </em><font color="#ffa600"><em>//     registers are currently available; if this happens, the least</em></font>
<em> 18: </em><font color="#ffa600"><em>//     recently used register is 'spilled' into a temporary local</em></font>
<em> 19: </em><font color="#ffa600"><em>//     variable on the process' stack and freed for use.  Note that the</em></font>
<em> 20: </em><font color="#ffa600"><em>//     process' stack is not to be confused with this stack machine</em></font>
<em> 21: </em><font color="#ffa600"><em>//     abstraction--the two are completely different entities.</em></font>
<em> 22: </em>
<em> 23: </em><font color="#ffa600"><em>//     Currently, push() and pop() also implement a little bit of</em></font>
<em> 24: </em><font color="#ffa600"><em>//     implicit type conversion, so they take as parameters a cparse.Type</em></font>
<em> 25: </em><font color="#ffa600"><em>//     object; currently conversion is done between char and int types,</em></font>
<em> 26: </em><font color="#ffa600"><em>//     so depending on the pushed and popped types, some type conversion</em></font>
<em> 27: </em><font color="#ffa600"><em>//     assembly code may be generated.</em></font>
<em> 28: </em>
<em> 29: </em><font color="#ffa600"><em>//     Finally, an additional method, done(), should be called whenever</em></font>
<em> 30: </em><font color="#ffa600"><em>//     the stack machine is done popping values for the current</em></font>
<em> 31: </em><font color="#ffa600"><em>//     operation.  This is because when pop is called, the returned</em></font>
<em> 32: </em><font color="#ffa600"><em>//     register is not immediately made 'free' for another call to pop or</em></font>
<em> 33: </em><font color="#ffa600"><em>//     push.  If this were the case, then the following situation could</em></font>
<em> 34: </em><font color="#ffa600"><em>//     occur:</em></font>
<em> 35: </em>
<em> 36: </em><font color="#ffa600"><em>//              rightOp.calc()      # calc val of right op, put on stack</em></font>
<em> 37: </em><font color="#ffa600"><em>//              leftOp.calc()       # calc val of left op, put on stack</em></font>
<em> 38: </em><font color="#ffa600"><em>//              l = leftOp.pop()    # pop left val from stack</em></font>
<em> 39: </em><font color="#ffa600"><em>//              r = rightOp.pop()   # pop right val from stack</em></font>
<em> 40: </em><font color="#ffa600"><em>//              output('addl %s, %s' % (r, l))</em></font>
<em> 41: </em>
<em> 42: </em><font color="#ffa600"><em>//     The problem with this approach is that we don't know how many</em></font>
<em> 43: </em><font color="#ffa600"><em>//     registers will be used by leftOp's calc() method--it may use all</em></font>
<em> 44: </em><font color="#ffa600"><em>//     the remaining registers, in which case the value that rightOp's</em></font>
<em> 45: </em><font color="#ffa600"><em>//     calc() method put on the stack is no longer stored in a register.</em></font>
<em> 46: </em><font color="#ffa600"><em>//     If leftOp.pop() returned register %eax and immediately marked the</em></font>
<em> 47: </em><font color="#ffa600"><em>//     %eax register as being 'free for use', then the call to</em></font>
<em> 48: </em><font color="#ffa600"><em>//     rightOp.pop() could very well generate code that moves rightOp's</em></font>
<em> 49: </em><font color="#ffa600"><em>//     value from a temporary variable into %eax, thereby overwriting</em></font>
<em> 50: </em><font color="#ffa600"><em>//     leftOp's value!</em></font>
<em> 51: </em>
<em> 52: </em><font color="#ffa600"><em>//     So, instead, the pop() method places the %eax register (in this</em></font>
<em> 53: </em><font color="#ffa600"><em>//     example) into an internal list of 'almost free' registers;</em></font>
<em> 54: </em><font color="#ffa600"><em>//     registers that have just been returned by pop() but shouldn't be</em></font>
<em> 55: </em><font color="#ffa600"><em>//     used by the stack machine until a call to done() is made.  The</em></font>
<em> 56: </em><font color="#ffa600"><em>//     done() method simply moves the registers in the 'almost free' list</em></font>
<em> 57: </em><font color="#ffa600"><em>//     over to the 'free' list.</em></font>
<em> 58: </em>
<em> 59: </em><font color="#1919af"><strong>#include</strong></font> &lt;iterator&gt;
<em> 60: </em><font color="#1919af"><strong>#include</strong></font> &lt;sstream&gt;
<em> 61: </em><font color="#1919af"><strong>#include</strong></font> &lt;stdexcept&gt;
<em> 62: </em><font color="#1919af"><strong>#include</strong></font> &lt;iostream&gt;
<em> 63: </em>
<em> 64: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;StackMachine.h&quot;</font>
<em> 65: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;Node.h&quot;</font>
<em> 66: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;Types.h&quot;</font>
<em> 67: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;AsmStore.h&quot;</font>
<em> 68: </em>
<em> 69: </em><font color="#1919af"><strong>#define</strong></font> ASM(a,c) <font color="red"><strong>{</strong></font> \
<em> 70: </em>  ostringstream s1,s2; \
<em> 71: </em>  s1 &lt;&lt; a; \
<em> 72: </em>  s2 &lt;&lt; c; \
<em> 73: </em>  o(s1.str(),s2.str().c_str()); \
<em> 74: </em><font color="red"><strong>}</strong></font>
<em> 75: </em>
<em> 76: </em>using namespace std;
<em> 77: </em>
<em> 78: </em>IntVect StackMachine::_all_regs;
<em> 79: </em>IntVect StackMachine::_caller_save_regs;
<em> 80: </em>IntVect StackMachine::_callee_save_regs;
<em> 81: </em>IntVect StackMachine::_byte_compat_regs;
<em> 82: </em>Type *StackMachine::_default_type = 0;
<em> 83: </em>
<em> 84: </em><font color="#ffa600"><em>// Converts the register to the equivalent byte-access version.  If the</em></font>
<em> 85: </em><font color="#ffa600"><em>// register isn't byte-compatible (i.e., isn't %eax, %ebx, %ecx,</em></font>
<em> 86: </em><font color="#ffa600"><em>// or %edx), then an exception is raised.</em></font>
<em> 87: </em>void Operand::setlo()
<em> 88: </em><font color="red"><strong>{</strong></font>
<em> 89: </em>  <font color="#ffa600"><em>// Ignore if not a register.</em></font>
<em> 90: </em>  <strong>if</strong> (is_reg()) <font color="red"><strong>{</strong></font>
<em> 91: </em>    <strong>if</strong> (_value &gt;= eax &amp;&amp; _value &lt;= edx) <font color="red"><strong>{</strong></font>
<em> 92: </em>      _flags |= Byte;
<em> 93: </em>    <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em> 94: </em>      Error1(<font color="red">&quot;Register &quot;</font> &lt;&lt; _value &lt;&lt; <font color="red">&quot; is not byte-compatible.&quot;</font>);
<em> 95: </em>    <font color="red"><strong>}</strong></font>
<em> 96: </em>  <font color="red"><strong>}</strong></font>
<em> 97: </em><font color="red"><strong>}</strong></font>
<em> 98: </em>
<em> 99: </em>ostream &amp;operator&lt;&lt;(ostream &amp;o,Operand op)
<em>100: </em><font color="red"><strong>{</strong></font>
<em>101: </em>  <strong>if</strong> (op.is_reg()) <font color="red"><strong>{</strong></font>
<em>102: </em>    <strong>if</strong> (op.is_bytereg()) <font color="red"><strong>{</strong></font>
<em>103: </em>      <strong>switch</strong> (op.value()) <font color="red"><strong>{</strong></font>
<em>104: </em>      <strong>case</strong> Operand::al:
<em>105: </em>        o &lt;&lt; <font color="red">&quot;%al&quot;</font>;
<em>106: </em>        <strong>break</strong>;
<em>107: </em>      <strong>case</strong> Operand::bl:
<em>108: </em>        o &lt;&lt; <font color="red">&quot;%bl&quot;</font>;
<em>109: </em>        <strong>break</strong>;
<em>110: </em>      <strong>case</strong> Operand::cl:
<em>111: </em>        o &lt;&lt; <font color="red">&quot;%cl&quot;</font>;
<em>112: </em>        <strong>break</strong>;
<em>113: </em>      <strong>case</strong> Operand::dl:
<em>114: </em>        o &lt;&lt; <font color="red">&quot;%dl&quot;</font>;
<em>115: </em>        <strong>break</strong>;
<em>116: </em>      default:
<em>117: </em>        assert(0);
<em>118: </em>      <font color="red"><strong>}</strong></font>
<em>119: </em>    <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em>120: </em>      <strong>switch</strong> (op.value()) <font color="red"><strong>{</strong></font>
<em>121: </em>      <strong>case</strong> Operand::eax:
<em>122: </em>        o &lt;&lt; <font color="red">&quot;%eax&quot;</font>;
<em>123: </em>        <strong>break</strong>;
<em>124: </em>      <strong>case</strong> Operand::ebx:
<em>125: </em>        o &lt;&lt; <font color="red">&quot;%ebx&quot;</font>;
<em>126: </em>        <strong>break</strong>;
<em>127: </em>      <strong>case</strong> Operand::ecx:
<em>128: </em>        o &lt;&lt; <font color="red">&quot;%ecx&quot;</font>;
<em>129: </em>        <strong>break</strong>;
<em>130: </em>      <strong>case</strong> Operand::edx:
<em>131: </em>        o &lt;&lt; <font color="red">&quot;%edx&quot;</font>;
<em>132: </em>        <strong>break</strong>;
<em>133: </em>      <strong>case</strong> Operand::esi:
<em>134: </em>        o &lt;&lt; <font color="red">&quot;%esi&quot;</font>;
<em>135: </em>        <strong>break</strong>;
<em>136: </em>      <strong>case</strong> Operand::edi:
<em>137: </em>        o &lt;&lt; <font color="red">&quot;%edi&quot;</font>;
<em>138: </em>        <strong>break</strong>;
<em>139: </em>      default:
<em>140: </em>        assert(0);
<em>141: </em>      <font color="red"><strong>}</strong></font>
<em>142: </em>    <font color="red"><strong>}</strong></font>
<em>143: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <strong>if</strong> (op.is_mem()) <font color="red"><strong>{</strong></font>
<em>144: </em>    o &lt;&lt; op.value() &lt;&lt; <font color="red">&quot;(%ebp)&quot;</font>;
<em>145: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em>146: </em>    o &lt;&lt; <font color="red">&quot;$&quot;</font> &lt;&lt; op.value();
<em>147: </em>  <font color="red"><strong>}</strong></font>
<em>148: </em>  <strong>return</strong> o;
<em>149: </em><font color="red"><strong>}</strong></font>
<em>150: </em>
<em>151: </em><strong>template</strong>&lt;<strong>class</strong> T,typename C&gt;
<em>152: </em>bool contains(const T &amp;t,C c)
<em>153: </em><font color="red"><strong>{</strong></font>
<em>154: </em>  <strong>return</strong> (find(t.begin(),t.end(),c) != t.end());
<em>155: </em><font color="red"><strong>}</strong></font>
<em>156: </em>
<em>157: </em><strong>template</strong>&lt;<strong>class</strong> T,typename C&gt;
<em>158: </em>void remove_item(T &amp;t,C c)
<em>159: </em><font color="red"><strong>{</strong></font>
<em>160: </em>  typename T::iterator e = remove(t.begin(),t.end(),c);
<em>161: </em>  t.erase(e,t.end());
<em>162: </em><font color="red"><strong>}</strong></font>
<em>163: </em>
<em>164: </em>void printRegs(const IntVect &amp;iv)
<em>165: </em><font color="red"><strong>{</strong></font>
<em>166: </em>  ostream_iterator&lt;int&gt; i(cerr,<font color="red">&quot; &quot;</font>);
<em>167: </em>  copy(iv.begin(),iv.end(),i);
<em>168: </em><font color="red"><strong>}</strong></font>
<em>169: </em>
<em>170: </em>bool StackMachine::staticInits()
<em>171: </em><font color="red"><strong>{</strong></font>
<em>172: </em>  _all_regs.push_back(Operand::ebx);
<em>173: </em>  _all_regs.push_back(Operand::esi);
<em>174: </em>  _all_regs.push_back(Operand::edi);
<em>175: </em>  _all_regs.push_back(Operand::eax);
<em>176: </em>  _all_regs.push_back(Operand::ecx);
<em>177: </em>  _all_regs.push_back(Operand::edx);
<em>178: </em>
<em>179: </em>  _caller_save_regs.push_back(Operand::eax);
<em>180: </em>  _caller_save_regs.push_back(Operand::ecx);
<em>181: </em>  _caller_save_regs.push_back(Operand::edx);
<em>182: </em>
<em>183: </em>  _callee_save_regs.push_back(Operand::ebx);
<em>184: </em>  _callee_save_regs.push_back(Operand::esi);
<em>185: </em>  _callee_save_regs.push_back(Operand::edi);
<em>186: </em>
<em>187: </em>  _byte_compat_regs.push_back(Operand::eax);
<em>188: </em>  _byte_compat_regs.push_back(Operand::ebx);
<em>189: </em>  _byte_compat_regs.push_back(Operand::ecx);
<em>190: </em>  _byte_compat_regs.push_back(Operand::edx);
<em>191: </em>
<em>192: </em>  _default_type = new BaseType(BaseType::Int);
<em>193: </em>
<em>194: </em>  <strong>return</strong> true;
<em>195: </em><font color="red"><strong>}</strong></font>
<em>196: </em>
<em>197: </em>StackMachine::StackMachine(AsmStore &amp;code,int base_fp) :
<em>198: </em>  _next_temp(base_fp - WordSize),
<em>199: </em>  _code(code)
<em>200: </em><font color="red"><strong>{</strong></font>
<em>201: </em>  <strong>static</strong> bool dummy = staticInits();
<em>202: </em>  _regs_free = _all_regs;
<em>203: </em><font color="red"><strong>}</strong></font>
<em>204: </em>
<em>205: </em>void StackMachine::o(const string &amp;a,const char *c)
<em>206: </em><font color="red"><strong>{</strong></font>
<em>207: </em>  _code.o(a,c);
<em>208: </em><font color="red"><strong>}</strong></font>
<em>209: </em>
<em>210: </em><font color="#ffa600"><em>// Saves the caller-save registers, which should be done</em></font>
<em>211: </em><font color="#ffa600"><em>// before the current function makes a function call, so that</em></font>
<em>212: </em><font color="#ffa600"><em>// the registers don't get corrupted by the called function.</em></font>
<em>213: </em><font color="#ffa600"><em>//</em></font>
<em>214: </em><font color="#ffa600"><em>// Normally, this is done by pushing the caller-save registers</em></font>
<em>215: </em><font color="#ffa600"><em>// onto the stack just before the function call is made and</em></font>
<em>216: </em><font color="#ffa600"><em>// popping them off afterwards; however, due to the workings of</em></font>
<em>217: </em><font color="#ffa600"><em>// this particular stack machine it's much easier to just move</em></font>
<em>218: </em><font color="#ffa600"><em>// the contents of the caller-save registers, if they are</em></font>
<em>219: </em><font color="#ffa600"><em>// currently being used, into temporary variables.</em></font>
<em>220: </em>void StackMachine::save_caller_saves()
<em>221: </em><font color="red"><strong>{</strong></font>
<em>222: </em>  IntVect tmp(1);
<em>223: </em>  <strong>for</strong> (IntVect::const_iterator i = _caller_save_regs.begin();
<em>224: </em>       i != _caller_save_regs.end(); ++i) <font color="red"><strong>{</strong></font>
<em>225: </em>    <strong>if</strong> (!contains(_regs_free,*i)) <font color="red"><strong>{</strong></font>
<em>226: </em>      tmp[0] = *i;
<em>227: </em>      copy_reg_to_temp(tmp,<font color="red">&quot;Save caller-save register to temp.&quot;</font>);
<em>228: </em>      _regs_free.push_back(*i);
<em>229: </em>    <font color="red"><strong>}</strong></font>
<em>230: </em>  <font color="red"><strong>}</strong></font>
<em>231: </em><font color="red"><strong>}</strong></font>
<em>232: </em>
<em>233: </em><font color="#ffa600"><em>// Emits code that pushes the callee-save registers</em></font>
<em>234: </em><font color="#ffa600"><em>// used by the stack machine onto the process' stack.</em></font>
<em>235: </em>void StackMachine::save_callee_saves(AsmStore &amp;code)
<em>236: </em><font color="red"><strong>{</strong></font>
<em>237: </em>  <strong>for</strong> (IntVect::iterator i = _callee_save_regs_used.begin();
<em>238: </em>       i != _callee_save_regs_used.end(); ++i) <font color="red"><strong>{</strong></font>
<em>239: </em>    ostringstream ss;
<em>240: </em>    ss &lt;&lt; <font color="red">&quot;  pushl &quot;</font> &lt;&lt; Operand(*i);
<em>241: </em>    code.o(ss.str(),<font color="red">&quot;Save callee-save registers.&quot;</font>);
<em>242: </em>  <font color="red"><strong>}</strong></font>
<em>243: </em><font color="red"><strong>}</strong></font>
<em>244: </em>
<em>245: </em><font color="#ffa600"><em>// Emits code that pops the callee-save registers used by</em></font>
<em>246: </em><font color="#ffa600"><em>// the stack machine off the process' stack.  </em></font>
<em>247: </em>void StackMachine::load_callee_saves()
<em>248: </em><font color="red"><strong>{</strong></font>
<em>249: </em>  <strong>for</strong> (IntVect::iterator i = _callee_save_regs_used.begin();
<em>250: </em>       i != _callee_save_regs_used.end(); ++i) <font color="red"><strong>{</strong></font>
<em>251: </em>    ASM(<font color="red">&quot;  popl &quot;</font> &lt;&lt; Operand(*i),<font color="red">&quot;Restore callee-save registers.&quot;</font>);
<em>252: </em>  <font color="red"><strong>}</strong></font>  
<em>253: </em><font color="red"><strong>}</strong></font>
<em>254: </em>
<em>255: </em><font color="#ffa600"><em>// Copy the least recently used register on the stack into a</em></font>
<em>256: </em><font color="#ffa600"><em>// temporary variable.  The register must be in the valid_regs</em></font>
<em>257: </em><font color="#ffa600"><em>// list.</em></font>
<em>258: </em>int StackMachine::copy_reg_to_temp(const IntVect &amp;valid_regs,const char *comment_str)
<em>259: </em><font color="red"><strong>{</strong></font>
<em>260: </em>  <font color="#ffa600"><em>// If no free temp variables exist, create a new one.</em></font>
<em>261: </em>  <strong>if</strong> (_mem_free.empty()) <font color="red"><strong>{</strong></font>
<em>262: </em>    _mem_free.push_back(_next_temp);
<em>263: </em>    _next_temp -= WordSize;
<em>264: </em>  <font color="red"><strong>}</strong></font>
<em>265: </em>
<em>266: </em>  <font color="#ffa600"><em>// Get an unused temp var.</em></font>
<em>267: </em>  int mem = _mem_free.back();
<em>268: </em>  _mem_free.pop_back();
<em>269: </em>
<em>270: </em>  <font color="#ffa600"><em>// Find the least recently used register on the stack.</em></font>
<em>271: </em>  int reg = Operand::None;
<em>272: </em>  int index = 0;
<em>273: </em>  <strong>for</strong> (Stack::iterator i = _stack.begin(); i != _stack.end(); ++i) <font color="red"><strong>{</strong></font>
<em>274: </em>    <strong>if</strong> (i-&gt;is_reg() &amp;&amp; contains(valid_regs,i-&gt;value())) <font color="red"><strong>{</strong></font>
<em>275: </em>      reg = i-&gt;value();
<em>276: </em>      <strong>break</strong>;
<em>277: </em>    <font color="red"><strong>}</strong></font>
<em>278: </em>    ++index;
<em>279: </em>  <font color="red"><strong>}</strong></font>
<em>280: </em>  <strong>if</strong> (reg == Operand::None) <font color="red"><strong>{</strong></font>
<em>281: </em>    <strong>throw</strong> runtime_error(<font color="red">&quot;No free registers inside OR outside of stack.&quot;</font>);
<em>282: </em>  <font color="red"><strong>}</strong></font>
<em>283: </em>
<em>284: </em>  <font color="#ffa600"><em>// Emit code to copy the register to the memory location.</em></font>
<em>285: </em>  <strong>if</strong> (!comment_str) <font color="red"><strong>{</strong></font>
<em>286: </em>    comment_str = <font color="red">&quot;Stack machine:  copy register to temp.&quot;</font>;
<em>287: </em>  <font color="red"><strong>}</strong></font>
<em>288: </em>  ASM(<font color="red">&quot;  movl &quot;</font> &lt;&lt; Operand(reg) &lt;&lt; <font color="red">&quot;, &quot;</font> &lt;&lt; Operand(mem,Operand::Mem),comment_str);
<em>289: </em>  <font color="#ffa600"><em>// Modify element's stack machine position to reference its new location.</em></font>
<em>290: </em>  _stack[index]._op = Operand(mem,Operand::Mem);
<em>291: </em>  <strong>return</strong> reg;
<em>292: </em><font color="red"><strong>}</strong></font>
<em>293: </em>
<em>294: </em><font color="#ffa600"><em>// Returns a free register that is in the valid_regs list.  If</em></font>
<em>295: </em><font color="#ffa600"><em>// no registers are available, the most least-recently used</em></font>
<em>296: </em><font color="#ffa600"><em>// eligible one is freed (by moving its contents to a temporary</em></font>
<em>297: </em><font color="#ffa600"><em>// variable) and returned.</em></font>
<em>298: </em>int StackMachine::get_free_reg(const IntVect &amp;valid_regs,int preferred_reg)
<em>299: </em><font color="red"><strong>{</strong></font>
<em>300: </em>  <strong>if</strong> (!_regs_free.empty()) <font color="red"><strong>{</strong></font>
<em>301: </em>    int reg = Operand::None;
<em>302: </em>    <strong>if</strong> (preferred_reg != Operand::None &amp;&amp; contains(_regs_free,preferred_reg)) <font color="red"><strong>{</strong></font>
<em>303: </em>      reg = preferred_reg;
<em>304: </em>    <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em>305: </em>      <font color="#ffa600"><em>// We iterate from the back, since free registers are added to the back.  This lets</em></font>
<em>306: </em>      <font color="#ffa600"><em>// us re-use the preferred set (caller-save).</em></font>
<em>307: </em>      <strong>for</strong> (IntVect::reverse_iterator i = _regs_free.rbegin(); i != _regs_free.rend(); ++i) <font color="red"><strong>{</strong></font>
<em>308: </em>        <strong>if</strong> (contains(valid_regs,*i)) <font color="red"><strong>{</strong></font>
<em>309: </em>          reg = *i;
<em>310: </em>          <strong>break</strong>;
<em>311: </em>        <font color="red"><strong>}</strong></font>
<em>312: </em>      <font color="red"><strong>}</strong></font>
<em>313: </em>    <font color="red"><strong>}</strong></font>
<em>314: </em>    <strong>if</strong> (reg != Operand::None) <font color="red"><strong>{</strong></font>
<em>315: </em>      remove_item(_regs_free,reg);
<em>316: </em>      <font color="#ffa600"><em>// If this register is a callee-save register that</em></font>
<em>317: </em>      <font color="#ffa600"><em>// we haven't used before, add it to our list of</em></font>
<em>318: </em>      <font color="#ffa600"><em>// used callee-save registers.</em></font>
<em>319: </em>      <strong>if</strong> (!contains(_callee_save_regs_used,reg) &amp;&amp; contains(_callee_save_regs,reg)) <font color="red"><strong>{</strong></font>
<em>320: </em>        _callee_save_regs_used.push_back(reg);
<em>321: </em>      <font color="red"><strong>}</strong></font>
<em>322: </em>      <strong>return</strong> reg;
<em>323: </em>    <font color="red"><strong>}</strong></font>
<em>324: </em>  <font color="red"><strong>}</strong></font>
<em>325: </em>  <font color="#ffa600"><em>// No register was free, so move least recently used to temp location.</em></font>
<em>326: </em>  <strong>return</strong> copy_reg_to_temp(valid_regs);
<em>327: </em><font color="red"><strong>}</strong></font>
<em>328: </em>
<em>329: </em><font color="#ffa600"><em>// Returns the valid registers that an element of the given</em></font>
<em>330: </em><font color="#ffa600"><em>// type can occupy.  For instance, 8-bit chars should only be</em></font>
<em>331: </em><font color="#ffa600"><em>// placed in %eax/%ebx/%ecx/%edx because these are the only</em></font>
<em>332: </em><font color="#ffa600"><em>// registers with low-order byte sub-registers</em></font>
<em>333: </em><font color="#ffa600"><em>// (%al/%bl/%cl/%dl).</em></font>
<em>334: </em>const IntVect &amp;StackMachine::get_type_valid_regs(Type *type) const
<em>335: </em><font color="red"><strong>{</strong></font>
<em>336: </em>  BaseType::BT t = intType(type);
<em>337: </em>  <strong>if</strong> (t == BaseType::Char) <font color="red"><strong>{</strong></font>
<em>338: </em>    <strong>return</strong> _byte_compat_regs;
<em>339: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <strong>if</strong> (t == BaseType::Int || isPtrType(type)) <font color="red"><strong>{</strong></font>
<em>340: </em>    <strong>return</strong> _all_regs;
<em>341: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em>342: </em>    Error1(<font color="red">&quot;No compatible register available for type &quot;</font> &lt;&lt; type);
<em>343: </em>  <font color="red"><strong>}</strong></font>
<em>344: </em><font color="red"><strong>}</strong></font>
<em>345: </em>
<em>346: </em><font color="#ffa600"><em>// Finds a free eligible register (or frees one if all are</em></font>
<em>347: </em><font color="#ffa600"><em>// being used) and returns it, pushing the register onto the</em></font>
<em>348: </em><font color="#ffa600"><em>// stack machine's stack.</em></font>
<em>349: </em><font color="#ffa600"><em>//</em></font>
<em>350: </em><font color="#ffa600"><em>// This method associates the stack entry with the given Type</em></font>
<em>351: </em><font color="#ffa600"><em>// object; if none is supplied, then an 'int' type is used</em></font>
<em>352: </em><font color="#ffa600"><em>// by default.</em></font>
<em>353: </em><font color="#ffa600"><em>//</em></font>
<em>354: </em><font color="#ffa600"><em>// If preferred_reg is passed, this function will try its</em></font>
<em>355: </em><font color="#ffa600"><em>// best to return preferred_reg, if it's available.</em></font>
<em>356: </em>Operand StackMachine::push(Type *type,int preferred_reg,const IntVect *valid_regs)
<em>357: </em><font color="red"><strong>{</strong></font>
<em>358: </em>  <strong>if</strong> (!type) <font color="red"><strong>{</strong></font>
<em>359: </em>    type = _default_type;
<em>360: </em>  <font color="red"><strong>}</strong></font>
<em>361: </em>  _stack.push_back(Item());
<em>362: </em>  _stack.back()._type = type;
<em>363: </em>  <strong>if</strong> (!valid_regs) <font color="red"><strong>{</strong></font>
<em>364: </em>    valid_regs = &amp;get_type_valid_regs(type);
<em>365: </em>  <font color="red"><strong>}</strong></font>
<em>366: </em>  Operand reg = get_free_reg(*valid_regs,preferred_reg);
<em>367: </em>  _stack.back()._op = reg;
<em>368: </em>  <strong>return</strong> reg;
<em>369: </em><font color="red"><strong>}</strong></font>
<em>370: </em>
<em>371: </em><font color="#ffa600"><em>// Attempts to coerce the element in the current register</em></font>
<em>372: </em><font color="#ffa600"><em>// from the given type to the given type.</em></font>
<em>373: </em>Operand StackMachine::coerce_type(Operand curr_reg,Type *from,Type *to)
<em>374: </em><font color="red"><strong>{</strong></font>
<em>375: </em>  <strong>if</strong> (typeid(from) == typeid(to)) <font color="red"><strong>{</strong></font>
<em>376: </em>    <strong>return</strong> curr_reg;
<em>377: </em>  <font color="red"><strong>}</strong></font>
<em>378: </em>  BaseType::BT from_t = intType(from);
<em>379: </em>  BaseType::BT to_t = intType(to);
<em>380: </em>  <strong>if</strong> (from_t == BaseType::Char) <font color="red"><strong>{</strong></font>
<em>381: </em>    <strong>if</strong> (to_t == BaseType::Int) <font color="red"><strong>{</strong></font>
<em>382: </em>      <strong>return</strong> curr_reg;
<em>383: </em>    <font color="red"><strong>}</strong></font>
<em>384: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <strong>if</strong> (from_t == BaseType::Int) <font color="red"><strong>{</strong></font>
<em>385: </em>    <strong>if</strong> (to_t == BaseType::Char) <font color="red"><strong>{</strong></font>
<em>386: </em>      Operand cr_lo(curr_reg);
<em>387: </em>      cr_lo.setlo();
<em>388: </em>      ASM(<font color="red">&quot;  movzbl &quot;</font> &lt;&lt; cr_lo &lt;&lt; <font color="red">&quot;, &quot;</font> &lt;&lt; curr_reg,
<em>389: </em>          <font color="red">&quot;Implicit cast: &quot;</font> &lt;&lt; from &lt;&lt; <font color="red">&quot; -&gt; &quot;</font> &lt;&lt; to);
<em>390: </em>      <strong>return</strong> curr_reg;
<em>391: </em>    <font color="red"><strong>}</strong></font>
<em>392: </em>  <font color="red"><strong>}</strong></font>
<em>393: </em>  assert(0);
<em>394: </em><font color="red"><strong>}</strong></font>
<em>395: </em>
<em>396: </em><font color="#ffa600"><em>// Pops the top element off the stack machine's stack, coerces</em></font>
<em>397: </em><font color="#ffa600"><em>// it to the given type if necessary, and returns a register in</em></font>
<em>398: </em><font color="#ffa600"><em>// which the element's value now resides.</em></font>
<em>399: </em><font color="#ffa600"><em>//</em></font>
<em>400: </em><font color="#ffa600"><em>// If no type is specified, pop() returns the value of the</em></font>
<em>401: </em><font color="#ffa600"><em>// element as-is.</em></font>
<em>402: </em>Operand StackMachine::pop(Type *type,const IntVect *valid_regs)
<em>403: </em><font color="red"><strong>{</strong></font>
<em>404: </em>  Type *prev_type = _stack.back()._type;
<em>405: </em>  <strong>if</strong> (type) <font color="red"><strong>{</strong></font>
<em>406: </em>    <strong>if</strong> (!valid_regs) <font color="red"><strong>{</strong></font>
<em>407: </em>      valid_regs = &amp;get_type_valid_regs(type);
<em>408: </em>    <font color="red"><strong>}</strong></font>
<em>409: </em>    <strong>return</strong> coerce_type(pop_internal(*valid_regs),prev_type,type);
<em>410: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em>411: </em>    <strong>return</strong> pop_internal(_all_regs);
<em>412: </em>  <font color="red"><strong>}</strong></font>
<em>413: </em><font color="red"><strong>}</strong></font>
<em>414: </em>
<em>415: </em><font color="#ffa600"><em>// Pops the top element of the stack into a free register</em></font>
<em>416: </em><font color="#ffa600"><em>// that is also in valid_regs and returns the register name.  If</em></font>
<em>417: </em><font color="#ffa600"><em>// no registers are free, the least recently used one is first</em></font>
<em>418: </em><font color="#ffa600"><em>// copied into a temporary variable and then used.</em></font>
<em>419: </em>Operand StackMachine::pop_internal(const IntVect &amp;valid_regs)
<em>420: </em><font color="red"><strong>{</strong></font>
<em>421: </em>  Operand last = _stack.back()._op;
<em>422: </em>  _stack.pop_back();
<em>423: </em>
<em>424: </em>  <font color="#ffa600"><em>// If the top of the stack is a register, just return</em></font>
<em>425: </em>  <font color="#ffa600"><em>// the name of the register and add the register to our</em></font>
<em>426: </em>  <font color="#ffa600"><em>// free register list.</em></font>
<em>427: </em>  <strong>if</strong> (last.is_reg() &amp;&amp; contains(valid_regs,last.value())) <font color="red"><strong>{</strong></font>
<em>428: </em>    _regs_almost_free.push_back(last.value());
<em>429: </em>    <strong>return</strong> last;
<em>430: </em>  <font color="red"><strong>}</strong></font>
<em>431: </em>
<em>432: </em>  <font color="#ffa600"><em>// Otherwise, copy the temp variable at the top of stack</em></font>
<em>433: </em>  <font color="#ffa600"><em>// into a free register, possibly requiring us to spill the</em></font>
<em>434: </em>  <font color="#ffa600"><em>// current contents of the memory register into another temp</em></font>
<em>435: </em>  <font color="#ffa600"><em>// register.</em></font>
<em>436: </em>  Operand reg(get_free_reg(valid_regs));
<em>437: </em>  ASM(<font color="red">&quot;  movl &quot;</font> &lt;&lt; last &lt;&lt; <font color="red">&quot;, &quot;</font> &lt;&lt; reg,
<em>438: </em>      <font color="red">&quot;Stack machine:  copy temp to register.&quot;</font>);
<em>439: </em>
<em>440: </em>  <font color="#ffa600"><em>// If our location was a register but not in valid_regs,</em></font>
<em>441: </em>  <font color="#ffa600"><em>// make the register free for use.</em></font>
<em>442: </em>  <strong>if</strong> (last.is_reg()) <font color="red"><strong>{</strong></font>
<em>443: </em>    _regs_free.push_back(last.value());
<em>444: </em>  <font color="red"><strong>}</strong></font>
<em>445: </em>
<em>446: </em>  _regs_almost_free.push_back(reg.value());
<em>447: </em>
<em>448: </em>  <strong>return</strong> reg;
<em>449: </em><font color="red"><strong>}</strong></font>
<em>450: </em>
<em>451: </em><font color="#ffa600"><em>// Returns the top element of the stack, but doesn't pop</em></font>
<em>452: </em><font color="#ffa600"><em>// it.  Note that this is not guaranteed to be a register; it</em></font>
<em>453: </em><font color="#ffa600"><em>// could be a memory location!</em></font>
<em>454: </em>Operand StackMachine::peek()
<em>455: </em><font color="red"><strong>{</strong></font>
<em>456: </em>  assert(!empty());
<em>457: </em>  <strong>return</strong> _stack.back()._op;
<em>458: </em><font color="red"><strong>}</strong></font>
<em>459: </em>
<em>460: </em><font color="#ffa600"><em>// Frees all registers that are marked as being in</em></font>
<em>461: </em><font color="#ffa600"><em>// intermediate use (i.e., have been pop()'d).</em></font>
<em>462: </em>void StackMachine::done()
<em>463: </em><font color="red"><strong>{</strong></font>
<em>464: </em>  _regs_free.insert(_regs_free.end(),_regs_almost_free.begin(),_regs_almost_free.end());
<em>465: </em>  _regs_almost_free.clear();
<em>466: </em><font color="red"><strong>}</strong></font>
<em>467: </em>
<em>468: </em><font color="#ffa600"><em>// Returns the maximum point in the process' stack, relative</em></font>
<em>469: </em><font color="#ffa600"><em>// to the current function's frame pointer, that the stack</em></font>
<em>470: </em><font color="#ffa600"><em>// machine is using for temporary variables.</em></font>
<em>471: </em>int StackMachine::get_max_fp() const
<em>472: </em><font color="red"><strong>{</strong></font>
<em>473: </em>  <strong>return</strong> _next_temp + WordSize;
<em>474: </em><font color="red"><strong>}</strong></font>
<em>475: </em>
<em>476: </em><font color="#ffa600"><em>// Forces a type change of the top element of the stack.</em></font>
<em>477: </em>void StackMachine::force_type_change(Type *type)
<em>478: </em><font color="red"><strong>{</strong></font>
<em>479: </em>  assert(!empty());
<em>480: </em>  _stack.back()._type = type;
<em>481: </em><font color="red"><strong>}</strong></font>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
</div>
<!-- Assembly Code Writer -->
<a name="Assembly-Code-Writer"></a>
<div class="skribesubsectiontitle"><table width="100%"><tr><td bgcolor="#ffffff"><h3><font color="#8381de">5.9 Assembly Code Writer</font>
</h3></td></tr></table>
</div><div class="subsection">
<!-- cc/AsmStore.h -->
<a name="cc/AsmStore.h"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">5.9.1 cc/AsmStore.h</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em> 1: </em><font color="#ffa600"><em>//</em></font>
<em> 2: </em><font color="#ffa600"><em>// Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.</em></font>
<em> 3: </em><font color="#ffa600"><em>//</em></font>
<em> 4: </em><font color="#ffa600"><em>// You may distribute under the terms of the Artistic License, as specified in</em></font>
<em> 5: </em><font color="#ffa600"><em>// the COPYING file.</em></font>
<em> 6: </em><font color="#ffa600"><em>//</em></font>
<em> 7: </em><font color="#ffa600"><em>//</em></font>
<em> 8: </em><font color="#ffa600"><em>// Simple class for storing assembly code.</em></font>
<em> 9: </em><font color="#ffa600"><em>// Rather than having an AST for assembly, we just</em></font>
<em>10: </em><font color="#ffa600"><em>// have a list of strings that we print out at the</em></font>
<em>11: </em><font color="#ffa600"><em>// end.</em></font>
<em>12: </em><font color="#ffa600"><em>//</em></font>
<em>13: </em>
<em>14: </em>#ifndef _ASM_STORE_H_
<em>15: </em><font color="#1919af"><strong>#define</strong></font> _ASM_STORE_H_
<em>16: </em>
<em>17: </em><font color="#1919af"><strong>#include</strong></font> &lt;list&gt;
<em>18: </em><font color="#1919af"><strong>#include</strong></font> &lt;string&gt;
<em>19: </em><font color="#1919af"><strong>#include</strong></font> &lt;iosfwd&gt;
<em>20: </em>
<em>21: </em><strong>class</strong> AsmStore <font color="red"><strong>{</strong></font>
<em>22: </em>public:
<em>23: </em>  AsmStore(bool print_comments = true);
<em>24: </em>
<em>25: </em>  <font color="#ffa600"><em>// Output a line of assembly.</em></font>
<em>26: </em>  void o(const std::string &amp;str,const char *comment = 0);
<em>27: </em>  <font color="#ffa600"><em>// Output a comment, if comments are enabled.</em></font>
<em>28: </em>  void c(const std::string &amp;str,int indent_amt = 2);
<em>29: </em>
<em>30: </em>  <font color="#ffa600"><em>// Add code to front.</em></font>
<em>31: </em>  void splice_front(AsmStore &amp;);
<em>32: </em>  <font color="#ffa600"><em>// Add code to back.</em></font>
<em>33: </em>  void splice_back(AsmStore &amp;);
<em>34: </em>
<em>35: </em>  <font color="#ffa600"><em>// Write data to the specified output stream.</em></font>
<em>36: </em>  void write(std::ostream &amp;) const;
<em>37: </em>
<em>38: </em>private:
<em>39: </em>  <strong>typedef</strong> std::list&lt;std::string&gt; AList;
<em>40: </em>
<em>41: </em>  bool  _print_comments;
<em>42: </em>  AList _asm;
<em>43: </em>
<em>44: </em><font color="red"><strong>}</strong></font>;
<em>45: </em>
<em>46: </em><font color="#1919af"><strong>#endif</strong></font>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
<!-- cc/AsmStore.C -->
<a name="cc/AsmStore.C"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">5.9.2 cc/AsmStore.C</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em> 1: </em><font color="#ffa600"><em>//</em></font>
<em> 2: </em><font color="#ffa600"><em>// Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.</em></font>
<em> 3: </em><font color="#ffa600"><em>//</em></font>
<em> 4: </em><font color="#ffa600"><em>// You may distribute under the terms of the Artistic License, as specified in</em></font>
<em> 5: </em><font color="#ffa600"><em>// the COPYING file.</em></font>
<em> 6: </em><font color="#ffa600"><em>//</em></font>
<em> 7: </em><font color="#ffa600"><em>//</em></font>
<em> 8: </em><font color="#ffa600"><em>// Simple class for storing assembly code.</em></font>
<em> 9: </em><font color="#ffa600"><em>// Rather than having an AST for assembly, we just</em></font>
<em>10: </em><font color="#ffa600"><em>// have a list of strings that we print out at the</em></font>
<em>11: </em><font color="#ffa600"><em>// end.</em></font>
<em>12: </em><font color="#ffa600"><em>//</em></font>
<em>13: </em>
<em>14: </em><font color="#1919af"><strong>#include</strong></font> &lt;sstream&gt;
<em>15: </em><font color="#1919af"><strong>#include</strong></font> &lt;iomanip&gt;
<em>16: </em><font color="#1919af"><strong>#include</strong></font> &lt;iterator&gt;
<em>17: </em>
<em>18: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;AsmStore.h&quot;</font>
<em>19: </em>
<em>20: </em>using namespace std;
<em>21: </em>
<em>22: </em>AsmStore::AsmStore(bool print_comments) :
<em>23: </em>  _print_comments(print_comments)
<em>24: </em><font color="red"><strong>{</strong></font>
<em>25: </em><font color="red"><strong>}</strong></font>
<em>26: </em>
<em>27: </em>void AsmStore::o(const std::string &amp;str,const char *comment)
<em>28: </em><font color="red"><strong>{</strong></font>
<em>29: </em>  <strong>if</strong> (_print_comments &amp;&amp; comment) <font color="red"><strong>{</strong></font>
<em>30: </em>    ostringstream ss;
<em>31: </em>    ss &lt;&lt; setw(35) &lt;&lt; setiosflags(ios_base::left) &lt;&lt; 
<em>32: </em>      str &lt;&lt; <font color="red">&quot;# &quot;</font> &lt;&lt; comment;
<em>33: </em>    _asm.push_back(ss.str());
<em>34: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em>35: </em>    <strong>if</strong> (!str.empty()) <font color="red"><strong>{</strong></font>
<em>36: </em>       _asm.push_back(str);
<em>37: </em>    <font color="red"><strong>}</strong></font>
<em>38: </em>  <font color="red"><strong>}</strong></font>
<em>39: </em><font color="red"><strong>}</strong></font>
<em>40: </em>
<em>41: </em><font color="#ffa600"><em>// Add code to front.</em></font>
<em>42: </em>void AsmStore::splice_front(AsmStore &amp;as)
<em>43: </em><font color="red"><strong>{</strong></font>
<em>44: </em>  _asm.splice(_asm.begin(),as._asm,as._asm.begin(),as._asm.end());
<em>45: </em><font color="red"><strong>}</strong></font>
<em>46: </em>
<em>47: </em><font color="#ffa600"><em>// Add code to back.</em></font>
<em>48: </em>void AsmStore::splice_back(AsmStore &amp;as)
<em>49: </em><font color="red"><strong>{</strong></font>
<em>50: </em>  _asm.splice(_asm.end(),as._asm,as._asm.begin(),as._asm.end());
<em>51: </em><font color="red"><strong>}</strong></font>
<em>52: </em>
<em>53: </em>void AsmStore::c(const std::string &amp;str,int indent_amt)
<em>54: </em><font color="red"><strong>{</strong></font>
<em>55: </em>  <strong>if</strong> (_print_comments) <font color="red"><strong>{</strong></font>
<em>56: </em>    _asm.push_back(<font color="red">&quot;# &quot;</font> + str);
<em>57: </em>  <font color="red"><strong>}</strong></font>
<em>58: </em><font color="red"><strong>}</strong></font>
<em>59: </em>
<em>60: </em><font color="#ffa600"><em>// Write data to the specified output stream.</em></font>
<em>61: </em>void AsmStore::write(ostream &amp;o) const
<em>62: </em><font color="red"><strong>{</strong></font>
<em>63: </em>  ostream_iterator&lt;string&gt; iter(o,<font color="red">&quot;\n&quot;</font>);
<em>64: </em>  copy(_asm.begin(),_asm.end(),iter);
<em>65: </em><font color="red"><strong>}</strong></font>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
</div>
<!-- String Class -->
<a name="String-Class"></a>
<div class="skribesubsectiontitle"><table width="100%"><tr><td bgcolor="#ffffff"><h3><font color="#8381de">5.10 String Class</font>
</h3></td></tr></table>
</div><div class="subsection">
<!-- cc/String.h -->
<a name="cc/String.h"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">5.10.1 cc/String.h</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em> 1: </em><font color="#ffa600"><em>//</em></font>
<em> 2: </em><font color="#ffa600"><em>// Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.</em></font>
<em> 3: </em><font color="#ffa600"><em>//</em></font>
<em> 4: </em><font color="#ffa600"><em>// You may distribute under the terms of the Artistic License, as specified in</em></font>
<em> 5: </em><font color="#ffa600"><em>// the COPYING file.</em></font>
<em> 6: </em><font color="#ffa600"><em>//</em></font>
<em> 7: </em><font color="#ffa600"><em>//</em></font>
<em> 8: </em><font color="#ffa600"><em>// Very simple string class- a string is a pointer</em></font>
<em> 9: </em><font color="#ffa600"><em>// and a length.  This allows one of these classes</em></font>
<em>10: </em><font color="#ffa600"><em>// to point to data in a read-only mmapped file.</em></font>
<em>11: </em><font color="#ffa600"><em>//</em></font>
<em>12: </em>
<em>13: </em>#ifndef _STRING_H_
<em>14: </em><font color="#1919af"><strong>#define</strong></font> _STRING_H_
<em>15: </em>
<em>16: </em><font color="#1919af"><strong>#include</strong></font> &lt;assert.h&gt;
<em>17: </em><font color="#1919af"><strong>#include</strong></font> &lt;iosfwd&gt;
<em>18: </em>
<em>19: </em><strong>struct</strong> Tokens;
<em>20: </em>
<em>21: </em><strong>class</strong> String <font color="red"><strong>{</strong></font>
<em>22: </em>public:
<em>23: </em>  String() : _ptr(0), _len(0) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>24: </em>  String(const char *p,int n) : _ptr(p), _len(n) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>25: </em>  String(Tokens &amp;tk);
<em>26: </em>  String(const String &amp;x) : _ptr(x._ptr), _len(x._len) <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>27: </em>  <font color="#ffa600"><em>// This will allocate a new string of the given size</em></font>
<em>28: </em>  <font color="#ffa600"><em>// using the garbage collector.</em></font>
<em>29: </em>  String(int n);
<em>30: </em>
<em>31: </em>  bool operator==(String x) const;
<em>32: </em>  bool operator!=(String x) const;
<em>33: </em>
<em>34: </em>  <font color="#ffa600"><em>// This will allocate a new string, containing contents</em></font>
<em>35: </em>  <font color="#ffa600"><em>// + the argument string.  The original contents are</em></font>
<em>36: </em>  <font color="#ffa600"><em>// not modified.</em></font>
<em>37: </em>  String append(String x) const; 
<em>38: </em>
<em>39: </em>  bool empty() const <font color="red"><strong>{</strong></font> <strong>return</strong> !_len; <font color="red"><strong>}</strong></font>;
<em>40: </em>  unsigned size() const <font color="red"><strong>{</strong></font> <strong>return</strong> _len; <font color="red"><strong>}</strong></font>;
<em>41: </em>  const char *data() const <font color="red"><strong>{</strong></font> <strong>return</strong> _ptr; <font color="red"><strong>}</strong></font>;
<em>42: </em>  char operator[](unsigned n) <font color="red"><strong>{</strong></font> assert(n &lt; _len); <strong>return</strong> _ptr[n]; <font color="red"><strong>}</strong></font>;
<em>43: </em>
<em>44: </em>  friend std::ostream &amp;operator&lt;&lt; (std::ostream &amp;,const String &amp;);
<em>45: </em>private:
<em>46: </em>  friend <strong>struct</strong> StringHash;
<em>47: </em>
<em>48: </em>  const char *_ptr;
<em>49: </em>  unsigned _len;
<em>50: </em><font color="red"><strong>}</strong></font>;
<em>51: </em>
<em>52: </em><strong>struct</strong> StringHash <font color="red"><strong>{</strong></font>
<em>53: </em>  size_t operator()(String x) const <font color="red"><strong>{</strong></font>
<em>54: </em>    unsigned long __h = 0;
<em>55: </em>    <strong>for</strong> (unsigned i = 0; i != x._len; ++i)
<em>56: </em>      __h = 5*__h + x._ptr[i];
<em>57: </em>    <strong>return</strong> size_t(__h);
<em>58: </em>  <font color="red"><strong>}</strong></font>;
<em>59: </em><font color="red"><strong>}</strong></font>;
<em>60: </em>
<em>61: </em>inline bool String::operator==(String x) const
<em>62: </em><font color="red"><strong>{</strong></font>
<em>63: </em>  <strong>if</strong> (_len != x._len) <font color="red"><strong>{</strong></font>
<em>64: </em>    <strong>return</strong> false;
<em>65: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em>66: </em>    <strong>return</strong> !strncmp(_ptr,x._ptr,_len);
<em>67: </em>  <font color="red"><strong>}</strong></font>
<em>68: </em><font color="red"><strong>}</strong></font>
<em>69: </em>
<em>70: </em>inline bool String::operator!=(String x) const
<em>71: </em><font color="red"><strong>{</strong></font>
<em>72: </em>  <strong>return</strong> !(*this == x);
<em>73: </em><font color="red"><strong>}</strong></font>
<em>74: </em>
<em>75: </em><font color="#1919af"><strong>#endif</strong></font>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
<!-- cc/String.C -->
<a name="cc/String.C"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">5.10.2 cc/String.C</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em> 1: </em><font color="#ffa600"><em>//</em></font>
<em> 2: </em><font color="#ffa600"><em>// Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.</em></font>
<em> 3: </em><font color="#ffa600"><em>//</em></font>
<em> 4: </em><font color="#ffa600"><em>// You may distribute under the terms of the Artistic License, as specified in</em></font>
<em> 5: </em><font color="#ffa600"><em>// the COPYING file.</em></font>
<em> 6: </em><font color="#ffa600"><em>//</em></font>
<em> 7: </em><font color="#ffa600"><em>//</em></font>
<em> 8: </em><font color="#ffa600"><em>// Very simple string class- a string is a pointer</em></font>
<em> 9: </em><font color="#ffa600"><em>// and a length.  This allows one of these classes</em></font>
<em>10: </em><font color="#ffa600"><em>// to point to data in a read-only mmapped file.</em></font>
<em>11: </em><font color="#ffa600"><em>//</em></font>
<em>12: </em>
<em>13: </em><font color="#1919af"><strong>#include</strong></font> &lt;iostream&gt;
<em>14: </em>
<em>15: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;gc/gc.h&quot;</font>
<em>16: </em>
<em>17: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;String.h&quot;</font>
<em>18: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;Tokens.h&quot;</font>
<em>19: </em>
<em>20: </em>using namespace std;
<em>21: </em>
<em>22: </em>String::String(Tokens &amp;tk) :
<em>23: </em>  _ptr((char*)tk._str.p),
<em>24: </em>  _len(tk._str.l)
<em>25: </em><font color="red"><strong>{</strong></font>
<em>26: </em><font color="red"><strong>}</strong></font>
<em>27: </em>
<em>28: </em>ostream &amp;operator&lt;&lt; (ostream &amp;o,const String &amp;s)
<em>29: </em><font color="red"><strong>{</strong></font>
<em>30: </em>  o.write(s._ptr,s._len);
<em>31: </em>  <strong>return</strong> o;
<em>32: </em><font color="red"><strong>}</strong></font>
<em>33: </em>
<em>34: </em>String String::append(String x) const
<em>35: </em><font color="red"><strong>{</strong></font>
<em>36: </em>  char *s = (char*)GC_malloc(_len+x._len);
<em>37: </em>  memcpy(s,_ptr,_len);
<em>38: </em>  memcpy(s+_len,x._ptr,x._len);
<em>39: </em>  <strong>return</strong> String(s,_len+x._len);
<em>40: </em><font color="red"><strong>}</strong></font>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
</div>
<!-- Miscellaneous Headers -->
<a name="Miscellaneous-Headers"></a>
<div class="skribesubsectiontitle"><table width="100%"><tr><td bgcolor="#ffffff"><h3><font color="#8381de">5.11 Miscellaneous Headers</font>
</h3></td></tr></table>
</div><div class="subsection">
<!-- cc/Channels.h -->
<a name="cc/Channels.h"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">5.11.1 cc/Channels.h</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em> 1: </em><font color="#ffa600"><em>//</em></font>
<em> 2: </em><font color="#ffa600"><em>// Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.</em></font>
<em> 3: </em><font color="#ffa600"><em>//</em></font>
<em> 4: </em><font color="#ffa600"><em>// You may distribute under the terms of the Artistic License, as specified in</em></font>
<em> 5: </em><font color="#ffa600"><em>// the COPYING file.</em></font>
<em> 6: </em><font color="#ffa600"><em>//</em></font>
<em> 7: </em><font color="#ffa600"><em>//</em></font>
<em> 8: </em><font color="#ffa600"><em>// Various channels used for communication.</em></font>
<em> 9: </em><font color="#ffa600"><em>//</em></font>
<em>10: </em>
<em>11: </em>#ifndef _COMMUNICATION_H_
<em>12: </em><font color="#1919af"><strong>#define</strong></font> _COMMUNICATION_H_
<em>13: </em>
<em>14: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;plasma.h&quot;</font>
<em>15: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;Tokens.h&quot;</font>
<em>16: </em>
<em>17: </em><strong>struct</strong> TokChan : public plasma::Channel&lt;Tokens&gt; <font color="red"><strong>{</strong></font><font color="red"><strong>}</strong></font>;
<em>18: </em>
<em>19: </em><font color="#1919af"><strong>#endif</strong></font>
<em>20: </em>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
<!-- cc/Types.h -->
<a name="cc/Types.h"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">5.11.2 cc/Types.h</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em> 1: </em><font color="#ffa600"><em>//</em></font>
<em> 2: </em><font color="#ffa600"><em>// Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.</em></font>
<em> 3: </em><font color="#ffa600"><em>//</em></font>
<em> 4: </em><font color="#ffa600"><em>// You may distribute under the terms of the Artistic License, as specified in</em></font>
<em> 5: </em><font color="#ffa600"><em>// the COPYING file.</em></font>
<em> 6: </em><font color="#ffa600"><em>//</em></font>
<em> 7: </em><font color="#ffa600"><em>//</em></font>
<em> 8: </em><font color="#ffa600"><em>// Miscellaneous common types and info.</em></font>
<em> 9: </em><font color="#ffa600"><em>//</em></font>
<em>10: </em>
<em>11: </em>#ifndef _TYPES_H_
<em>12: </em><font color="#1919af"><strong>#define</strong></font> _TYPES_H_
<em>13: </em>
<em>14: </em><font color="#1919af"><strong>#include</strong></font> &lt;vector&gt;
<em>15: </em><font color="#1919af"><strong>#include</strong></font> &lt;string&gt;
<em>16: </em>
<em>17: </em><font color="#ffa600"><em>// Size of the 'int' type.</em></font>
<em>18: </em>const unsigned IntSize = 4;
<em>19: </em>
<em>20: </em><font color="#ffa600"><em>// Size of the 'char' type.</em></font>
<em>21: </em>const unsigned CharSize = 1;
<em>22: </em>
<em>23: </em><font color="#ffa600"><em>// The machine's word size.  Note that making this different</em></font>
<em>24: </em><font color="#ffa600"><em>// from INT_SIZE may cause serious problems.</em></font>
<em>25: </em>const unsigned WordSize = 4;
<em>26: </em>
<em>27: </em><font color="#ffa600"><em>// Not really used, but it's here.</em></font>
<em>28: </em>const unsigned DoubleSize = 8;
<em>29: </em>
<em>30: </em><font color="#ffa600"><em>// This is a strange multiplier that needs to be used in the allocation</em></font>
<em>31: </em><font color="#ffa600"><em>// of global variables for the GNU Assembler.  Not sure exactly what it</em></font>
<em>32: </em><font color="#ffa600"><em>// represents.</em></font>
<em>33: </em>const unsigned WeirdMultiplier = 4;
<em>34: </em>
<em>35: </em><strong>typedef</strong> std::vector&lt;int&gt; IntVect;
<em>36: </em>
<em>37: </em><font color="#1919af"><strong>#endif</strong></font>
<em>38: </em>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
</div>
</div></td>
</tr></table><div class="skribe-ending">
<hr> 
<p class="ending"><font size="-1">
This <span class="sc">Html</span> page has been produced by 
<a href="http://www.inria.fr/mimosa/fp/Skribe" class="http">Skribe</a>.
<br/>
Last update <em>Wed Nov  9 16:42:03 2005</em>.</font></p></div>
</body>
</html>