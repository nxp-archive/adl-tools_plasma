#LyX 1.3 created this file. For more info see http://www.lyx.org/
\lyxformat 221
\textclass article
\begin_preamble
\usepackage{amsmath,amssymb,amsfonts,textcomp}
\usepackage{color}
\usepackage{hyperref}
\hypersetup{pdftex, colorlinks=true, linkcolor=blue, filecolor=blue, pagecolor=blue, urlcolor=blue, pdfauthor=Brian Kahne}
\usepackage{lmodern}
\newtheorem{theorem}{Theorem}
\date{}
\end_preamble
\language english
\inputencoding default
\fontscheme default
\graphics default
\paperfontsize 11
\spacing single 
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 2
\papersides 1
\paperpagestyle default

\layout Title


\series bold 
An Introduction To The Plasma Language
\layout Author

Brian Kahne 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
dag{}
\end_inset 

, Aseem Gupta 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
ddag{}
\end_inset 

, Peter Wilson 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
dag{}
\end_inset 

, Nikil Dutt 
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
ddag{}
\end_inset 


\newline 

\newline 

\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
dag{}
\end_inset 

 Freescale Semiconductor Inc
\newline 
Austin, TX 78729, USA
\newline 
{bkahne, Peter.Wilson}@freescale.com
\newline 

\newline 

\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
ddag{}
\end_inset 

 Center for Embedded Computer Systems
\newline 
University of California, Irvine
\newline 
Irvine, CA 92697, USA
\newline 
{aseemg, dutt}@uci.edu
\layout Abstract

The ability to enhance single-thread performance, such as by increasing
 clock frequency, is reaching a point of diminishing returns: power is becoming
 a dominating factor and limiting scalability.
 Adding additional cores is a scalable way to increase performance, but
 it requires that system designers have a method for developing multi-threaded
 applications.
\layout Abstract

Plasma, (
\series bold 
P
\series default 
arallel 
\series bold 
LA
\series default 
nguage for 
\series bold 
S
\series default 
ystem 
\series bold 
M
\series default 
odeling and 
\series bold 
A
\series default 
nalysis) is a parallel language for system modeling and multi-threaded applicati
on development implemented as a superset of C++.
 The language extensions are based upon those found in Occam, which is based
 upon CSP (Communicating Sequential Processes) by C.
 A.
 R.
 Hoare.
\layout Abstract

The goal of the Plasma project is to investigate whether a language with
 the appropriate constructs might be used to ease the task of developing
 highly multi-threaded software.\SpecialChar ~
 In addition, through the inclusion of a
 discrete-event simulation API, we seek to simplify the task of system modeling
 and increase productivity through clearer representation and increased
 compile-time checking of the more difficult-to-get-right aspects of systems
 models (the concurrency).
\layout Abstract

The result is a single language which allows users to develop a parallel
 application and then to model it within the context of a system, allowing
 for hardware-software partitioning and various other early tradeoff analyses.\SpecialChar ~

 We believe that this language offers a simpler and more concise syntax
 than other offerings and can be targeted at a large range of potential
 architectures,including heterogeneous systems and those without shared
 memory.
\layout Section

Introduction
\layout Standard

We initiated the Plasma experiment within Freescale after recognising the
 confluence of two separate trends: the rise of multi-core systems (denoting
 a need for languages and tools to program them efficiently) and the increasing
 complexity and importance of software in SoC solutions (making the ability
 to model the software at least as important as the ability to model the
 hardware).
\layout Standard

Plasma, (
\series bold 
P
\series default 
arallel
\series bold 
 L
\series default 
anguage for 
\series bold 
A
\series default 
rchitecture, 
\series bold 
S
\series default 
ystems, 
\series bold 
M
\series default 
odeling and 
\series bold 
A
\series default 
nalysis) is a parallel language for system modeling and multi-threaded applicati
on development implemented as a superset of C++.
 The language extensions are based upon those found in Occam
\begin_inset LatexCommand \cite{OCCAM}

\end_inset 

, which itself was based upon CSP
\begin_inset LatexCommand \cite{CSP}

\end_inset 

 (Communicating Sequential Processes) by C.
 A.
 R.
 Hoare.
\layout Standard

The basic idea is that threads are explicitly created by the user and they
 communicate using typed channels.
 Plasma adds several additional concepts such as shared data structures
 protected by mutual-exclusion code and the ability to easily wait on the
 result of a function launched as a separate thread.
 Although C++ is a difficult language from which to extract formal properties,
 we believe that the combination of CSP (which does have well-understood
 semantics) and an identified subset of Plasma will make this possible.
\layout Standard

Just as there are higher-level languages in the sequential or functional
 domain than C/C++, we are happy to believe in the future existence of languages
 attacking the problems of concurrency at a higher level than Plasma.
 However, we believe that such languages must be built upon some appropriate
 abstractions, and that a language making those abstractions explicit, as
 Plasma does, is highly useful.
\layout Section

Motivation
\layout Standard

The goal of the Plasma project is to investigate two major areas:
\layout Itemize

Whether a language with the appropriate constructs might be used to ease
 the task of system modeling by providing a simple means of representing
 systems models, increase productivity through clearer representation, and
 increase productivity and quality through increased compile-time checking
 of the more difficult-to-get-right aspects of systems models (the concurrency).
 A key constraint for this usage is to present a language 
\begin_inset Quotes eld
\end_inset 

feel
\begin_inset Quotes erd
\end_inset 

 which is natural for processor micro architects and SoC architects; in
 general, while they are comfortable with C (and Verilog) they do not take
 kindly to the complexities of the C++ language and the necessary associated
 class libraries.
 
\layout Itemize

To provide a basis for real systems implementation, including facilities
 important for embedded work including fault tolerance and real-time deadline
 specification.
 The ability to enhance single-thread performance, such as by increasing
 clock frequency, is rapidly diminishing: power is becoming a dominating
 factor and limiting scalability.
 Adding additional cores is a scalable way to increase performance, but
 it requires that customers have a standardized method for developing multi-thre
aded applications.
 A Plasma compiler would allow designers to develop such programs and gain
 the benefit of a single clear simple model of concurrency, sharing and
 communication (as opposed to choosing between a plethora of APIs and libraries)
, and also to gain the benefits of a compiler's ability to detect misuse
 of the language (such as unprotected sharing of data).
 
\layout Standard

A full-blown Plasma system would thus have wide applicability: It could
 be used throughout the life cycle of a design: in the initial stages, it
 can model proposed products and perform early architectural and microarchitectu
ral design trade-offs; to create refinable models of software; to allow
 co-design to identify which portions of the behavior should be implemented
 as software and which as application-specific acceleration hardware; to
 partition and balance the software across the right number of execution
 units; and finally to build an implementation with the software being compiled
 and mapped appropriately to processors and the acceleration behaviors being
 directly synthesized into hardware.
\layout Standard

The current implementation is limited in scope, being intended to allow
 the language to be evaluated for its intended use rather than aiming at
 real system work.
 The intent is to release the implementation under an appropriate open-source
 license in the near future.
\layout Section

Existing Work
\layout Standard

There exists a plethora of languages attempting to solve the problem of
 how to model complex systems.
 They generally fall into two main categories: Those originally derived
 from a hardware description language and those derived from C or C++.
 The first approach, typified by SystemVerilog
\begin_inset LatexCommand \cite{SYSVRLG}

\end_inset 

, does allow the user to raise the level of abstraction, but it still remains
 a language primarily for describing hardware at a relatively low level.
 For example, it has relatively limited abilities for creating new abstract
 data structures.
 It appears unlikely that we could convince customers to develop their software
 using this language.
\layout Standard

The other approach, deriving a language from C or C++, is typified by SpecC
\begin_inset LatexCommand \cite{SPECC}

\end_inset 

, HandelC
\begin_inset LatexCommand \cite{HNDLC}

\end_inset 

, and SystemC
\begin_inset LatexCommand \cite{SYSC}

\end_inset 

.
 The first two are languages with true parallelism: Their compilers are
 able to perform safety checks to guard against common concurrency problems.
 However, they are primarily aimed at describing hardware, though in a manner
 familiar to many programmers.
 This means that they tend to implement a subset of C or provide constructs
 which are very specific to certain types of hardware modeling.
 In addition, the fact that they are based upon C means that they are limited
 in their extensibility, versus the abstraction mechanisms offered by C++.
\layout Standard

SystemC is not a true language in and of itself, but is a class library
 built on top of C++.
 Since it implements parallelism, which is not provided by C++, it can in
 some ways be thought of as its own language, in so far as a traditional
 library is usually thought of as building upon existing facilities of a
 language.
 Since SystemC builds upon C++, it does offer powerful abstraction mechanisms
 and the ability to use and create sophisticated data structures.
\layout Standard

Its main semantic
\begin_inset Foot
collapsed true

\layout Standard

There are clarity problems, too, which are dealt with later.
\end_inset 

 problem, however, is that the compiler is unaware of the concurrency, and
 is thus unable to perform any relevant checks or optimizations.
 In addition, the way in which concurrency and channel communication is
 implemented in SystemC requires the use of C++'s object system.
 While this is not bad in principle, it would be nice to have the ability
 to write a concurrent program in an imperative, C-like fashion for those
 more comfortable with that style.
 In addition, communication between threads, via channels, requires the
 use of virtual functions.
 Taken together, these restrictions mean that SystemC is unlikely to be
 used for actual application development.
 However, it does show the utility of taking a powerful and extensible general
 purpose language and adding a modeling framework on top of it.
\layout Section

An Introduction to Plasma 
\layout Standard

The novel aspect of this work is that Plasma is suitable for use as both
 an applications development language and as a modeling language.
 For application development, both in the embedded and desktop/server realm,
 it provides a convenient means for exploiting parallelism provided by a
 multi-core hardware platform.
 For modeling purposes, the parallelism in the language is used to model
 the parallelism inherent in the design being modeled.
 In either case, a production-ready compiler for Plasma will know about
 this parallelism and be able to create better optimized code than the tradition
al approach of using a threading library.
\layout Standard

For instance, on an explicit thread switch, the compiler need only generate
 code to save the live registers of the current function, rather than the
 entire hardware context.
 In some cases, the matter is not just about optimization, but about actual
 correctness: An optimizer might think that a variable is dead, when in
 fact it is still being used by another thread.
 Useful safety checks might also be made.
 For example, the compiler can ensure that two different threads do not
 write to the same variable unless it is protected by mutual-exclusion code.
\layout Standard

Another goal of Plasma is to add to C++ features that make it easier to
 create robust, correct programs.
 C++ already offers good abstraction mechanisms and strong type-checking.
 However, it lacks, for instance, garbage collection.
 The current Plasma implementation adds garbage collection via the Boehm
 Weiser Garbage Collector
\begin_inset LatexCommand \cite{BOEHM93}

\end_inset 


\begin_inset LatexCommand \cite{BOEHM88}

\end_inset 

, a fully-conservative collector.
 The interface allows the user to work with explicitly-managed memory or
 with garbage-collector managed memory, thus allowing for interoperability
 with existing C++ code.
\layout Standard

In a production version of Plasma we hope to further investigate what else
 could be added in order to make life easier for the programmer.
 For example, we might add default initialization of built-in types so that
 there is no chance of dangling pointers.
 We might also consider the recommendations found within 
\begin_inset LatexCommand \cite{WER}

\end_inset 

.
\layout Subsection

Parallelism
\layout Standard

Plasma inherits its parallelism constructs from Occam and extends them with
 a functional operator, similar to the 
\shape italic 
future
\shape default 
 found in Multilisp
\begin_inset LatexCommand \cite{HAL85}

\end_inset 

.
 For example, to create two threads one uses the 
\shape italic 
par
\shape default 
 block:
\layout LyX-Code

par {
\newline 
 a();
\newline 
 b();
\newline 
}
\newline 
c();
\layout Standard

The functions 
\shape italic 
a()
\shape default 
 and 
\shape italic 
b()
\shape default 
 will run in parallel but will both finish before function 
\shape italic 
c()
\shape default 
 is called.
 Each statement within a par block is launched as a separate thread and
 braces may be used to group multiple statements together.
\layout Standard

A replicated form of 
\shape italic 
par
\shape default 
 exists in the form of the 
\shape italic 
pfor
\shape default 
 block:
\layout LyX-Code

pfor (int i = 0; i != Max; ++i) {
\newline 
 foo(i);
\newline 
}
\layout Standard

In the above example, 
\emph on 
Max
\emph default 
 threads are launched concurrently, each executing the body of the 
\emph on 
pfor
\emph default 
 block, the function 
\emph on 
foo()
\emph default 
.
\layout Standard

To work with a more functional approach, the 
\shape italic 
spawn 
\shape default 
operator may be used:
\layout LyX-Code

Foo x;
\newline 
Result<int> res = 
\layout LyX-Code

  spawn(x.calculate(1,2,3));
\newline 
cout << "The result is: " 
\newline 
     << res.value() << "
\backslash 
n";
\layout Standard

In the example above, the 
\shape italic 
spawn
\shape default 
 operator runs 
\shape italic 
Foo::calculate
\shape default 
 in a separate thread.
 Synchronization occurs when 
\shape italic 
Result::value()
\shape default 
 is called, which returns the result of the thread.
\layout Subsection

Communications
\layout Subsubsection

Channels 
\layout Standard


\begin_inset LatexCommand \label{sub:Channels}

\end_inset 

Communication between threads is handled by typed 
\shape italic 
channels
\shape default 
.
 A channel can be any object which satisfies a certain API and is written
 in a thread-safe manner.
 This means that a channel can be extremely efficient: It does not require
 the use of virtual functions and a production-ready version of the compiler
 may be able to use hardware-optimized intrinsics, if available.
 The standard library provides several varieties, including a single-item
 channel, a queued channel, where the queue size can be fixed or infinite,
 and an interface channel for using the 
\shape italic 
Result
\shape default 
 object returned by a 
\shape italic 
spawn
\shape default 
 function.
\layout Standard

For example, the following code creates two threads, a producer and a consumer:
\layout LyX-Code

typedef Channel<int> IntChan;
\newline 
IntChan c;
\newline 
par {
\newline 
 {
\newline 
  // Thread 1.
\newline 
  writer(1);
\newline 
  writer(2);
\newline 
  writer(3);
\newline 
  writer(-1);
\newline 
 }
\newline 
 {
\newline 
  // Thread 2.
\newline 
  int x;
\newline 
  do {
\newline 
   x = c.get();
\newline 
   imprint ("Result: %d
\backslash 
n",x);
\newline 
  } while (x >= 0);
\newline 
 }
\newline 
}
\layout Standard

The first thread writes numbers to a channel, while the second thread reads
 from this channel and prints them using 
\emph on 
imprint
\emph default 
, a mutex-protected version of 
\shape italic 
printf
\shape default 
.
 Flow-control is handled by the channel itself: If there is no data, then
 a read will block, while if there is already a data item in the channel,
 a write will block.
\layout Standard

Calling 
\shape italic 
get()
\shape default 
 works when only one channel needs to be queried, but a situation often
 arises when multiple channels exist.
 A thread needs to block only if no data exists on any of the channels.
 To support this, Plasma has the 
\shape italic 
alt
\shape default 
 and 
\shape italic 
afor
\shape default 
 constructs:
\layout LyX-Code

alt {
\newline 
 c0.port (int v) {
\newline 
  mprintf ("From port c0: %d
\backslash 
n",v);
\newline 
 }
\newline 
 c1.port (int v) {
\newline 
  mprintf ("From port c1: %d
\backslash 
n",v);
\newline 
 }
\newline 
}
\layout Standard

If none of the channels (
\shape italic 
c0
\shape default 
 or 
\shape italic 
c1
\shape default 
) have any data, then the thread will suspend until data is available on
 any one of the channels.
 At that point, the relevant block of code will be executed.
 If one or more of the channels already has data upon entry to the 
\shape italic 
alt
\shape default 
, then exactly one of the ready channels will be read and its code executed;
 the selection of the channel is non-deterministic.
\layout Standard

Just as Plasma provides the 
\shape italic 
pfor
\shape default 
 construct for replicating threads, it also provides 
\shape italic 
afor
\shape default 
 for replicating channel reads:
\layout LyX-Code

afor (int i = 0; i != c.size(); ++i) {
\newline 
 channels[i].port (int v) {
\newline 
  mprintf ("From port %d: %d
\backslash 
n",i,v);
\newline 
 }
\newline 
}
\layout Standard

In the above example, the 
\shape italic 
afor
\shape default 
 block will suspend the thread if no channels in the channels container
 are ready.
\layout Standard


\shape italic 
Alt
\shape default 
 and 
\shape italic 
afor
\shape default 
 blocks may be nested.
 This allows the user, for example, to wait on multiple containers of channels
 or individual channels combined with containers of channels, etc.
\layout Standard

As mentioned above, the ordering in which channels will be read for 
\shape italic 
alt
\shape default 
 and 
\shape italic 
afor
\shape default 
 blocks is indeterminate.
 To guarantee a specific ordering, the 
\shape italic 
prialt
\shape default 
 and 
\shape italic 
priafor
\shape default 
 constructs may be used.
 These take the same form as 
\shape italic 
alt
\shape default 
 and 
\shape italic 
afor
\shape default 
 except that the channels will be queried in 
\begin_inset Quotes eld
\end_inset 

textual
\begin_inset Quotes erd
\end_inset 

 order in the same way as 
\shape italic 
else if
\shape default 
 clauses are handled in a normal C conditional.
\layout Subsubsection

Synchronous Communication 
\layout Standard

The Plasma standard library contains a special kind of channel, called a
 
\shape italic 
clocked channel
\shape default 
, for modeling synchronous hardware.
 This is a standard channel in the sense that its implementation is just
 a templated class that conforms to the channel API.
 The difference is in its behavior: Writes may occur at any time but reads
 are restricted to clock boundaries, where the clock period is specified
 by a constructor parameter.
\layout Standard

The benefit of this approach is that the user's code remains uncluttered
 by clocking logic.
 Timing changes may be made by simply changing parameters in the declaration
 of the various channels.
 This also retains the basic simplicity of CSP: Threads continue to communicate
 through channels, but the properties of the channels themselves regulate
 this data interchange to clock boundaries.
\layout Standard

The standard library currently consists of a single type of clocked channel,
 called 
\shape italic 
ClockChan
\shape default 
.
 It defaults to storing a single item but it can also act as a queue of
 fixed or arbitrary size via a constructor parameter.
 The behavior remains essentially the same: Writes never block unless the
 queue is full, which might never be the case if the queue size is not fixed.
 Reads, however, are always synchronous.
 Optionally, the size may be set to zero, which means that a write will
 block until a read has removed the data.
 This is useful for modeling a fully interlocked pipeline.
\layout Subsubsection

Shared Data Structures 
\layout Standard

Shared data structures may be easily implemented by using the 
\shape italic 
pMutex
\shape default 
 class modifier:
\layout LyX-Code

pMutex class Foo {
\newline 
 ...
\newline 
public:
\newline 
 pNoMutex bool foo() const;
\newline 
};
\layout Standard

A 
\shape italic 
mutex
\shape default 
 class has all of its public member functions wrapped with serialization
 code (except for the constructors and destructors).
 This may be disabled by using the 
\shape italic 
pNoMutex 
\shape default 
keyword, as shown for the method 
\shape italic 
foo
\shape default 
.
\layout Subsection

Simulation 
\layout Standard

Plasma contains a discrete-event time model for simulation purposes.
 This is not part of the language, per se, but is implemented as a set of
 functions which manipulate the back-end thread package.
 This means that a Plasma implementation designed for applications might
 not support the time model, while an implementation designed for modeling
 would.
\layout Standard

A thread may delay itself by calling 
\shape italic 
pDelay
\shape default 
 and may consume time by calling 
\shape italic 
pBusy
\shape default 
.
 A delay corresponds to a thread waiting for some event to occur; it is
 not consuming any resources and other threads may execute during this time.
 Being busy, on the other hand, means that the thread is working, or consuming
 the processing resources of what it is running on.
 These two functions are the only way in which time advances in simulation
 Plasma: Everything else is considered to occur in zero time.
\layout Standard

What this means is that a user may write real software for an embedded applicati
on in Plasma.
 To gain an understanding of the software's resource requirements, it may
 be annotated with 
\shape italic 
pDelay
\shape default 
 and 
\shape italic 
pBusy
\shape default 
 calls based upon the anticipated behavior of the underlying hardware.
 For instance, a multiply-accumulate loop might require two separate instruction
s, so a call to 
\shape italic 
pBusy 
\shape default 
with a value of two would be made.
 However, this value could be changed in order to understand the effects
 of adding a specific multiply-accumulate instruction.
\layout Standard

Decorating software in this way is both tedious and error-prone; we therefore
 envisage production-quality simulation tools being able to examine and
 annotate the internal representation of a plasma program intended for simulatio
n using target architecture and microarchitecture information to provide
 an appropriate density of automatically-generated annotations.
\layout Standard

Threads may be distributed to multiple 
\begin_inset Quotes eld
\end_inset 

processors
\begin_inset Quotes erd
\end_inset 

 in order to model multiple hardware resources in a simulation.
 As in the real world, in the Plasma simulation universe a thread on one
 processor might be busy (that is, using up processor resources), but this
 does not affect a thread on another processor:
\layout LyX-Code

Processor proc1,proc2;
\newline 
par {
\newline 
 on (proc1) {
\newline 
  <code>
\newline 
  // Does not affect the other thread.
\newline 
  pBusy(100);
\newline 
  <code>
\newline 
 }
\newline 
 on (proc2) {
\newline 
  <code>
\newline 
 }
\newline 
}
\layout Standard

The 
\shape italic 
on
\shape up 
 construct provided by Plasma is a novelty of the language, as it specifically
 allows simulation and application development for multiprocessor systems.
 Other languages do not provide explicit support for multiprocessor systems
 and special code needs to be written 
\begin_inset LatexCommand \cite{Benini}

\end_inset 

.
 
\layout Standard

Processors have their own private ready queues of threads, by default, but
 can be instantiated such that several processors share a single queue.
 This allows for both distributed and SMP systems (and mixes) to be easily
 modeled.
\layout Standard

Each thread may be given a priority.
 Priority-based preemptive scheduling is provided: higher priority threads
 (a lower priority number) execute until completion before ready lower priority
 threads are run.
 The lowest priority threads are time-sliced.
 A delayed high-priority thread may interrupt a lower-priority thread which
 is busy.
\layout Subsection

Power Modeling 
\layout Standard

Plasma supports power modeling by providing some simple hooks for recording
 and retrieving energy consumption on a per-processor basis.
 The model calls 
\shape italic 
pEnergy(energy_t)
\shape default 
 to add to the current processor's consumed-energy value, where energy_t
 is currently defined as a double.
 Calling 
\shape italic 
pGetEnergy(Processor)
\shape default 
 retrieves a processor's consumed energy and clears the value.
 Thus, to monitor power, a thread might regularly query processors for their
 energy and then divide this by the sample period.
\layout Standard

Just as with evaluating compute requirements, a process of step-wise refinement
 may be applied: The user might start with a very coarse-grained analysis
 using average power values, then proceed to refine that by adding different
 energy consumption statements for different paths through the code or compute
 energy by looking at the hamming distance between consecutive data values
 read from a channel.
 Additionally, a model might wrap all calls to 
\shape italic 
pEnergy
\shape default 
 so that a scaling value, based on clock-frequency, might be applied.
 As with the modeling of processor (or resource) utilization mentioned above,
 we envisage the toolchain making use of some architecture-specific power
 information to decorate the code automatically.
\layout Section

Implementation
\layout Standard

Our pilot implementation of Plasma's front-end parser makes use of OpenC++
\begin_inset LatexCommand \cite{CHIBA95}

\end_inset 

 an open-source C++ grammar and meta-object protocol.
 The Plasma front-end processing code is linked in with the OpenC++ framework
 to form the Plasma executable.
\layout Standard

From the user's point of view, using the Plasma program is identical to
 using a normal C++ compiler: You can produce an object file, an executable,
 or link together multiple object files to produce an executable.
 The transformation of the Plasma primitives is generally fairly straightforward.
 Unfortunately, C++'s lack of orthogonality sometimes complicates matters.
 For example, the 
\emph on 
par
\emph default 
 block's contents are moved into individual functions.
 These are then launched as independent threads using the 
\shape italic 
pSpawn
\shape default 
 primitive.
 However, since C++ does not allow nested threads, each function must be
 placed at the global level and any variables used by the code must be passed
 as references.
\layout Standard

The Plasma language is (optionally) garbage collected.
 This is accomplished by using the Boehm Weiser Garbage Collector
\begin_inset LatexCommand \cite{BOEHM93}

\end_inset 


\begin_inset LatexCommand \cite{BOEHM88}

\end_inset 

, a conservative garbage collector.
 In order for it to work with the thread library, a hook was added so that
 the stacks of all threads could be searched during a collection.
\layout Standard

The Plasma threading library is a simple user-mode threading library based
 upon QuickThread
\begin_inset LatexCommand \cite{KEPPEL}

\end_inset 

.
 All threads in this implementation of Plasma run within a single OS process.
 The QuickThreads library only implements thread-switching primitives.
 The scheduler, various queues, etc., are implemented within the Plasma library.
 The thread library generally operates in either of two modes, defined by
 whether calls to 
\shape italic 
pBusy
\shape default 
 are allowed.
 If they are not allowed, then preemption is enabled: An alarm is set using
 a UNIX 
\shape italic 
signal
\shape default 
.
 The signal handler calls the scheduler which schedules a new thread to
 be run.
\layout Standard

If calls to 
\shape italic 
pBusy
\shape default 
 are allowed, then preemption is disabled and all thread switching is done
 cooperatively, either explicitly via calls to functions such as 
\shape italic 
pBusy
\shape default 
, or implicitly, such as by reading from an empty channel.
 In addition, calls to 
\shape italic 
pDelay
\shape default 
 mean that the current thread is added to the delay list; it will only execute
 again once time has advanced sufficiently.
 A call to 
\shape italic 
pBusy
\shape default 
 means that the entire 
\shape italic 
Proc
\shape default 
 object is removed from the list of available processors and added to the
 busy queue; it will only be moved back to the queue once time has advanced
 sufficiently.
\layout Section

System Modeling
\layout Standard

In order to evaluate Plasma's effectiveness for system modeling, we have
 modelled a 2-D Discrete Wavelet Transform (DWT) block, used in the JPEG2000
 and MPEG4 compression standards.
 The multi-resolution representation derived from DWT time-frequency decompositi
on demonstrates extraordinary advantages in signal analysis and compression.
 The full frame nature of DWT decorrelates the image over a large scale
 and eliminates blocking artifacts at high compression ratios which is a
 drawback in block-based transformation standards.
 We compared the implementation of DWT in Plasma with another implementation
 of DWT in SystemC.
\layout Standard

SystemC in its current version has two kind of processes: SC_METHOD and
 SC_THREAD.
 Each process must have ports in order to interface with any other process.
 An SC_METHOD process has a sensitivity list associated with it and whenever
 an event occurs on a signal or a port in the sensitivity list, the process
 executes.
 Such a process completes execution in the same time step (with no delays
 or waits) and returns control back to the simulation kernel.
 Thus, an SC_METHOD process cannot be suspended or contain an infinite loop.
 A process of type SC_THREAD can be suspended and then made to resume execution
 based on a time delay or on occurrence of a certain event; the events may
 be described in a sensitivity list and the 
\emph on 
wait()
\emph default 
 method is used to await their occurrence.
 
\shape up 
By default all SystemC threads are executed in parallel, which in some sense
 is ironic, given that the C++ compiler does not understand parallelism
 well and does no optimizations.

\shape default 
 SystemC does not explicitly support sequential execution.
 The execution sequences of threads are determined by a signal-trigger mechanism
, which means that in order to write a sequential SystemC model the designer
 must add trigger signals and 
\shape italic 
wait() 
\shape default 
statements for each thread.
 For example, in the following piece of code, in order to make 
\shape italic 
b() 
\shape default 
execute after 
\shape italic 
a()
\shape up 
, designers must declare an event 
\shape italic 
a_done 
\shape up 
using sc_event
\shape italic 
, 
\shape up 
which is triggered in the 
\shape default 
last statement of the thread 
\shape italic 
a() 
\shape up 
by using 
\shape italic 
notify() 
\shape up 
method and add a statement in the thread 
\shape italic 
b() 
\shape up 
which makes the execution of the thread wait a
\shape default 
n
\shape up 
 
\shape italic 
a_done:
\layout LyX-Code

sc_event a_done;
\newline 
a(){
\newline 
  ...
\newline 
  a_done.notify();
\newline 
}
\newline 
b(){
\newline 
  wait(a_done);
\newline 
  ...
\newline 
}
\layout Standard


\shape up 
In Plasma, however, threads execute sequentially by default and can be easily
 made to run concurrently using the 
\shape italic 
par 
\shape up 
statement.
 In the following code, 
\shape italic 
a()
\shape up 
 finishes execution, followed by parallel execution of 
\shape italic 
b() 
\shape up 
and 
\shape italic 
c(), 
\shape up 
followed by sequential execution of 
\shape italic 
d():
\layout LyX-Code

a();
\newline 
par {
\newline 
  b();
\newline 
  c();
\newline 
}
\newline 
d();
\layout Standard


\shape up 
The clumsiness of composing a sequence of activities in System C we attribute
 to its
\shape default 
 
\shape up 
goal of describing just hardware systems, in which all elements always execute
\shape default 
 
\shape up 
concurrently; this, however, sharply reduces the usability of the language
 for describing
\shape default 
 
\shape up 
software.

\shape default 
 
\shape up 
SystemC version 2.1 improves on the situation slightly; it provides 
\shape italic 
sc_spawn
\shape up 
, which is used to create a dynamic process instance, but this is also rather
 verbose and still requires threads to be methods of classes.
\layout Standard


\shape up 
Another feature of Plasma is the powerful handling of comm
\shape default 
unication requirements between threads by channels.
 In our experience, communication was less error-prone in Plasma than in
 SystemC.
 This observation is partly due to the fact that the code requirements for
 the communication primitives were a lot more verbose in SystemC.
 SystemC needs three constructs to describe communication between modules:
 Ports, Interfaces and Channels.
 A module has ports through which it communicates with other modules.
 There are three kinds of port defined by 
\shape italic 
sc_port:
\shape default 
 input, output and inout 
\begin_inset LatexCommand \cite{Bhasker}

\end_inset 

.

\shape up 
 An interface declares a set of methods for accessing a channel and is implement
ed by the channel, hence the definition of the methods declared in the interface
 are described in the channel.

\shape default 
 An instance of a port connects a module to a channel, enabling reads from
 and writes to the channel.
 A port can be associated with an arbitrary number of access methods; the
 set of access methods is defined by the interface.
\layout Standard


\begin_inset Float figure
wide false
collapsed false

\layout Standard


\begin_inset Graphics
	filename SystemC-diagram.png
	width 3.1in

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:Ports,-Channels,-and}

\end_inset 

Ports, Channels, and Interfaces in SystemC
\end_inset 


\layout Standard

Figure 
\begin_inset LatexCommand \ref{cap:Ports,-Channels,-and}

\end_inset 

 shows module 
\shape italic 
mod_a
\shape up 
 has a port 
\shape italic 
port_b,
\shape default 
 which can only access methods
\shape italic 
 meth_d()
\shape up 
 and 
\shape italic 
meth_e()
\shape up 
, which are specified in the interface
\shape italic 
 intf_c
\shape up 
.
 The channel
\shape italic 
 chan_f
\shape up 
 contains the declarations of the methods
\shape italic 
 meth_d()
\shape up 
 and 
\shape italic 
meth_e().
 
\shape up 
The module 
\shape italic 
mod_a
\shape up 
 is able to communicate with other modules using channel 
\shape italic 
chan_f
\shape up 
 through an interface 
\shape italic 
intf_c, 
\shape up 
which has the methods 
\shape italic 
meth_d()
\shape up 
 and 
\shape italic 
meth_e()
\shape up 
, for enabling communication over the channel.
 In general, a port is declared using 
\shape italic 
sc_port
\shape up 
 of a specific interface
\shape default 
:
\layout LyX-Code


\shape up 
sc_port<interface_name> port_name;
\layout Standard


\shape italic 
port_name
\shape up 
 is a port, which exhibits the interface behavior as specified by the 
\shape italic 
interface_name.

\shape up 
 Thus, the port can access the methods specified by the interface and consequent
ly can access the channel that is associated with that
\shape default 
 interface.
\layout Standard

An interface is an abstract base class of C++ that inherits from the class
 
\shape italic 
sc_interface.

\shape up 
 Interface, along with the set of access methods is specified as follows:
\layout LyX-Code


\shape up 
class interface_name:
\layout LyX-Code

  
\shape up 
virtual public sc_interface
\layout LyX-Code


\shape up 
{
\layout LyX-Code

  
\shape up 
public:
\layout LyX-Code

  
\shape up 
virtual return_type 
\layout LyX-Code

    
\shape up 
method_name(parameter_list) = 0;
\layout LyX-Code

  ...

\shape up 
 
\layout LyX-Code


\shape up 
};
\layout Standard


\shape up 
A channel is an object that serves as a container for communication and
 synchronization.
 A channel can implement one or more interfaces and has the definitions
 of the methods.
 A channel in SystemC is defined as:
\layout LyX-Code


\shape up 
class channel_name:
\shape default 
 
\layout LyX-Code

  
\shape up 
public sc_module,
\shape default 
 
\layout LyX-Code

  public interface_names
\layout LyX-Code

{
\layout LyX-Code

 public:
\layout LyX-Code

   virtual return_type 
\layout LyX-Code

   method_name(..) {
\newline 
     ...
 
\newline 
   }
\newline 
   ...
\newline 
};
\layout Standard

The above described module will be declared in SystemC as:
\layout LyX-Code

class intf_c: 
\layout LyX-Code

  virtual public sc_interface
\newline 
{
\newline 
  public:
\newline 
    virtual int meth_d(char) = 0;
\newline 
    virtual int meth_e() = 0;
\layout LyX-Code


\shape up 
};
\layout LyX-Code

\layout LyX-Code


\shape up 
class chan_f:
\shape default 
 
\layout LyX-Code

  
\shape up 
public sc_module,
\shape default 
 
\layout LyX-Code

  public intf_c
\newline 
{
\newline 
  public:
\newline 
    virtual int meth_d(char)
\newline 
    {
\newline 
      ...
 
\newline 
    }
\newline 
    virtual int meth_e()
\newline 
    {
\newline 
      ...
 
\newline 
    }
\newline 
  :
\newline 
};
\newline 
SC_MODULE (mod_a){
\newline 
  sc_port <intf_c<int> > port_b;
\newline 
  ...
\newline 
}
\layout Standard

The verbosity and complexity of SystemC as seen here, in order to describe
 the communication between a channel and a module makes this task hard on
 the designer.
 Note that, the above exercise was just to set up the communication primitive
 and declarations, and does not involve statements about any communication
 transaction.
 On the other hand, Plasma has taken care of this problem by providing much
 simpler constructs.
 As seen in Section 
\begin_inset LatexCommand \ref{sub:Channels}

\end_inset 

, channels can be instantiated in one statement and can simply be used by
 any thread.
 Channels can be conveniently set to transfer any custom data structure,
 without affecting the channel's interface and provide a simple user interface
 of 
\shape italic 
write(), read(), get(), ready(), full().
 
\shape up 
It is up to the channel to make sure that these operations are safe and
 to ensure proper flow control.
 For example, let us suppose two threads have to communicate using a complex
 data structure
\shape italic 
 
\shape up 
called 
\shape italic 
packet, 
\shape up 
defined using
\shape italic 
 struct.
 
\shape up 
Then a channel, 
\shape italic 
ChanPack,
\shape up 
 which can be used for transferring data of type 
\shape italic 
packet, 
\shape up 
is declared in a single statement:
\layout LyX-Code


\shape up 
typedef Channel<packet> ChanPack
\shape default 
;
\layout Standard


\shape up 
The threads need to instantiate channels of type 
\shape italic 
ChanPack 
\shape up 
and use the interface.
 For example:
\layout LyX-Code


\shape up 
void Producer_thread (ChanPack &CP)
\layout LyX-Code


\shape up 
{
\layout LyX-Code

  
\shape up 
packet p1;
\layout LyX-Code

  
\shape up 
CP.write(p1);
\layout LyX-Code


\shape up 
}
\layout Standard

Plasma already comes with channels with pre-defined behaviors such as Busy-Chann
el, Queue-Channel, A Timeout Channel, Clocked-Channel.
 Busy-Channel is similar to a regular channel but if a read blocks, it places
 the thread's processor into a busy state.
 This can be used for when waiting on a resource holds up a task, e.g.
 a processor waiting on a load cannot do something else.
 The user can specify a timeslice value in the constructor or specify zero
 to mean no timeslicing.
 Queued channels allow for multiple producers and supports multiple consumers
 also.
 The queue size is not fixed by default, but the user may set a maximum
 size by specifying it in the constructor.
 Timeout channel is used to break out of an 
\shape italic 
alt
\shape up 
 block after a specified amount of simulation time.

\shape default 
 In Plasma, the reads block on empty channels and writes block on full channels
 and it is up to the channel to make sure that these operations are safe
 and to ensure proper flow control.
 Unlike SystemC, the designer is free from the burden of implementing any
 flow control mechanisms for channels.
\layout Standard

Plasma's conciseness reduces the number of errors compared to SystemC.
 Designers can swiftly explore the optimal distribution of an application
 among multiple threads without having to spend too much effort on getting
 the communication primitives right.
\layout Standard

Plasma has also been used in several diverse areas of modeling and application
 development.
 It has been used to model clocked hardware, more specifically a very simple
 RISC pipeline.
 Clocked channels were used and no stage in the pipeline needs to know about
 time or the clock, which is now completely encapsulated in the clocked
 channels.
 The timing of the whole system can thus be modified simply by changing
 the declarations of the clocked channels.
 Plasma was also used to model a large scale networked system of a database
 server, where a series of terminals send requests to a server, which then
 dispatches queries to a database.
 The database either finds that it can answer the query by accessing memory
 or else it has to dispatch a request to a disk array.
 Plasma functions such as 
\shape italic 
pBusy 
\shape up 
and
\shape italic 
 Random 
\shape up 
were used.
 Plasma was also tested for modeling real-time embedded systems by implementing
 a simple engine controller.
 The hardware is modeled as a flywheel and an engine.
 The flywheel has a concept of friction, so that it slows down if the engine
 is not accelerating it.
 The engine has several cylinders and based upon the amount of fuel added,
 the model calculates the new speed of the engine.
 A separate thread is launched for each cylinder and the 
\shape italic 
pBusy 
\shape up 
function is used to consume time in order to understand the load on the
 micro-controller.
 Thus, if the load were too great for a single core device, the threads
 could be distributed over multiple cores by the using the 
\shape italic 
on 
\shape up 
construct
\shape italic 
.
\layout Section

Conclusion 
\layout Standard


\shape up 
Growing system complexity and unmanageable power densities have made multi-core
 processors a popular choice for System on Chips.
 However, the absence of convenient languages for design and development
 of multi-threaded application has been a limiting factor.
 We introduce a new language, Plasma 
\series bold 
(P
\series default 
arallel 
\series bold 
La
\series default 
nguage for 
\series bold 
S
\series default 
ystem 
\series bold 
M
\series default 
odeling and 
\series bold 
A
\series default 
nalysis
\series bold 
), 
\series default 
in an attempt to provide a parallel language for system modeling and multi-threa
ded application development.
 In this work, we have motivated the need for another modeling language
 based on the unsuitability of other contemporary languages.
 Plasma is a superset of C++ with parallel constructs based upon CSP.
 The fact that the language is inherently parallel provides for the potential
 to optimize context switches and perform safety checks to guard against
 common concurrency problems
\shape default 
 at compile time
\shape up 
.
 We also 
\shape default 
discussed 
\shape up 
the various communication primitives provided by the language and compared
 it against 
\shape default 
SystemC
\shape up 
 for 
\shape default 
clarity
\shape up 
.
 Plasma offers explicit support fort multi-processor simulation by featuring
 special constructs, which allow allocation of threads to specific processors.
 In this paper, we also briefly presented the power modeling capabilities
 of Plasma at the system level.
 Plasma will soon be publicly released as a
\shape default 
n
\shape up 
 open source language
\shape default 
.
\begin_inset LatexCommand \BibTeX[ieeetr]{/temp/work/p/plasma/doc/papers/Plasma_MTV_2005}

\end_inset 


\the_end
