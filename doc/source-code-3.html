<!-- 95% W3C COMPLIANT, 95% CSS FREE, RAW HTML -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Example Source Code</title>
 <style type="text/css">
  <!--
  pre { font-family: monospace }
  tt { font-family: monospace }
  code { font-family: monospace }
  p.flushright { text-align: right }
  p.flushleft { text-align: left }
  span.sc { font-variant: small-caps }
  span.sf { font-family: sans-serif }
  span.skribetitle { font-family: sans-serif; font-weight: bolder; font-size: x-large; }
  -->
 </style>
</head>

<body class="section" bgcolor="#ffffff">
<table width="100%" class="skribetitle"><tbody>
<tr><td align="center" bgcolor="#8381de"><div class="skribetitle"><strong><big><big><big>3 Example Source Code -- Embedded Application Example</big></big></big></strong></div><center>
</center>
</td></tr></tbody></table>
<table cellpadding="3" cellspacing="0" width="100%" class="skribe-margins"><tr>
<td align="left" valign="top" class="skribe-left-margin" width="20%" bgcolor="#dedeff"><div class="skribe-left-margin">
<br/><center><table width="97%" border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse;" frame="box" rules="none"><tbody>
<tr bgcolor="#8381de"><th align="center" colspan="1" rowspan="1"><font color="#ffffff"><strong>main page</strong></font></th></tr>
<tr bgcolor="#ffffff"><td align="center" colspan="1" rowspan="1"><table width="100%" border="0" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="left" valign="top" colspan="1" rowspan="1"><strong>top:</strong></td><td align="right" valign="top" colspan="1" rowspan="1"><a href="source-code.html#Example-Source-Code" class="inbound">Example Source Code</a></td></tr>
</tbody></table>
</td></tr>
</tbody></table>
</center>
<br/><br/><center><table width="97%" border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse;" frame="box" rules="none"><tbody>
<tr bgcolor="#8381de"><th align="center" colspan="1" rowspan="1"><font color="#ffffff"><strong>Sections</strong></font></th></tr>
<tr bgcolor="#ffffff"><td align="center" colspan="1" rowspan="1"><table cellspacing="1" cellpadding="1" width="100%" class="toc">
<tbody>
 <tr><td valign="top" align="left">1</td><td colspan="4" width="100%"><a href="source-code-1.html#RISC-Pipeline-Example">RISC Pipeline Example</a></td></tr>
 <tr><td valign="top" align="left">2</td><td colspan="4" width="100%"><a href="source-code-2.html#Network-System-Example">Network System Example</a></td></tr>
 <tr><td valign="top" align="left">3</td><td colspan="4" width="100%"><a href="source-code-3.html#Embedded-Application-Example">Embedded Application Example</a></td></tr>
 <tr><td valign="top" align="left">4</td><td colspan="4" width="100%"><a href="source-code-4.html#Desktop-Application-Example">Desktop Application Example</a></td></tr>
</tbody>
</table>
</td></tr>
</tbody></table>
</center>
</div></td>
<td align="left" valign="top" class="skribe-body"><div class="skribe-body">
<!-- Header Files -->
<a name="Header-Files"></a>
<div class="skribesubsectiontitle"><table width="100%"><tr><td bgcolor="#ffffff"><h3><font color="#8381de">3.1 Header Files</font>
</h3></td></tr></table>
</div><div class="subsection">
<!-- ecu/angle.h -->
<a name="ecu/angle.h"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">3.1.1 ecu/angle.h</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em> 1: </em><font color="#ffa600"><em>//</em></font>
<em> 2: </em><font color="#ffa600"><em>// angle.pa</em></font>
<em> 3: </em><font color="#ffa600"><em>//</em></font>
<em> 4: </em>
<em> 5: </em>#ifndef _ANGLE_H_
<em> 6: </em><font color="#1919af"><strong>#define</strong></font> _ANGLE_H_
<em> 7: </em>
<em> 8: </em>int32 curr_angle(int32 time);
<em> 9: </em>void angle_manager(int32 num_cylinders, Chan &amp;teeth, Chans &amp;ask, Chans &amp;wakeups);
<em>10: </em>
<em>11: </em><font color="#1919af"><strong>#endif</strong></font>
<em>12: </em>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
<!-- ecu/car.h -->
<a name="ecu/car.h"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">3.1.2 ecu/car.h</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em> 1: </em><font color="#ffa600"><em>//</em></font>
<em> 2: </em><font color="#ffa600"><em>// car.h:  Accelerator, etc..</em></font>
<em> 3: </em><font color="#ffa600"><em>//</em></font>
<em> 4: </em>
<em> 5: </em>#ifndef _CAR_H_
<em> 6: </em><font color="#1919af"><strong>#define</strong></font> _CAR_H_
<em> 7: </em>
<em> 8: </em>void accelerator(int32 simtime, Chan &amp;acc_query, Chan &amp;acc_val);
<em> 9: </em>void starter(Chan &amp;to_starter, Chan &amp;started);
<em>10: </em>
<em>11: </em><font color="#1919af"><strong>#endif</strong></font>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
<!-- ecu/configuration.h -->
<a name="ecu/configuration.h"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">3.1.3 ecu/configuration.h</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em> 1: </em><font color="#ffa600"><em>//</em></font>
<em> 2: </em><font color="#ffa600"><em>// configuration.sw</em></font>
<em> 3: </em><font color="#ffa600"><em>//</em></font>
<em> 4: </em>
<em> 5: </em><font color="#ffa600"><em>// configuration globals</em></font>
<em> 6: </em>
<em> 7: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;plasma.h&quot;</font>
<em> 8: </em>
<em> 9: </em>#ifndef _CONFIGURATION_
<em>10: </em><font color="#1919af"><strong>#define</strong></font> _CONFIGURATION_
<em>11: </em>
<em>12: </em><strong>extern</strong> const char *version;
<em>13: </em><strong>extern</strong> const char *copyright;
<em>14: </em>
<em>15: </em><strong>typedef</strong> int int32;
<em>16: </em>
<em>17: </em><font color="#ffa600"><em>// platform</em></font>
<em>18: </em><strong>extern</strong> plasma::Processor zen;
<em>19: </em><strong>extern</strong> plasma::Processor tpu;
<em>20: </em><strong>extern</strong> plasma::Processor hardware;
<em>21: </em>
<em>22: </em><font color="#ffa600"><em>// performance</em></font>
<em>23: </em><strong>extern</strong> int32 cpu_MIPS[3];       <font color="#ffa600"><em>// slot n holds mips for cpu n</em></font>
<em>24: </em>
<em>25: </em><strong>extern</strong> const int32 zen_mips;
<em>26: </em><strong>extern</strong> const int32 tpu_mips;
<em>27: </em>
<em>28: </em><font color="#ffa600"><em>// ticks per second</em></font>
<em>29: </em><strong>extern</strong> const int32 ticks_per_second;            <font color="#ffa600"><em>// a tick is a microsecond</em></font>
<em>30: </em>
<em>31: </em><font color="#ffa600"><em>// globals</em></font>
<em>32: </em><strong>extern</strong> double fuelrate;                     <font color="#ffa600"><em>// units of fuel per second:    ml per sec</em></font>
<em>33: </em><strong>extern</strong> double fuelpush;                     <font color="#ffa600"><em>// impulse per unit of fuel:    newton-seconds per ml</em></font>
<em>34: </em><strong>extern</strong> double mass;                         <font color="#ffa600"><em>// 'weight' of car :            kg</em></font>
<em>35: </em><strong>extern</strong> double speed;                    <font color="#ffa600"><em>// car speed:                   meters/sec</em></font>
<em>36: </em>
<em>37: </em><strong>extern</strong> double speedratio;               <font color="#ffa600"><em>// 'rpm' per unit speed</em></font>
<em>38: </em><strong>extern</strong> double friction;                     <font color="#ffa600"><em>// coefficient of friction</em></font>
<em>39: </em>
<em>40: </em><strong>extern</strong> int32 num_teeth;                 <font color="#ffa600"><em>// number of teeth on flywheel</em></font>
<em>41: </em><strong>extern</strong> int32 num_cylinders;             <font color="#ffa600"><em>// number of cylinders.</em></font>
<em>42: </em>const int32 cylinder_max = 64;	    <font color="#ffa600"><em>// don't handle engines with more than this num of cyls</em></font>
<em>43: </em>
<em>44: </em><strong>extern</strong> int32 tooth_chunk;
<em>45: </em>                                 
<em>46: </em><strong>extern</strong> const int32 circle;	<font color="#ffa600"><em>// a complete circle has this number of units (a million)</em></font>
<em>47: </em>
<em>48: </em><font color="#ffa600"><em>// the shared accelerator variable</em></font>
<em>49: </em><strong>extern</strong> int32 gAccelerator;
<em>50: </em>
<em>51: </em><font color="#ffa600"><em>// ecu asking injector to squirt fuel</em></font>
<em>52: </em><strong>struct</strong> fuel_request <font color="red"><strong>{</strong></font>
<em>53: </em>  int32 squirt_time;
<em>54: </em>  double fuel_amount;
<em>55: </em><font color="red"><strong>}</strong></font>;
<em>56: </em>
<em>57: </em><strong>typedef</strong> plasma::Channel&lt;int&gt; Chan;
<em>58: </em><strong>typedef</strong> plasma::Channel&lt;fuel_request&gt; FuelChan;
<em>59: </em>
<em>60: </em><strong>typedef</strong> std::vector&lt;Chan&gt; Chans;
<em>61: </em><strong>typedef</strong> std::vector&lt;FuelChan&gt; FuelChans;
<em>62: </em>
<em>63: </em><font color="#ffa600"><em>// logging file.</em></font>
<em>64: </em><strong>extern</strong> FILE *logfile;
<em>65: </em>    
<em>66: </em><font color="#ffa600"><em>// the shared variables for angle management</em></font>
<em>67: </em><strong>extern</strong> int32 measured_angle, est_angle_rate, est_angle_accel;       <font color="#ffa600"><em>// parameters of angle movement</em></font>
<em>68: </em><strong>extern</strong> int32 measured_t;                                    <font color="#ffa600"><em>// time at which params valid</em></font>
<em>69: </em>
<em>70: </em><font color="#1919af"><strong>#endif</strong></font>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
<!-- ecu/constants.h -->
<a name="ecu/constants.h"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">3.1.4 ecu/constants.h</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em> 1: </em><font color="#ffa600"><em>// constants.sw</em></font>
<em> 2: </em>
<em> 3: </em><font color="#ffa600"><em>// names for the base values of time, mass,  distance, volume and force</em></font>
<em> 4: </em>
<em> 5: </em>#ifndef _CONSTANTS_
<em> 6: </em><font color="#1919af"><strong>#define</strong></font> _CONSTANTS_
<em> 7: </em>
<em> 8: </em>const double    musec   = 1.0,
<em> 9: </em>                msec    = musec * 1000.0,
<em>10: </em>                sec     = msec * 1000.0,
<em>11: </em>                min     = sec * 60.0,
<em>12: </em>                hour    = min * 60.0,
<em>13: </em>                day     = hour * 24.0,
<em>14: </em>                
<em>15: </em>                mugram  = 1.0,
<em>16: </em>                mgram   = mugram * 1000.0,
<em>17: </em>                gram    = mgram * 1000.0,
<em>18: </em>                kg      = gram * 1000.0,
<em>19: </em>                
<em>20: </em>                mum     = 1.0,
<em>21: </em>                mm      = 1000.0 * mum,
<em>22: </em>                meter   = 1000.0 * mm,
<em>23: </em>                km      = 1000.0 * meter,
<em>24: </em>                
<em>25: </em>                mul     = 1.0,
<em>26: </em>                ml      = 1000.0 * mul,
<em>27: </em>                liter   = 1000.0 * ml,
<em>28: </em>                
<em>29: </em>                mn      = 1000.0,
<em>30: </em>                newton  = 1000.0 * mn;
<em>31: </em>
<em>32: </em><font color="#1919af"><strong>#endif</strong></font>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
<!-- ecu/engine.h -->
<a name="ecu/engine.h"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">3.1.5 ecu/engine.h</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em> 1: </em><font color="#ffa600"><em>//</em></font>
<em> 2: </em><font color="#ffa600"><em>// engine.h:  Engine model.</em></font>
<em> 3: </em><font color="#ffa600"><em>//</em></font>
<em> 4: </em>
<em> 5: </em>#ifndef _ENGINE_H_
<em> 6: </em><font color="#1919af"><strong>#define</strong></font> _ENGINE_H_
<em> 7: </em>
<em> 8: </em>void engine(FuelChans &amp;inject, Chans &amp;spark);
<em> 9: </em>void flywheel(Chan &amp;from_flywheel, Chan &amp;to_starter);
<em>10: </em>
<em>11: </em><font color="#1919af"><strong>#endif</strong></font>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
<!-- ecu/utilities.h -->
<a name="ecu/utilities.h"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">3.1.6 ecu/utilities.h</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em> 1: </em><font color="#ffa600"><em>//</em></font>
<em> 2: </em><font color="#ffa600"><em>// utilities.h</em></font>
<em> 3: </em><font color="#ffa600"><em>//</em></font>
<em> 4: </em>
<em> 5: </em>#ifndef _UTILITIES_H_
<em> 6: </em><font color="#1919af"><strong>#define</strong></font> _UTILITIES_H_
<em> 7: </em>
<em> 8: </em>void Compute(int32 work);
<em> 9: </em>
<em>10: </em><font color="#1919af"><strong>#endif</strong></font>
<em>11: </em>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
</div>
<!-- Implementation Files -->
<a name="Implementation-Files"></a>
<div class="skribesubsectiontitle"><table width="100%"><tr><td bgcolor="#ffffff"><h3><font color="#8381de">3.2 Implementation Files</font>
</h3></td></tr></table>
</div><div class="subsection">
<!-- ecu/angle.pa -->
<a name="ecu/angle.pa"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">3.2.7 ecu/angle.pa</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em>  1: </em><font color="#ffa600"><em>//</em></font>
<em>  2: </em><font color="#ffa600"><em>// angle.pa</em></font>
<em>  3: </em><font color="#ffa600"><em>//</em></font>
<em>  4: </em>
<em>  5: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;configuration.h&quot;</font>
<em>  6: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;utilities.h&quot;</font>
<em>  7: </em>
<em>  8: </em>using namespace std;
<em>  9: </em>using namespace plasma;
<em> 10: </em>
<em> 11: </em><font color="#ffa600"><em>// the angle manager for the ecu</em></font>
<em> 12: </em>
<em> 13: </em><font color="#ffa600"><em>// ---------------------- curr_angle ---------------</em></font>
<em> 14: </em>int32 curr_angle(int32 time) 
<em> 15: </em><font color="red"><strong>{</strong></font>
<em> 16: </em>  <font color="#ffa600"><em>// returns best estimate of current angle using global angle, time and angle rate info</em></font>
<em> 17: </em>  int32 d_angle, angle_now, dt;
<em> 18: </em>    
<em> 19: </em>  <font color="#ffa600"><em>// find out what the angle was when the last tooth was seen</em></font>
<em> 20: </em>  <font color="#ffa600"><em>// then compute where we should be given that and the angle rate</em></font>
<em> 21: </em>    
<em> 22: </em>  <font color="#ffa600"><em>//printf(&quot;\ncurr_angle::last angle =%ld at %ld&quot;, measured_angle, measured_t);</em></font>
<em> 23: </em>  dt = time - measured_t;
<em> 24: </em>  <font color="#ffa600"><em>//printf(&quot;::dt=%ld&quot;, dt);</em></font>
<em> 25: </em>  d_angle = dt * est_angle_rate;
<em> 26: </em>  angle_now = measured_angle + d_angle;
<em> 27: </em>  <font color="#ffa600"><em>//printf(&quot;::dangle=%ld rate=%ld ==&gt; angle now = %ld&quot;, d_angle, est_angle_rate, angle_now);</em></font>
<em> 28: </em>  <strong>return</strong> angle_now;
<em> 29: </em><font color="red"><strong>}</strong></font>
<em> 30: </em>
<em> 31: </em><font color="#ffa600"><em>// ---------------------- angle_to_time ------------</em></font>
<em> 32: </em><strong>static</strong> int32 angle_to_time(int32 time, int32 target_angle) 
<em> 33: </em><font color="red"><strong>{</strong></font>
<em> 34: </em>  <font color="#ffa600"><em>// uses stored angle info to convert a future angle to expected time of arrival</em></font>
<em> 35: </em>  <font color="#ffa600"><em>// initially just use angle rate (wrap in accel later)</em></font>
<em> 36: </em>  <font color="#ffa600"><em>// returns how long you must wait to get to the angle</em></font>
<em> 37: </em>        
<em> 38: </em>  int32 dt, angle_now;
<em> 39: </em>        
<em> 40: </em>  <font color="#ffa600"><em>// estimate what our current engine angle is</em></font>
<em> 41: </em>  angle_now = curr_angle(time);
<em> 42: </em>        
<em> 43: </em>  <font color="#ffa600"><em>// see whether the target angle is more than this or less</em></font>
<em> 44: </em>  <font color="#ffa600"><em>// if less, then it is for the next time around</em></font>
<em> 45: </em>        
<em> 46: </em>  <font color="#ffa600"><strong>/*</strong></font>
<em> 47: </em><font color="#ffa600"><strong>    if (target_angle &lt; angle_now) {</strong></font>
<em> 48: </em><font color="#ffa600"><strong>    target_angle = target_angle + circle;</strong></font>
<em> 49: </em><font color="#ffa600"><strong>    }</strong></font>
<em> 50: </em><font color="#ffa600"><strong>  */</strong></font>    
<em> 51: </em>  <font color="#ffa600"><em>// now compute how long we have to wait to get to target angle</em></font>
<em> 52: </em>  dt = (target_angle - angle_now)/est_angle_rate; 
<em> 53: </em>        
<em> 54: </em>  <font color="#ffa600"><em>//printf(&quot;..wait %ld ticks for angle&quot;, dt);</em></font>
<em> 55: </em>  
<em> 56: </em>  <strong>if</strong> (dt &lt; 0) <font color="red"><strong>{</strong></font>
<em> 57: </em>    printf(<font color="red">&quot;\n\t*** angle-to-time for %d at %d: negative dt %d&quot;</font>,
<em> 58: </em>           target_angle, time, dt);
<em> 59: </em>    dt = 0;
<em> 60: </em>  <font color="red"><strong>}</strong></font>
<em> 61: </em>  <strong>return</strong> dt;
<em> 62: </em><font color="red"><strong>}</strong></font>
<em> 63: </em>
<em> 64: </em><font color="#ffa600"><em>// ---------------------- signal_cylinder ------------	</em></font>
<em> 65: </em>void signal_cylinder(int32 wakeangle, Chan &amp;awake) 
<em> 66: </em><font color="red"><strong>{</strong></font>       
<em> 67: </em>  <font color="#ffa600"><em>// compute the time we need to wake up at</em></font>
<em> 68: </em>  int32 dt = angle_to_time(pTime(), wakeangle);
<em> 69: </em>  <font color="#ffa600"><em>//printf(&quot;\n\tsignal::angle = %ld;dt -&gt; %ld&quot;, wakeangle, dt);</em></font>
<em> 70: </em>  
<em> 71: </em>  <font color="#ffa600"><em>// tell the cylinder</em></font>
<em> 72: </em>  awake.write(dt);  
<em> 73: </em><font color="red"><strong>}</strong></font>
<em> 74: </em>
<em> 75: </em><font color="#ffa600"><em>// ---------------------- track ------------------	</em></font>
<em> 76: </em><strong>static</strong> void track(Chan &amp;teeth, Chans &amp;tooth_marks) 
<em> 77: </em><font color="red"><strong>{</strong></font>
<em> 78: </em>  <font color="#ffa600"><em>// a simple digital filter to extract tooth rate</em></font>
<em> 79: </em>  <font color="#ffa600"><em>// every time it gets a tooth, it broadcasts to the cylinders so they can do The Right Thing</em></font>
<em> 80: </em>  int32 tooth, angle_rate1;
<em> 81: </em>        
<em> 82: </em>  pSetPriority(1);
<em> 83: </em>                            
<em> 84: </em>  measured_t = pTime();
<em> 85: </em>
<em> 86: </em>  measured_angle = 0;
<em> 87: </em>  est_angle_rate = 0;
<em> 88: </em>  est_angle_accel = 0;
<em> 89: </em>  printf(<font color="red">&quot;\n%08lld::tooth digital filter starting..&quot;</font>, pTime());
<em> 90: </em>        
<em> 91: </em>  <font color="#ffa600"><em>// first sample</em></font>
<em> 92: </em>  tooth = teeth.get();
<em> 93: </em>  measured_angle = tooth;
<em> 94: </em>  est_angle_rate = tooth_chunk/(pTime() - measured_t);              <font color="#ffa600"><em>// a tooth's worth of degrees in time dt</em></font>
<em> 95: </em>  measured_t = pTime();                                         <font color="#ffa600"><em>// timestamp the data</em></font>
<em> 96: </em>        
<em> 97: </em>  printf(<font color="red">&quot;\n%08lld::tooth digital filter received sample 1..&quot;</font>, pTime());
<em> 98: </em>  printf(<font color="red">&quot;\n\tangle = %d rate = %d, accel = %d &quot;</font>, measured_angle, est_angle_rate, est_angle_accel);
<em> 99: </em>  Compute(50);
<em>100: </em>        
<em>101: </em>  <font color="#ffa600"><em>// second sample</em></font>
<em>102: </em>  tooth = teeth.get();
<em>103: </em>  angle_rate1 = tooth_chunk/(pTime() - measured_t);
<em>104: </em>  est_angle_rate = (est_angle_rate + angle_rate1)/2;
<em>105: </em>        
<em>106: </em>  measured_t = pTime();
<em>107: </em>  printf(<font color="red">&quot;\n%08lld::tooth digital filter received sample 2..&quot;</font>, pTime());
<em>108: </em>  printf(<font color="red">&quot;\n\tangle = %d rate = %d&quot;</font>, measured_angle, est_angle_rate);
<em>109: </em>        
<em>110: </em>  Compute(50);
<em>111: </em>        
<em>112: </em>  <font color="#ffa600"><em>// loop</em></font>
<em>113: </em>  
<em>114: </em>  <strong>while</strong> (true) <font color="red"><strong>{</strong></font>
<em>115: </em>    int32 dt;
<em>116: </em>            
<em>117: </em>    <font color="#ffa600"><em>// tooth digital filter loop</em></font>
<em>118: </em>    tooth = teeth.get();
<em>119: </em>            
<em>120: </em>    <font color="#ffa600"><em>//load = ExecInfo(TaskInstructions);</em></font>
<em>121: </em>            
<em>122: </em>    measured_angle = tooth * tooth_chunk;
<em>123: </em>            
<em>124: </em>    dt = pTime() - measured_t;
<em>125: </em>            
<em>126: </em>    <font color="#ffa600"><em>//printf(&quot;\n%ld::tooth %ld seen -&gt; angle %ld; measured time = %ld; dt = %ld&quot;, </em></font>
<em>127: </em>    <font color="#ffa600"><em>//	Now, tooth, measured_angle, measured_t, dt);</em></font>
<em>128: </em>    measured_t = pTime();
<em>129: </em>            
<em>130: </em>    <strong>if</strong> (dt &gt; 0) <font color="red"><strong>{</strong></font>
<em>131: </em>      fprintf(logfile, <font color="red">&quot;\nTDF::%8lld::tooth %d&quot;</font>, pTime(), tooth);
<em>132: </em>                
<em>133: </em>      est_angle_rate = tooth_chunk/dt;                              <font color="#ffa600"><em>// rate from prev tooth</em></font>
<em>134: </em>      <font color="#ffa600"><em>//printf(&quot; ==&gt; est_angle_rate = %ld&quot;, est_angle_rate); </em></font>
<em>135: </em>                
<em>136: </em>    <font color="red"><strong>}</strong></font>
<em>137: </em>                
<em>138: </em>    <font color="#ffa600"><em>// now notify all cylinders of tooth arrival</em></font>
<em>139: </em>    pfor (int i = 0; i != num_cylinders; ++i) <font color="red"><strong>{</strong></font>
<em>140: </em>      tooth_marks[i].write(tooth);
<em>141: </em>    <font color="red"><strong>}</strong></font>
<em>142: </em>            
<em>143: </em>    <font color="#ffa600"><em>//load = ExecInfo(TaskInstructions) - load;</em></font>
<em>144: </em>    <font color="#ffa600"><em>//printf(&quot;\n---tooth digital filter loop - compute() is for %ld ticks&quot;, load);</em></font>
<em>145: </em>    Compute(350);
<em>146: </em>  <font color="red"><strong>}</strong></font> 
<em>147: </em><font color="red"><strong>}</strong></font>
<em>148: </em>
<em>149: </em><font color="#ffa600"><em>// --------------------- cylinder_wake -----------------    </em></font>
<em>150: </em><strong>static</strong> void cylinder_wake(int32 index, Chan &amp;tooth, Chan &amp;ask, Chan &amp;awake) 
<em>151: </em><font color="red"><strong>{</strong></font>
<em>152: </em>  <font color="#ffa600"><em>// one instance per cylinder</em></font>
<em>153: </em>  <font color="#ffa600"><em>// tooth counts toothticks from the digital filter; </em></font>
<em>154: </em>  <font color="#ffa600"><em>// ask specifies a tooth to wait for from my cylinder</em></font>
<em>155: </em>  <font color="#ffa600"><em>// awake sigals back to the cylinder, the value being the time at which he should awake</em></font>
<em>156: </em>        
<em>157: </em>  <font color="#ffa600"><em>//int32 waketime;                 // the time to wake up at</em></font>
<em>158: </em>  int32 waketooth;          <font color="#ffa600"><em>// the tooth to wake up on</em></font>
<em>159: </em>  int32 currtooth;          <font color="#ffa600"><em>// the tooth we just saw</em></font>
<em>160: </em>  int32 wakeangle;          <font color="#ffa600"><em>// the angle we want to wake up at</em></font>
<em>161: </em>        
<em>162: </em>  printf(<font color="red">&quot;\nCylinder-wake[%d] starting...&quot;</font>, index);
<em>163: </em>        
<em>164: </em>  waketooth = -1;
<em>165: </em>  currtooth = -2;
<em>166: </em>  wakeangle = 0;
<em>167: </em>        
<em>168: </em>  pSetPriority(1);
<em>169: </em>        
<em>170: </em>  <strong>while</strong> (true) <font color="red"><strong>{</strong></font>
<em>171: </em>    alt <font color="red"><strong>{</strong></font>
<em>172: </em>      tooth.port(int ct) <font color="red"><strong>{</strong></font>
<em>173: </em>        currtooth = ct;
<em>174: </em>
<em>175: </em>        <font color="#ffa600"><em>// we just got a current tooth</em></font>
<em>176: </em>        <font color="#ffa600"><em>//printf(&quot;\n\tcylinder-wake[%ld] saw tooth %ld want t %ld&quot;, index, currtooth, waketooth);</em></font>
<em>177: </em>        <strong>if</strong> (waketooth == currtooth) <font color="red"><strong>{</strong></font>
<em>178: </em>          <font color="#ffa600"><em>// note the match</em></font>
<em>179: </em>          <font color="#ffa600"><em>//printf(&quot;\n\tcylinder-wake[%ld] saw tooth %ld matches tooth %ld for wakeangle %ld&quot;, </em></font>
<em>180: </em>          <font color="#ffa600"><em>//    index, currtooth, waketooth, wakeangle);</em></font>
<em>181: </em>    
<em>182: </em>          signal_cylinder(wakeangle, awake);
<em>183: </em>          waketooth = -1;
<em>184: </em>          Compute(83);
<em>185: </em>        <font color="red"><strong>}</strong></font>
<em>186: </em>      <font color="red"><strong>}</strong></font>
<em>187: </em>                    
<em>188: </em>      ask.port(int wa) <font color="red"><strong>{</strong></font>
<em>189: </em>        wakeangle = wa;
<em>190: </em>        int32 angle_now;
<em>191: </em>        int32 target_tooth;
<em>192: </em>        <font color="#ffa600"><em>// we just got given an angle request, which we've captured in wakeangle                    </em></font>
<em>193: </em>                    
<em>194: </em>        <font color="#ffa600"><em>// see if this is for a smaller angle than where we're already at</em></font>
<em>195: </em>        angle_now = curr_angle(pTime());
<em>196: </em>        target_tooth =      wakeangle/tooth_chunk;
<em>197: </em>        <font color="#ffa600"><em>//printf(&quot;\n%ld::cylinder-wake[%ld] saw request for %ld; curr angle ~ %ld waketooth=%ld target_tooth=%ld&quot;, </em></font>
<em>198: </em>        <font color="#ffa600"><em>//	Now, index, wakeangle, angle_now, waketooth, target_tooth); </em></font>
<em>199: </em>        <strong>if</strong> (angle_now &gt; wakeangle) <font color="red"><strong>{</strong></font>
<em>200: </em>          <font color="#ffa600"><em>// then we need to wake up in the future CHECK THIS FIRST!!</em></font>
<em>201: </em>          waketooth = wakeangle / tooth_chunk;              <font color="#ffa600"><em>// tooth before the angle we want</em></font>
<em>202: </em>          <font color="#ffa600"><em>//printf(&quot;==&gt; toothchunk = %ld tooth wanted = %ld&quot;, tooth_chunk, waketooth);</em></font>
<em>203: </em>          Compute(77);
<em>204: </em>        <font color="red"><strong>}</strong></font> 
<em>205: </em>        <strong>else</strong> <strong>if</strong> (target_tooth == currtooth) <font color="red"><strong>{</strong></font>
<em>206: </em>          <font color="#ffa600"><em>// ok, we're still in this tooth</em></font>
<em>207: </em>          <font color="#ffa600"><em>//printf(&quot;==&gt; got request for currtooth %ld == targettooth&quot;, currtooth);	</em></font>
<em>208: </em>          waketooth = -1;
<em>209: </em>          signal_cylinder(wakeangle, awake);
<em>210: </em>          Compute(95);
<em>211: </em>        <font color="red"><strong>}</strong></font>
<em>212: </em>        <strong>else</strong> <font color="red"><strong>{</strong></font>
<em>213: </em>          waketooth = wakeangle / tooth_chunk;
<em>214: </em>          <font color="#ffa600"><em>//printf(&quot;==&gt; need new waketooth %ld&quot;, waketooth);</em></font>
<em>215: </em>          Compute(51);
<em>216: </em>        <font color="red"><strong>}</strong></font>
<em>217: </em>      <font color="red"><strong>}</strong></font>
<em>218: </em>    <font color="red"><strong>}</strong></font>
<em>219: </em>  <font color="red"><strong>}</strong></font>
<em>220: </em><font color="red"><strong>}</strong></font>
<em>221: </em>    
<em>222: </em><font color="#ffa600"><em>// ---------------------- angle_manager -----------------</em></font>
<em>223: </em>void angle_manager(int32 num_cylinders, Chan &amp;teeth, Chans &amp;ask, Chans &amp;wakeups) 
<em>224: </em><font color="red"><strong>{</strong></font>
<em>225: </em>  <font color="#ffa600"><em>// we get raw ticks on teeth (we get the tooth number)</em></font>
<em>226: </em>  <font color="#ffa600"><em>// ask[] provides a request that a client gets woken up at a specific angle</em></font>
<em>227: </em>  <font color="#ffa600"><em>// clients being numbered by index</em></font>
<em>228: </em>  <font color="#ffa600"><em>// client suspends on responses[index] and gets woken up when angle turns up</em></font>
<em>229: </em>  
<em>230: </em>  Chans tooth_marks(cylinder_max);
<em>231: </em>  Chans requests(cylinder_max);
<em>232: </em>  Chan tooth_request;
<em>233: </em>                                                            
<em>234: </em>  pSetPriority(1);
<em>235: </em>        
<em>236: </em>  par <font color="red"><strong>{</strong></font>
<em>237: </em>    pfor(int i = 0; i != num_cylinders; ++i) <font color="red"><strong>{</strong></font>
<em>238: </em>      <font color="#ffa600"><em>//service_request(i, ask[i], tooth_request, tooth_marks[i], wakeups[i]);</em></font>
<em>239: </em>      cylinder_wake(i, tooth_marks[i], ask[i], wakeups[i]);
<em>240: </em>    <font color="red"><strong>}</strong></font>
<em>241: </em>    track(teeth, tooth_marks);
<em>242: </em>  <font color="red"><strong>}</strong></font>
<em>243: </em><font color="red"><strong>}</strong></font>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
<!-- ecu/car.pa -->
<a name="ecu/car.pa"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">3.2.8 ecu/car.pa</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em> 1: </em><font color="#ffa600"><em>//</em></font>
<em> 2: </em><font color="#ffa600"><em>// car.pa</em></font>
<em> 3: </em><font color="#ffa600"><em>//</em></font>
<em> 4: </em>
<em> 5: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;configuration.h&quot;</font>
<em> 6: </em>
<em> 7: </em>using namespace std;
<em> 8: </em>using namespace plasma;
<em> 9: </em>
<em>10: </em><font color="#ffa600"><em>// ----------------- respond ---------------</em></font>
<em>11: </em><strong>static</strong> void respond(Chan &amp;req, Chan &amp;accel_val, int32 simtime, int32 &amp;position) 
<em>12: </em><font color="red"><strong>{</strong></font>
<em>13: </em>  <font color="#ffa600"><em>// if someone wants to know what the accelerator setting is, respond() tells 'em</em></font>
<em>14: </em>  <strong>while</strong> (true) <font color="red"><strong>{</strong></font>
<em>15: </em>    req.get();
<em>16: </em>    <font color="#ffa600"><em>// printf(&quot;\n**Accelerator asked for position; responding with %ld at %ld&quot;, position, Now);</em></font>
<em>17: </em>    accel_val.write(position);
<em>18: </em>  <font color="red"><strong>}</strong></font>
<em>19: </em><font color="red"><strong>}</strong></font>
<em>20: </em>
<em>21: </em><font color="#ffa600"><em>// ------------------ profile ----------------	</em></font>
<em>22: </em>void profile(int32 simtime,int32 &amp;position) 
<em>23: </em><font color="red"><strong>{</strong></font>
<em>24: </em>  <font color="#ffa600"><em>// change the accelerator setting over time</em></font>
<em>25: </em>  int32 slices, i;
<em>26: </em>  slices = 100;
<em>27: </em>  i = 0;
<em>28: </em>  <strong>while</strong> ((int)pTime() &lt; simtime) <font color="red"><strong>{</strong></font>
<em>29: </em>    pDelay(simtime/slices);
<em>30: </em>    int32 f = (i * 90)/slices;
<em>31: </em>    position = 10 + f;
<em>32: </em>    <font color="#ffa600"><em>//printf(&quot;\n***Accelerator moved to %ld at %ld&quot;, position, Now);</em></font>
<em>33: </em>    i = i + 1;
<em>34: </em>    gAccelerator = position;
<em>35: </em>  <font color="red"><strong>}</strong></font>
<em>36: </em>  printf(<font color="red">&quot;\n*** Accelerator profiling halting.&quot;</font>);
<em>37: </em><font color="red"><strong>}</strong></font>
<em>38: </em>
<em>39: </em><font color="#ffa600"><em>// ------------------------ accelerator -------------------</em></font>
<em>40: </em>void accelerator(int32 simtime, Chan &amp;acc_query, Chan &amp;acc_val)
<em>41: </em><font color="red"><strong>{</strong></font>
<em>42: </em>  <font color="#ffa600"><em>// moves accelerator in appropriate manner and tells anyone who asks where it is</em></font>
<em>43: </em>  int32 position;
<em>44: </em>        
<em>45: </em>  printf(<font color="red">&quot;\nAccelerator starting..&quot;</font>);
<em>46: </em>  position = 10;
<em>47: </em>  gAccelerator = position;
<em>48: </em>  par <font color="red"><strong>{</strong></font>
<em>49: </em>    respond(acc_query, acc_val, simtime, position);
<em>50: </em>    profile(simtime,position);
<em>51: </em>  <font color="red"><strong>}</strong></font>
<em>52: </em><font color="red"><strong>}</strong></font>
<em>53: </em>    
<em>54: </em><font color="#ffa600"><em>// ------------------------ starter ---------------------</em></font>
<em>55: </em>void starter(Chan &amp;to_starter, Chan &amp;started)
<em>56: </em><font color="red"><strong>{</strong></font>
<em>57: </em>  printf(<font color="red">&quot;\nStarter motor starting...&quot;</font>);
<em>58: </em>  to_starter.get();
<em>59: </em>  printf (<font color="red">&quot;\nSending starter-started message.&quot;</font>);
<em>60: </em>  started.write(true);
<em>61: </em>  printf (<font color="red">&quot;\nDone sending starter-started message.&quot;</font>);
<em>62: </em><font color="red"><strong>}</strong></font>
<em>63: </em>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
<!-- ecu/configuration.pa -->
<a name="ecu/configuration.pa"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">3.2.9 ecu/configuration.pa</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em> 1: </em><font color="#ffa600"><em>//</em></font>
<em> 2: </em><font color="#ffa600"><em>// configuration.pa</em></font>
<em> 3: </em><font color="#ffa600"><em>//</em></font>
<em> 4: </em>
<em> 5: </em><font color="#ffa600"><em>// configuration globals</em></font>
<em> 6: </em>
<em> 7: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;configuration.h&quot;</font>
<em> 8: </em>
<em> 9: </em>const char *version = <font color="red">&quot;v0.03, 6 February 2003&quot;</font>;
<em>10: </em>const char *copyright = <font color="red">&quot;copyright Freescale 2004-2005, all rights reserved.&quot;</font>;
<em>11: </em>
<em>12: </em><font color="#ffa600"><em>// platform.  the &quot;names&quot; are integers so that we can look up their</em></font>
<em>13: </em><font color="#ffa600"><em>// MIPS in the cpu_MIPS array.</em></font>
<em>14: </em>plasma::Processor zen((const char *)0);
<em>15: </em>plasma::Processor tpu((const char *)1);
<em>16: </em>plasma::Processor hardware((const char *)2);
<em>17: </em>
<em>18: </em><font color="#ffa600"><em>// performance</em></font>
<em>19: </em>int32 cpu_MIPS[3];      <font color="#ffa600"><em>// slot n holds mips for cpu n</em></font>
<em>20: </em>
<em>21: </em>const int32 zen_mips = 100;
<em>22: </em>const int32 tpu_mips = 37;
<em>23: </em>
<em>24: </em><font color="#ffa600"><em>// ticks per second</em></font>
<em>25: </em>const int32 ticks_per_second = 1000000;             <font color="#ffa600"><em>// a tick is a microsecond</em></font>
<em>26: </em>
<em>27: </em><font color="#ffa600"><em>// globals</em></font>
<em>28: </em>double fuelrate;                    <font color="#ffa600"><em>// units of fuel per second:    ml per sec</em></font>
<em>29: </em>double fuelpush;                    <font color="#ffa600"><em>// impulse per unit of fuel:    newton-seconds per ml</em></font>
<em>30: </em>double mass;                        <font color="#ffa600"><em>// 'weight' of car :            kg</em></font>
<em>31: </em>double speed;                   <font color="#ffa600"><em>// car speed:                   meters/sec</em></font>
<em>32: </em>
<em>33: </em>double speedratio;              <font color="#ffa600"><em>// 'rpm' per unit speed</em></font>
<em>34: </em>double friction;                <font color="#ffa600"><em>// coefficient of friction</em></font>
<em>35: </em>int32 num_teeth;                <font color="#ffa600"><em>// number of teeth on flywheel</em></font>
<em>36: </em>int32 num_cylinders;            <font color="#ffa600"><em>// number of cylinders.</em></font>
<em>37: </em>
<em>38: </em>int32 tooth_chunk;
<em>39: </em>                                 
<em>40: </em>const int32 circle = 1000000;   <font color="#ffa600"><em>// a complete circle has this number of units (a million)</em></font>
<em>41: </em>
<em>42: </em><font color="#ffa600"><em>// the shared accelerator variable</em></font>
<em>43: </em>int32 gAccelerator;
<em>44: </em>
<em>45: </em>FILE *logfile = 0;
<em>46: </em>    
<em>47: </em><font color="#ffa600"><em>// the shared variables for angle management</em></font>
<em>48: </em>int32 measured_angle, est_angle_rate, est_angle_accel;      <font color="#ffa600"><em>// parameters of angle movement</em></font>
<em>49: </em>int32 measured_t;                                   <font color="#ffa600"><em>// time at which params valid</em></font>
<em>50: </em>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
<!-- ecu/utilities.pa -->
<a name="ecu/utilities.pa"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">3.2.10 ecu/utilities.pa</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em> 1: </em><font color="#ffa600"><em>//</em></font>
<em> 2: </em><font color="#ffa600"><em>// utilities.sw</em></font>
<em> 3: </em><font color="#ffa600"><em>//</em></font>
<em> 4: </em>
<em> 5: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;configuration.h&quot;</font>
<em> 6: </em>
<em> 7: </em>using namespace std;
<em> 8: </em>using namespace plasma;
<em> 9: </em>
<em>10: </em><font color="#ffa600"><em>// --------------------- Compute ------------------------</em></font>
<em>11: </em>
<em>12: </em>void Compute(int32 work)
<em>13: </em><font color="red"><strong>{</strong></font>
<em>14: </em>  <font color="#ffa600"><em>// this scales the amount of computation to the speed of the host cpu</em></font>
<em>15: </em>  int32 cpu = (int)pCurProc().name();
<em>16: </em>  int32 mips = cpu_MIPS[cpu];
<em>17: </em>  int32 dt = work/mips;
<em>18: </em>  
<em>19: </em>  <font color="#ffa600"><em>//printf(&quot;\n\tCompute %ld on cpu %ld (%ld mips)  -&gt; %ld ticks\n&quot;, work, cpu, mips, dt);</em></font>
<em>20: </em>  pBusy(dt);
<em>21: </em><font color="red"><strong>}</strong></font>
<em>22: </em>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
<!-- ecu/engine.pa -->
<a name="ecu/engine.pa"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">3.2.11 ecu/engine.pa</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em>  1: </em><font color="#ffa600"><em>//</em></font>
<em>  2: </em><font color="#ffa600"><em>// engine.pa</em></font>
<em>  3: </em><font color="#ffa600"><em>//</em></font>
<em>  4: </em>
<em>  5: </em><font color="#1919af"><strong>#include</strong></font> &lt;cstdio&gt;
<em>  6: </em><font color="#1919af"><strong>#include</strong></font> &lt;cmath&gt;
<em>  7: </em>
<em>  8: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;configuration.h&quot;</font>
<em>  9: </em>
<em> 10: </em>using namespace std;
<em> 11: </em>using namespace plasma;
<em> 12: </em>
<em> 13: </em><font color="#ffa600"><em>// ----------------------- accelerate --------------------</em></font>
<em> 14: </em>
<em> 15: </em><strong>static</strong> double accelerate(double t, double fuel, double fuelpush, 
<em> 16: </em>                         double mass, double u) 
<em> 17: </em><font color="red"><strong>{</strong></font>
<em> 18: </em>  <font color="#ffa600"><em>// t is time interval                         : seconds</em></font>
<em> 19: </em>  <font color="#ffa600"><em>// fuel is amount of fuel burned in dt        : ml</em></font>
<em> 20: </em>  <font color="#ffa600"><em>// fuelpush is 'specific impulse' of fuel     : newton-seconds per ml</em></font>
<em> 21: </em>  <font color="#ffa600"><em>// mass is vehicle mass                       : kg</em></font>
<em> 22: </em>  <font color="#ffa600"><em>// u is initial speed                         : m/sec</em></font>
<em> 23: </em>  <font color="#ffa600"><em>// returns new speed                      : m/sec</em></font>
<em> 24: </em>    
<em> 25: </em>  <font color="#ffa600"><em>// Physics: Newtonian acceleration</em></font>
<em> 26: </em>  <font color="#ffa600"><em>// v**2 = u**2 + 2as</em></font>
<em> 27: </em>  <font color="#ffa600"><em>// s = ut + 0.5 * a * t**2</em></font>
<em> 28: </em>  <font color="#ffa600"><em>// p = ma;</em></font>
<em> 29: </em>  <font color="#ffa600"><em>// a = m/((fuel * fuelpush) - frictional_force)</em></font>
<em> 30: </em>  <font color="#ffa600"><em>// Friction: rises sharply with speed</em></font>
<em> 31: </em>  <font color="#ffa600"><em>// f = (friction * v) ** 2</em></font>
<em> 32: </em>    
<em> 33: </em>  double s, v, a, f;
<em> 34: </em>    
<em> 35: </em>  <font color="#ffa600"><em>//printf(&quot;\naccelerate: t = %f, fuel = %f, fuelpush = %f, mass = %fm u = %f&quot;,</em></font>
<em> 36: </em>  <font color="#ffa600"><em>//    t, fuel, fuelpush, mass, u);</em></font>
<em> 37: </em>        
<em> 38: </em>  <font color="#ffa600"><em>// compute effects of friction</em></font>
<em> 39: </em>  f = friction * u;                         <font color="#ffa600"><em>// assume speed constant enough over interval, and..</em></font>
<em> 40: </em>  f = f * f ;                               <font color="#ffa600"><em>// .. compute frictional force just for starting speed</em></font>
<em> 41: </em>  <font color="#ffa600"><em>//printf(&quot;\n\tfrictional force = %f&quot;, f);</em></font>
<em> 42: </em>        
<em> 43: </em>  f = (fuel * fuelpush) - f;                <font color="#ffa600"><em>// force = fuel's impulse - frictional force</em></font>
<em> 44: </em>    
<em> 45: </em>    
<em> 46: </em>  <font color="#ffa600"><em>//printf(&quot;effective force = %f&quot;, f);</em></font>
<em> 47: </em>  a = f / mass;                             <font color="#ffa600"><em>// p = ma, rearranged</em></font>
<em> 48: </em>    
<em> 49: </em>  <font color="#ffa600"><em>//printf(&quot;\n\ta = %f&quot;, a);</em></font>
<em> 50: </em>    
<em> 51: </em>  s = (u * t) + ((a * t * t)/2.0);      <font color="#ffa600"><em>// how far have we gone?</em></font>
<em> 52: </em>  <font color="#ffa600"><em>//printf(&quot;\n\ts = %f&quot;, s);</em></font>
<em> 53: </em>    
<em> 54: </em>  v = (u * u) + (2 * a * s);                <font color="#ffa600"><em>// compute new speed</em></font>
<em> 55: </em>  <font color="#ffa600"><em>//printf(&quot;\n\tvsqu = %f&quot;, v);</em></font>
<em> 56: </em>    
<em> 57: </em>  <font color="#ffa600"><em>// if v is negative, somehow friction is driving our car backwards, which is unlikely</em></font>
<em> 58: </em>  <font color="#ffa600"><em>// thus our dynamic simplifications must be at fault. just make car motionless</em></font>
<em> 59: </em>  int32 v_int = (int32)v;
<em> 60: </em>  <strong>if</strong> (v_int &lt; 0) <font color="red"><strong>{</strong></font>
<em> 61: </em>    <font color="#ffa600"><em>// ooo! strong friction done slowed us to a halt</em></font>
<em> 62: </em>    v = 0.0;
<em> 63: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em> 64: </em>    <font color="#ffa600"><em>// otherwise compute sqrt</em></font>
<em> 65: </em>    v = sqrt(v); 
<em> 66: </em>  <font color="red"><strong>}</strong></font>
<em> 67: </em>  
<em> 68: </em>  <font color="#ffa600"><em>//printf(&quot;\n\tv = %f&quot;, v);</em></font>
<em> 69: </em>    
<em> 70: </em>  <strong>return</strong> v;
<em> 71: </em><font color="red"><strong>}</strong></font>
<em> 72: </em>    
<em> 73: </em>
<em> 74: </em><font color="#ffa600"><em>// ---------------------- inject_fuel -----------------</em></font>
<em> 75: </em>
<em> 76: </em><strong>static</strong> void inject_fuel(int32 squirt, double fuel) 
<em> 77: </em><font color="red"><strong>{</strong></font>
<em> 78: </em>  <font color="#ffa600"><em>// dummy for the moment.</em></font>
<em> 79: </em>  <font color="#ffa600"><em>// squirt says how long to hold the injector open</em></font>
<em> 80: </em>  <font color="#ffa600"><em>// later, we'll compute how much fuel we'll get given fuel line pressure</em></font>
<em> 81: </em>  
<em> 82: </em><font color="red"><strong>}</strong></font>
<em> 83: </em>        
<em> 84: </em><font color="#ffa600"><em>// ---------------------- fire_spark -----------------</em></font>
<em> 85: </em>
<em> 86: </em><strong>static</strong> void fire_spark(int32 cylinder, int32 flash, double fuel) 
<em> 87: </em><font color="red"><strong>{</strong></font>
<em> 88: </em>  <font color="#ffa600"><em>// dummy for the moment</em></font>
<em> 89: </em>  <font color="#ffa600"><em>// eventually we'll create a signature for knock detect to look at</em></font>
<em> 90: </em>    
<em> 91: </em>  <font color="#ffa600"><em>// compute car dynamics, using accelerate()</em></font>
<em> 92: </em>  double new_speed, fuel_amnt;
<em> 93: </em>    
<em> 94: </em>  fuel_amnt = fuel;
<em> 95: </em>    
<em> 96: </em>  <font color="#ffa600"><em>// compute our new speed; assume the fuel is delivered in unit time</em></font>
<em> 97: </em>  new_speed = accelerate(1.0, fuel_amnt, fuelpush, mass, speed);
<em> 98: </em>    
<em> 99: </em>  printf(<font color="red">&quot;\n***FireSpark at %lld for cyl[%d]::&quot;</font>, pTime(), cylinder);
<em>100: </em>  printf(<font color="red">&quot;fuel=%2.2f, startspeed=%2.2f newspeed=%2.2f&quot;</font>, fuel_amnt, speed, new_speed);
<em>101: </em>    
<em>102: </em>    
<em>103: </em>  <font color="#ffa600"><em>// log the new speed and the fact we sparked</em></font>
<em>104: </em>  fprintf(logfile, <font color="red">&quot;\nFSF::%8lld::&quot;</font>, pTime());
<em>105: </em>  fprintf(logfile, <font color="red">&quot;spark %2.2f&quot;</font>, fuel);
<em>106: </em>  fprintf(logfile, <font color="red">&quot;\nFSS::%8lld::&quot;</font>, pTime());
<em>107: </em>  fprintf(logfile, <font color="red">&quot;speed %2.2f ++ %2.2f&quot;</font>, speed, new_speed);
<em>108: </em>    
<em>109: </em>  speed = new_speed;
<em>110: </em>    
<em>111: </em><font color="red"><strong>}</strong></font>
<em>112: </em>    
<em>113: </em><font color="#ffa600"><em>// ----------------------- cylinder --------------------</em></font>
<em>114: </em><strong>static</strong> void cylinder(int32 cyl, FuelChan &amp;do_inject, Chan &amp;do_spark) 
<em>115: </em><font color="red"><strong>{</strong></font>
<em>116: </em>  <font color="#ffa600"><em>// models one cylinder</em></font>
<em>117: </em>  <font color="#ffa600"><em>// channels do_inject, do_spark carry commands from the engine controller </em></font>
<em>118: </em>  <font color="#ffa600"><em>// to inject or spark immediately</em></font>
<em>119: </em>  <font color="#ffa600"><em>// it is assumed that the ecu knows what the angular status of each cylinder is</em></font>
<em>120: </em>    
<em>121: </em>  bool engine_running = true;
<em>122: </em>  double fuel = 0;
<em>123: </em>    
<em>124: </em>  printf(<font color="red">&quot;\nCylinder %d starting...&quot;</font>, cyl);
<em>125: </em>    
<em>126: </em>  <strong>while</strong> (engine_running) <font color="red"><strong>{</strong></font>
<em>127: </em>    alt <font color="red"><strong>{</strong></font>
<em>128: </em>      do_inject.port(fuel_request request) <font color="red"><strong>{</strong></font>
<em>129: </em>        int32 squirt = request.squirt_time;
<em>130: </em>        fuel = request.fuel_amount;
<em>131: </em>        inject_fuel(squirt, fuel);
<em>132: </em>        printf(<font color="red">&quot;\n%lld::#### Engine cylinder %d &quot;</font>, pTime(), cyl);
<em>133: </em>        printf(<font color="red">&quot;received request to inject %2.2f&quot;</font>, fuel);
<em>134: </em>        printf(<font color="red">&quot;for %d&quot;</font>, squirt);
<em>135: </em>        engine_running = (fuel &gt; 0);
<em>136: </em>      <font color="red"><strong>}</strong></font>
<em>137: </em>      do_spark.port(int flash) <font color="red"><strong>{</strong></font>
<em>138: </em>        printf(<font color="red">&quot;\n%lld::**** Engine cylinder %d received request to fire spark&quot;</font>, pTime(), cyl);
<em>139: </em>        fire_spark(cyl, flash, fuel);
<em>140: </em>        engine_running = flash;
<em>141: </em>      <font color="red"><strong>}</strong></font>
<em>142: </em>    <font color="red"><strong>}</strong></font>
<em>143: </em>  <font color="red"><strong>}</strong></font>
<em>144: </em>  printf(<font color="red">&quot;\n..cylinder %d closing down at %lld&quot;</font>, cyl, pTime());
<em>145: </em><font color="red"><strong>}</strong></font>
<em>146: </em>
<em>147: </em><font color="#ffa600"><em>// ------------- cylinders -------------</em></font>
<em>148: </em><strong>static</strong> void cylinders(int32 n, FuelChans &amp;inject, Chans &amp;spark) 
<em>149: </em><font color="red"><strong>{</strong></font>
<em>150: </em>  printf(<font color="red">&quot;\nStarting cylinders 0..%d&quot;</font>, n);
<em>151: </em>  pfor (int i = 0; i != n; ++i) <font color="red"><strong>{</strong></font>
<em>152: </em>    cylinder(i, inject[i], spark[i]);
<em>153: </em>  <font color="red"><strong>}</strong></font>
<em>154: </em><font color="red"><strong>}</strong></font>
<em>155: </em>
<em>156: </em><font color="#ffa600"><em>// ---------------------- engine --------------------</em></font>
<em>157: </em>void engine(FuelChans &amp;inject, Chans &amp;spark)
<em>158: </em><font color="red"><strong>{</strong></font>
<em>159: </em>  <font color="#ffa600"><em>// channel from ecu provides instructions to engine</em></font>
<em>160: </em>  printf(<font color="red">&quot;\nEngine starting...&quot;</font>);   
<em>161: </em>  cylinders(num_cylinders, inject, spark);
<em>162: </em><font color="red"><strong>}</strong></font>
<em>163: </em>    
<em>164: </em><font color="#ffa600"><em>// function to convert from speed to teeth-per-sec</em></font>
<em>165: </em><font color="#ffa600"><em>// ---------------- tps ------------------</em></font>
<em>166: </em><strong>static</strong> double tps(double speed) 
<em>167: </em><font color="red"><strong>{</strong></font>
<em>168: </em>  <font color="#ffa600"><em>// compute teeth per second from speed</em></font>
<em>169: </em>  <strong>return</strong> (speed * speedratio * num_teeth)/60.0;
<em>170: </em><font color="red"><strong>}</strong></font>
<em>171: </em>
<em>172: </em><font color="#ffa600"><em>// ----------------------- flywheel ----------------------</em></font>
<em>173: </em>void flywheel(Chan &amp;from_flywheel, Chan &amp;to_starter) 
<em>174: </em><font color="red"><strong>{</strong></font>
<em>175: </em>  <font color="#ffa600"><em>// models the flywheel's generation of flywheel ticks</em></font>
<em>176: </em>  <font color="#ffa600"><em>// we simply sample car speed at some fast enough rate</em></font>
<em>177: </em>  <font color="#ffa600"><em>// and compute when we'll see the next tick from a flywheel tooth</em></font>
<em>178: </em>  <font color="#ffa600"><em>// output a tick down the channel when it's time</em></font>
<em>179: </em>  <font color="#ffa600"><em>// we convert speed to degrees per second using speed ratio via rpm</em></font>
<em>180: </em>  <font color="#ffa600"><em>// we convert to teeth per second and look for the moments when elapsed</em></font>
<em>181: </em>  <font color="#ffa600"><em>// teeth equals next tooth </em></font>
<em>182: </em>    
<em>183: </em>  int32 engine_running = 1;
<em>184: </em>  double teeth = 0.0;                   <font color="#ffa600"><em>// floaty representation of where we are in the teeth</em></font>
<em>185: </em>  int32 next_tooth = 1;                 <font color="#ffa600"><em>// integer number of next tooth</em></font>
<em>186: </em>  bool started = false;
<em>187: </em>            
<em>188: </em>  printf(<font color="red">&quot;\nFlywheel starting...&quot;</font>);
<em>189: </em>    
<em>190: </em>  <strong>while</strong> (true) <font color="red"><strong>{</strong></font>
<em>191: </em>    <font color="#ffa600"><em>// sample car speed and compute when next tooth will hit</em></font>
<em>192: </em>    double fraction = 0.02;                     <font color="#ffa600"><em>// expect 50 samples per tooth interval</em></font>
<em>193: </em>    double dt;                              <font color="#ffa600"><em>// time interval</em></font>
<em>194: </em>    double new_speed;                       <font color="#ffa600"><em>// intermediate convenience value</em></font>
<em>195: </em>    int32 wait_time;
<em>196: </em>    int32 sampling;             
<em>197: </em>    double tooth_target;
<em>198: </em>    double old_speed;
<em>199: </em>
<em>200: </em>    sampling = true;
<em>201: </em>    <font color="#ffa600"><em>//printf(&quot;\n%ld::\tFlywheel&quot;, Now);</em></font>
<em>202: </em>    <font color="#ffa600"><em>//teethpersec = tps(speed);</em></font>
<em>203: </em>    <font color="#ffa600"><em>//printf(&quot;\nSpeed = %f; teethpersec = %f&quot;, speed, teethpersec);</em></font>
<em>204: </em>        
<em>205: </em>    dt = (next_tooth - teeth) / tps(speed);     <font color="#ffa600"><em>// 100% of time to next tooth at curr speed</em></font>
<em>206: </em>    dt = dt * fraction;                         <font color="#ffa600"><em>// fraction of expected time</em></font>
<em>207: </em>    wait_time = (int32) dt;
<em>208: </em>    <strong>if</strong> (wait_time == 0) <font color="red"><strong>{</strong></font>
<em>209: </em>      wait_time = 1;
<em>210: </em>    <font color="red"><strong>}</strong></font>
<em>211: </em>    tooth_target = next_tooth;
<em>212: </em>    old_speed = speed;
<em>213: </em>        
<em>214: </em>    <font color="#ffa600"><em>//printf(&quot;\n%ld::Flywheel-compute delay till tooth %ld waittime=%ld&quot;, </em></font>
<em>215: </em>    <font color="#ffa600"><em>//	Now, next_tooth, wait_time);</em></font>
<em>216: </em>    <font color="#ffa600"><em>//printf(&quot;speed=%2.2f teeth = %2.2f dt=%2.2f&quot;, speed, teeth, dt);</em></font>
<em>217: </em>    <strong>while</strong> (sampling) <font color="red"><strong>{</strong></font>
<em>218: </em>      double dtooth;
<em>219: </em>      double teethpersec;
<em>220: </em>            
<em>221: </em>      pDelay(wait_time);
<em>222: </em>            
<em>223: </em>      <font color="#ffa600"><em>// where have we got to with teeth?</em></font>
<em>224: </em>      teethpersec = tps(speed);             <font color="#ffa600"><em>// recompute because speed can change twixt teeth</em></font>
<em>225: </em>      teeth = teeth + (teethpersec * dt);
<em>226: </em>      dtooth = tooth_target - teeth;
<em>227: </em>      <strong>if</strong> (dtooth &lt;= 0.0) <font color="red"><strong>{</strong></font>
<em>228: </em>        <font color="#ffa600"><em>// got to tooth time</em></font>
<em>229: </em>        sampling = false;
<em>230: </em>      <font color="red"><strong>}</strong></font>
<em>231: </em>    <font color="red"><strong>}</strong></font>
<em>232: </em>    <font color="#ffa600"><em>//printf(&quot;\n\n ==== ToothTick! %f&quot;, teeth);</em></font>
<em>233: </em>        
<em>234: </em>    <font color="#ffa600"><em>// on every tooth, compute car speed anew</em></font>
<em>235: </em>    new_speed = accelerate(1.0, 0.0, 0.0, mass, speed);
<em>236: </em>    <font color="#ffa600"><em>//fprintf(logfile, &quot;\n\tfriction is slowing car: u=%2.2f v=%2.2f&quot;, speed, new_speed);</em></font>
<em>237: </em>        
<em>238: </em>    fprintf(logfile, <font color="red">&quot;\nTFS::%8lld::Tooth &quot;</font>, pTime(), next_tooth);
<em>239: </em>    fprintf(logfile, <font color="red">&quot;speed %2.2f -- %2.2f&quot;</font>, speed, new_speed);
<em>240: </em>    speed = new_speed;
<em>241: </em>        
<em>242: </em>    <font color="#ffa600"><em>// create tooth interrupt</em></font>
<em>243: </em>    from_flywheel.write(next_tooth);
<em>244: </em>        
<em>245: </em>    <font color="#ffa600"><em>// set up for next tooth</em></font>
<em>246: </em>    <font color="#ffa600"><em>//printf(&quot;\n%ld::Created tooth interrupt t[%ld]&quot;, Now, next_tooth);</em></font>
<em>247: </em>        
<em>248: </em>    teeth = next_tooth;
<em>249: </em>    next_tooth = next_tooth + 1;
<em>250: </em>    <font color="#ffa600"><em>//printf(&quot;\t==&gt;teeth = %2.2f&quot;, teeth);</em></font>
<em>251: </em>        
<em>252: </em>    <strong>if</strong> (next_tooth == num_teeth) <font color="red"><strong>{</strong></font>
<em>253: </em>      <font color="#ffa600"><em>// handle cyclic nature of tooth number</em></font>
<em>254: </em>      next_tooth = 0;   
<em>255: </em>      teeth = 0.0;
<em>256: </em>      engine_running = engine_running - 1;
<em>257: </em>      
<em>258: </em>      <font color="#ffa600"><em>// handle starter</em></font>
<em>259: </em>      <strong>if</strong> (!started) <font color="red"><strong>{</strong></font>
<em>260: </em>        started = true;                 <font color="#ffa600"><em>// yay! we're running!</em></font>
<em>261: </em>        to_starter.write(true);
<em>262: </em>      <font color="red"><strong>}</strong></font>
<em>263: </em>    <font color="red"><strong>}</strong></font>
<em>264: </em>  <font color="red"><strong>}</strong></font> 
<em>265: </em><font color="red"><strong>}</strong></font>
<em>266: </em>
<em>267: </em>    
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
<!-- ecu/ecu.pa -->
<a name="ecu/ecu.pa"></a>
<div class="skribesubsubsectiontitle"><h4><font color="#8381de">3.2.12 ecu/ecu.pa</font>
</h4></div><div class="subsubsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em>  1: </em><font color="#ffa600"><em>// ecu.pa</em></font>
<em>  2: </em><font color="#ffa600"><em>// a simplistic model of an automotive engine controller (and engine)</em></font>
<em>  3: </em><font color="#ffa600"><em>// pete october/november 2002</em></font>
<em>  4: </em>
<em>  5: </em><font color="#ffa600"><strong>/* ========================= history =======================</strong></font>
<em>  6: </em>
<em>  7: </em><font color="#ffa600"><strong>    july 3 2004:  conversion to plasma.</strong></font>
<em>  8: </em><font color="#ffa600"><strong>    november 14 2002: structural first approximation sans logging. pre-alpha quality at best</strong></font>
<em>  9: </em><font color="#ffa600"><strong>        to do:  fuel injection and firing should drive motor; it doesn't</strong></font>
<em> 10: </em><font color="#ffa600"><strong>                need some appropriate logging file format</strong></font>
<em> 11: </em><font color="#ffa600"><strong>   =========================================================</strong></font>
<em> 12: </em><font color="#ffa600"><strong>*/</strong></font>
<em> 13: </em>
<em> 14: </em><font color="#ffa600"><strong>/* ========================= description =======================</strong></font>
<em> 15: </em>
<em> 16: </em><font color="#ffa600"><strong>the goal here is to get the 'architecture' of an engine controller captured, so that</strong></font>
<em> 17: </em><font color="#ffa600"><strong>we can understand how the bits play together. when complete, this model will NOT contain (eg) 'real</strong></font>
<em> 18: </em><font color="#ffa600"><strong>strategy code', but will contain at least placeholders for real code which could be refined</strong></font>
<em> 19: </em><font color="#ffa600"><strong>in a later model</strong></font>
<em> 20: </em>
<em> 21: </em><font color="#ffa600"><strong>what it will do is to allow us to </strong></font>
<em> 22: </em><font color="#ffa600"><strong>    - look at context switch rates</strong></font>
<em> 23: </em><font color="#ffa600"><strong>    - look at partitioning the sw across more than one processor</strong></font>
<em> 24: </em><font color="#ffa600"><strong>    - look for APU opportunities</strong></font>
<em> 25: </em><font color="#ffa600"><strong>    - confirm the architecture</strong></font>
<em> 26: </em><font color="#ffa600"><strong>    - look at the gross effects of scheduling and multiple processors on event jitter</strong></font>
<em> 27: </em>
<em> 28: </em><font color="#ffa600"><strong>for a next step:</strong></font>
<em> 29: </em><font color="#ffa600"><strong>with 'real code' and a 'real OS' we can construct an exact analogue of this system at the </strong></font>
<em> 30: </em><font color="#ffa600"><strong>'algorithmic' level of deatil, in which plausible code is running in a simulated realtime </strong></font>
<em> 31: </em><font color="#ffa600"><strong>environment. then we can further</strong></font>
<em> 32: </em><font color="#ffa600"><strong>    - look at the effects of task switching on cache behaviour</strong></font>
<em> 33: </em><font color="#ffa600"><strong>    - look for mechanisms which speed actual code</strong></font>
<em> 34: </em><font color="#ffa600"><strong>    - look for mechanisms which shrink code footprint</strong></font>
<em> 35: </em><font color="#ffa600"><strong>    - confirm it's code that needs shrining, not data</strong></font>
<em> 36: </em><font color="#ffa600"><strong>    - compare 'locks' and 'messages' for footprint and efficiency</strong></font>
<em> 37: </em><font color="#ffa600"><strong>    - ...</strong></font>
<em> 38: </em><font color="#ffa600"><strong>    </strong></font>
<em> 39: </em>
<em> 40: </em><font color="#ffa600"><strong>what we model is a (very!) simplified engine and engine controller</strong></font>
<em> 41: </em><font color="#ffa600"><strong>    - the engine is an n-cyclinder engine</strong></font>
<em> 42: </em><font color="#ffa600"><strong>    - it has a flywheel with t teeth on it, sensed by a hall-effect sensor whose sensitivity</strong></font>
<em> 43: </em><font color="#ffa600"><strong>varies with speed (low at low speeds) and which needs thresholding for effective digitisation</strong></font>
<em> 44: </em><font color="#ffa600"><strong>    - there is an accelerator pedal</strong></font>
<em> 45: </em><font color="#ffa600"><strong>    - there is an external environment which imposes frictional and mass-based forces on the motor</strong></font>
<em> 46: </em><font color="#ffa600"><strong>so that there is a maximum speed it can attain with any particular rate of fuel feed and a </strong></font>
<em> 47: </em><font color="#ffa600"><strong>maximum acceleration at a given fuel feed rate</strong></font>
<em> 48: </em><font color="#ffa600"><strong>    - there is a fuel injector per cylinder, which squirts fuel in when the injector is open. the</strong></font>
<em> 49: </em><font color="#ffa600"><strong>amount of fuel injected is a function of fuel line pressure and open time</strong></font>
<em> 50: </em><font color="#ffa600"><strong>    - there is a spark plug per cylinder, which must be zapped to have the fuel-air mixture go bang. </strong></font>
<em> 51: </em><font color="#ffa600"><strong>however, if it's asked to go bang at the wrong time, it might knock - get pre-ignition - nasty</strong></font>
<em> 52: </em><font color="#ffa600"><strong>    - there is a fuel pressure detector</strong></font>
<em> 53: </em><font color="#ffa600"><strong>    - there is a microphone per cylinder to listen for knocking</strong></font>
<em> 54: </em><font color="#ffa600"><strong>    </strong></font>
<em> 55: </em><font color="#ffa600"><strong>we will eventually try partitioning this software across a different mix of cpus, including a</strong></font>
<em> 56: </em><font color="#ffa600"><strong>zen, an etpu and a cpm (or rather, logical equivalents thereof).</strong></font>
<em> 57: </em>
<em> 58: </em><font color="#ffa600"><strong>   =========================================================</strong></font>
<em> 59: </em><font color="#ffa600"><strong>*/</strong></font>
<em> 60: </em>
<em> 61: </em><font color="#1919af"><strong>#include</strong></font> &lt;cmath&gt;
<em> 62: </em><font color="#1919af"><strong>#include</strong></font> &lt;cstdio&gt;
<em> 63: </em>
<em> 64: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;constants.h&quot;</font>              <font color="#ffa600"><em>// useful units</em></font>
<em> 65: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;configuration.h&quot;</font>          <font color="#ffa600"><em>// globals specifying configuration (eg, num cyclinders)</em></font>
<em> 66: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;engine.h&quot;</font>                     <font color="#ffa600"><em>// the engine model</em></font>
<em> 67: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;car.h&quot;</font>                        <font color="#ffa600"><em>// accelerator etc</em></font>
<em> 68: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;utilities.h&quot;</font>              <font color="#ffa600"><em>// Compute()</em></font>
<em> 69: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;angle.h&quot;</font>                  <font color="#ffa600"><em>// angle manager</em></font>
<em> 70: </em>
<em> 71: </em>using namespace plasma;
<em> 72: </em>using namespace std;
<em> 73: </em>
<em> 74: </em><font color="#ffa600"><em>// statistics</em></font>
<em> 75: </em>
<em> 76: </em>int32 deadline_average[cylinder_max];
<em> 77: </em>double deadline_variance[cylinder_max];
<em> 78: </em>int32 num_samples;
<em> 79: </em>
<em> 80: </em><font color="#ffa600"><em>// --------------------- init_statistics ----------------</em></font>
<em> 81: </em>
<em> 82: </em>void init_statistics() 
<em> 83: </em><font color="red"><strong>{</strong></font>
<em> 84: </em>  num_samples = 0;
<em> 85: </em>  <strong>for</strong> (int i = 0; i != num_cylinders; ++i) <font color="red"><strong>{</strong></font>
<em> 86: </em>    deadline_average[i] = 0;
<em> 87: </em>    deadline_variance[i] = 0.0;
<em> 88: </em>  <font color="red"><strong>}</strong></font>
<em> 89: </em><font color="red"><strong>}</strong></font>
<em> 90: </em>    
<em> 91: </em><font color="#ffa600"><em>// --------------------- report_statisticts --------------</em></font>
<em> 92: </em>
<em> 93: </em>void report_statistics() 
<em> 94: </em><font color="red"><strong>{</strong></font>
<em> 95: </em>  num_samples = num_samples/(num_cylinders);
<em> 96: </em>  printf(<font color="red">&quot;\n\n\n============================================================\n&quot;</font>);
<em> 97: </em>  printf(<font color="red">&quot;\nDeadline statistics for injection and firing:\n&quot;</font>);
<em> 98: </em>  <strong>for</strong> (int i = 0; i != num_cylinders; ++i) <font color="red"><strong>{</strong></font>
<em> 99: </em>    double v = 0, deg;
<em>100: </em>    int32 av = 0;
<em>101: </em>    <strong>if</strong> (num_samples) <font color="red"><strong>{</strong></font>
<em>102: </em>      av = deadline_average[i]/num_samples;
<em>103: </em>      v = deadline_variance[i]/num_samples;
<em>104: </em>    <font color="red"><strong>}</strong></font>
<em>105: </em>        
<em>106: </em>    printf(<font color="red">&quot;\nCylinder[%d] varied by %d angle units&quot;</font>, i, av);
<em>107: </em>    deg = av * 360;
<em>108: </em>    deg = deg/circle;
<em>109: </em>    printf(<font color="red">&quot; [%2.2f deg]&quot;</font>, deg);
<em>110: </em>    deg = v * 360;
<em>111: </em>    deg = deg/circle;
<em>112: </em>    printf(<font color="red">&quot; var=%2.2f [%2.2f deg]&quot;</font>, v, deg);
<em>113: </em>    v = sqrt(v);
<em>114: </em>    deg = v * 360;
<em>115: </em>    deg = deg/circle;
<em>116: </em>    printf(<font color="red">&quot; std=%2.2f [%2.2f deg]&quot;</font>, v, deg);
<em>117: </em>  <font color="red"><strong>}</strong></font>
<em>118: </em>  printf(<font color="red">&quot;\n\n\n============================================================\n&quot;</font>);
<em>119: </em><font color="red"><strong>}</strong></font>
<em>120: </em>    
<em>121: </em><font color="#ffa600"><em>// ---------------------- init_vehicle ------------------</em></font>
<em>122: </em>void init_vehicle() 
<em>123: </em><font color="red"><strong>{</strong></font>
<em>124: </em>  fuelpush = 0.631;             <font color="#ffa600"><em>// newton-seconds per ml</em></font>
<em>125: </em>  mass = 2000.0;                <font color="#ffa600"><em>// car weighs about a ton</em></font>
<em>126: </em>  speed = 0.0;
<em>127: </em>  speedratio = 0.05;
<em>128: </em>  friction = 0.631;             <font color="#ffa600"><em>// squared multiplier term in speed-dependent comp of friction</em></font>
<em>129: </em>  num_cylinders = 8;
<em>130: </em>  num_teeth = 36;               <font color="#ffa600"><em>// one every 10 degrees; a couple o milliseconds between teesh at 8000rpm</em></font>
<em>131: </em>  tooth_chunk = circle/num_teeth; <font color="#ffa600"><em>// portion of a circle for a tooth</em></font>
<em>132: </em><font color="red"><strong>}</strong></font>
<em>133: </em>    
<em>134: </em><font color="#ffa600"><em>// ---------------------- cylinder_process ---------------</em></font>
<em>135: </em>void cylinder_process(int32 c, int32 n, FuelChan &amp;inject, Chan &amp;spark, Chan &amp;ask, Chan &amp;wakeup) 
<em>136: </em><font color="red"><strong>{</strong></font>
<em>137: </em>  <font color="#ffa600"><em>// this process controls a single cylinder c of n cylinders, choosing how much</em></font>
<em>138: </em>  <font color="#ffa600"><em>// fuel to squirt, when, and when to fire</em></font>
<em>139: </em>  <font color="#ffa600"><em>// the firing order is an (unrealistic) 0, 1, 2, 3....</em></font>
<em>140: </em>  <font color="#ffa600"><em>// inject is the channel we tell cylinder to inject fuel, value is amount</em></font>
<em>141: </em>  <font color="#ffa600"><em>// spark is channel we tell cylinder's sparkplug to fire</em></font>
<em>142: </em>  <font color="#ffa600"><em>// ask is the channel we ask to be woken up at the appropriate angle</em></font>
<em>143: </em>    
<em>144: </em>  <font color="#ffa600"><em>// first choose our (fixed) firing angle (get adaptive later)</em></font>
<em>145: </em>  <font color="#ffa600"><em>// cylinder 0 fires at nominal angle 0.1, cylinder 1 at 0.1 + (1/n) later </em></font>
<em>146: </em>  <font color="#ffa600"><em>//...angles measured as fractions of a circle</em></font>
<em>147: </em>  <font color="#ffa600"><em>// fuel needs to be squirted before ignition</em></font>
<em>148: </em>  <font color="#ffa600"><em>// since angular velocity of engine changes, we can't predict the time at</em></font>
<em>149: </em>  <font color="#ffa600"><em>// which the angle is reached massively in advance (although</em></font>
<em>150: </em>  <font color="#ffa600"><em>// we'll try by having a 2nd-order fit filter on angular velocity of flywheel</em></font>
<em>151: </em>    
<em>152: </em>  int32 fire_angle, inject_angle;
<em>153: </em>    
<em>154: </em>  printf(<font color="red">&quot;\n\tCylinderManager Process starting for cylinder[%d] on &quot;</font>, c);
<em>155: </em>    
<em>156: </em>  inject_angle = c * (circle/(n + 1));          <font color="#ffa600"><em>// compute default fire angle for cylinder c of n+1</em></font>
<em>157: </em>  inject_angle = inject_angle + (circle/100);
<em>158: </em>  fire_angle = inject_angle + (circle/200);
<em>159: </em>    
<em>160: </em>  printf(<font color="red">&quot;\n\t..injects at %d, fires at %d&quot;</font>, inject_angle, fire_angle);
<em>161: </em>    
<em>162: </em>  <font color="#ffa600"><em>// now, loop</em></font>
<em>163: </em>    
<em>164: </em>  <strong>while</strong> (true) <font color="red"><strong>{</strong></font>
<em>165: </em>    int32 accelerator, dt;
<em>166: </em>    int32 req_angle;
<em>167: </em>    fuel_request f_req;
<em>168: </em>    <font color="#ffa600"><em>// find out where the accelerator is</em></font>
<em>169: </em>        
<em>170: </em>    accelerator = gAccelerator;
<em>171: </em>    <font color="#ffa600"><em>//printf(&quot;\n\t***c[%ld] reads accelerator as %ld\n&quot;, c, accelerator);</em></font>
<em>172: </em>        
<em>173: </em>    <font color="#ffa600"><em>// placeholder for strategy code to compute where we need to be</em></font>
<em>174: </em>        
<em>175: </em>    Compute(3500);
<em>176: </em>        
<em>177: </em>    <font color="#ffa600"><em>//printf(&quot;\n\t***c[%ld] has completed strategy code&quot;, c);</em></font>
<em>178: </em>        
<em>179: </em>    <font color="#ffa600"><em>// set up for injection</em></font>
<em>180: </em>        
<em>181: </em>    <font color="#ffa600"><em>//printf(&quot;\n\t***c[%ld] wants to wake up for angle %ld&quot;, c, inject_angle);</em></font>
<em>182: </em>        
<em>183: </em>    ask.write(inject_angle);            <font color="#ffa600"><em>// ask to be told when we get to the tooth before this angle</em></font>
<em>184: </em>        
<em>185: </em>    dt = wakeup.get();              <font color="#ffa600"><em>// get given time we need to suspend for        </em></font>
<em>186: </em>    pDelay(dt);
<em>187: </em>        
<em>188: </em>    req_angle = curr_angle(pTime()) - inject_angle;
<em>189: </em>    num_samples = num_samples + 1;
<em>190: </em>    deadline_average[c] = deadline_average[c] + req_angle;
<em>191: </em>    deadline_variance[c] = deadline_variance[c] + (req_angle * req_angle);
<em>192: </em>    <font color="#ffa600"><em>// tell injector to inject</em></font>
<em>193: </em>    f_req.squirt_time = 1;
<em>194: </em>    f_req.fuel_amount = accelerator * 3;
<em>195: </em>        
<em>196: </em>    <font color="#ffa600"><em>//printf(&quot;\n\t***c[%ld] injecting at %ld; &quot;, c, Now);</em></font>
<em>197: </em>    <font color="#ffa600"><em>//printf(&quot;fuel_amount = %2.2f&quot;, f_req.fuel_amount);</em></font>
<em>198: </em>    inject.write(f_req);
<em>199: </em>
<em>200: </em>    <font color="#ffa600"><em>// set up for fire</em></font>
<em>201: </em>    printf(<font color="red">&quot;\n%lld::***c[%d] INJECTED (dtheta=%d)&quot;</font>, pTime(), c, req_angle);
<em>202: </em>        
<em>203: </em>    ask.write(fire_angle);
<em>204: </em>    dt = wakeup.get();
<em>205: </em>    <font color="#ffa600"><em>//printf(&quot;\n%ld::c[%ld] told to sleep for %ld ticks to reach fire angle&quot;, Now, c, dt);</em></font>
<em>206: </em>        
<em>207: </em>    <font color="#ffa600"><em>// sleep till we get here</em></font>
<em>208: </em>    pDelay(dt);
<em>209: </em>        
<em>210: </em>    <font color="#ffa600"><em>//printf(&quot;\n\t***c[%ld] firing at %ld&quot;, c, Now);</em></font>
<em>211: </em>    req_angle = curr_angle(pTime()) - fire_angle;
<em>212: </em>    num_samples = num_samples + 1;
<em>213: </em>    deadline_average[c] = deadline_average[c] + req_angle;
<em>214: </em>    deadline_variance[c] = deadline_variance[c] + (req_angle * req_angle);
<em>215: </em>
<em>216: </em>    spark.write(25);
<em>217: </em>        
<em>218: </em>    printf(<font color="red">&quot;\n%lld::***c[%d] FIRED (dtheta=%d)&quot;</font>, pTime(), c, req_angle);
<em>219: </em>  <font color="red"><strong>}</strong></font>
<em>220: </em><font color="red"><strong>}</strong></font>
<em>221: </em>    
<em>222: </em><font color="#ffa600"><em>// ---------------------- baseload --------------------</em></font>
<em>223: </em>void baseload(const char *name, int32 quantum) 
<em>224: </em><font color="red"><strong>{</strong></font>
<em>225: </em>  <font color="#ffa600"><em>// we set ourselves a very low priority and use up spare processor compute cycles</em></font>
<em>226: </em>  <font color="#ffa600"><em>// run on all 'computers' (but not the hardware)</em></font>
<em>227: </em>    
<em>228: </em>  pSetPriority(6);
<em>229: </em>  printf(<font color="red">&quot;\nBaseload starting on %s at %lld with priority %d&quot;</font>, name, pTime(), pGetPriority());
<em>230: </em>    
<em>231: </em>  <strong>while</strong> (true) <font color="red"><strong>{</strong></font>        
<em>232: </em>    <font color="#ffa600"><em>// compute load by seeing how long we take to do a quantum of computer</em></font>
<em>233: </em>    int32 t = pTime();
<em>234: </em>    pBusy(quantum);                     <font color="#ffa600"><em>// use 'nude' compute...</em></font>
<em>235: </em>    t = pTime() - t;
<em>236: </em>    double capacity = quantum;
<em>237: </em>    capacity = quantum/t;
<em>238: </em>    capacity = 100.0 - (capacity * 100.0);
<em>239: </em>    printf(<font color="red">&quot;\nBaseload at %lld::running at &quot;</font>, pTime());
<em>240: </em>    printf(<font color="red">&quot;%2.1f%% &quot;</font>, capacity); 
<em>241: </em>    printf(<font color="red">&quot;of %s capacity [took %d ticks for %d compute quanta]&quot;</font>, name, t, quantum); 
<em>242: </em>  <font color="red"><strong>}</strong></font>
<em>243: </em><font color="red"><strong>}</strong></font>
<em>244: </em>
<em>245: </em><font color="#ffa600"><em>// -------------------- cylinders -------------------</em></font>
<em>246: </em><strong>static</strong> void cylinders(int32 n, Chan &amp;started, FuelChans &amp;inject, Chans &amp;spark, Chans &amp;ask, Chans &amp;wakeups) 
<em>247: </em><font color="red"><strong>{</strong></font>
<em>248: </em>  printf(<font color="red">&quot;\nCreate cylinder manager 0..%d&quot;</font>, n-1);
<em>249: </em>  <font color="#ffa600"><em>// now we have to wait one revolution for the engine to start</em></font>
<em>250: </em>  pSetPriority(1);
<em>251: </em>  started.get();
<em>252: </em>  printf(<font color="red">&quot;\nGot starter message.&quot;</font>);
<em>253: </em>                
<em>254: </em>  printf(<font color="red">&quot;\nECU: starter motor has got engine moving; start cylinder management&quot;</font>);
<em>255: </em>  pfor (int i = 0; i != n; ++i) <font color="red"><strong>{</strong></font>
<em>256: </em>    cylinder_process(i, n, inject[i], spark[i], ask[i], wakeups[i]);
<em>257: </em>  <font color="red"><strong>}</strong></font>
<em>258: </em><font color="red"><strong>}</strong></font>
<em>259: </em>    
<em>260: </em><font color="#ffa600"><em>// ----------------------- ecu ------------------------</em></font>
<em>261: </em>void ecu(Chan &amp;started, Chan &amp;tick, Chan &amp;acc_query, Chan &amp;acc_val,
<em>262: </em>         int32 num_cylinders, FuelChans &amp;inject, Chans &amp;spark, Chans &amp;wakeups) 
<em>263: </em><font color="red"><strong>{</strong></font>
<em>264: </em>  <font color="#ffa600"><em>//array chan wakeups[cylinder_max];</em></font>
<em>265: </em>  Chans ask(cylinder_max);
<em>266: </em>            
<em>267: </em>  <font color="#ffa600"><em>// now we can start the ecu</em></font>
<em>268: </em>  printf(<font color="red">&quot;\nECU starting with a %d-cylinder engine to control...&quot;</font>, num_cylinders);
<em>269: </em>
<em>270: </em><a name="270" class="mark"></a>  <font color="#ffa600"><em></em></font>
<em>271: </em>  par <font color="red"><strong>{</strong></font>
<em>272: </em>    on (tpu) <font color="red"><strong>{</strong></font> angle_manager(num_cylinders, tick, ask, wakeups); <font color="red"><strong>}</strong></font>
<em>273: </em>    on (zen) <font color="red"><strong>{</strong></font> cylinders(num_cylinders, started, inject, spark, ask, wakeups); <font color="red"><strong>}</strong></font>
<em>274: </em>    on (zen) <font color="red"><strong>{</strong></font> baseload(<font color="red">&quot;zen&quot;</font>, 2500); <font color="red"><strong>}</strong></font>
<em>275: </em>    on (tpu) <font color="red"><strong>{</strong></font> baseload(<font color="red">&quot;tpu&quot;</font>, 2500); <font color="red"><strong>}</strong></font>
<em>276: </em>  <font color="red"><strong>}</strong></font>
<em>277: </em><font color="red"><strong>}</strong></font>
<em>278: </em>
<em>279: </em><font color="#ffa600"><em>// ----------------------- vehicle_status ---------------</em></font>
<em>280: </em>void vehicle_status() 
<em>281: </em><font color="red"><strong>{</strong></font>
<em>282: </em>  double rpm = speed/speedratio;
<em>283: </em>  printf(<font color="red">&quot;\nT=%lld::\t&quot;</font>, pTime());
<em>284: </em>  printf(<font color="red">&quot;V=%2.3f, RPM=%3.1f&quot;</font>, speed, rpm);
<em>285: </em><font color="red"><strong>}</strong></font>
<em>286: </em>    
<em>287: </em><font color="#ffa600"><em>// ---------------------- report ------------------------</em></font>
<em>288: </em>void report(int32 dt, int32 stop_time) 
<em>289: </em><font color="red"><strong>{</strong></font>
<em>290: </em>  <font color="#ffa600"><em>// gives status every dt until stop_time, when it kills the sim</em></font>
<em>291: </em>  printf(<font color="red">&quot;\nReports starting; report every %d until %d&quot;</font>, dt, stop_time);
<em>292: </em>  <strong>while</strong> ((int)pTime() &lt; stop_time) <font color="red"><strong>{</strong></font>
<em>293: </em>    vehicle_status();
<em>294: </em>    pDelay(dt * 4);
<em>295: </em>  <font color="red"><strong>}</strong></font>
<em>296: </em>  printf(<font color="red">&quot;\n\n====== ECU/Engine simulation closing down ==========\n\n&quot;</font>);
<em>297: </em>  report_statistics();
<em>298: </em>  pExit(0);
<em>299: </em><font color="red"><strong>}</strong></font>
<em>300: </em>
<em>301: </em>void pSetup(ConfigParms &amp;cp)
<em>302: </em><font color="red"><strong>{</strong></font>
<em>303: </em>  cp._busyokay = true;
<em>304: </em><font color="red"><strong>}</strong></font>
<em>305: </em>    
<em>306: </em><font color="#ffa600"><em>//------------------------- main -------------------------</em></font>
<em>307: </em>int pMain(int argc,const char *argv[]) 
<em>308: </em><font color="red"><strong>{</strong></font>
<em>309: </em>  double t, dt, dv;
<em>310: </em>  Chan tick, acc_query, acc_val, started, to_starter;
<em>311: </em>  Chans spark(cylinder_max), wakeups(cylinder_max);
<em>312: </em>  
<em>313: </em>  FuelChans inject(cylinder_max);
<em>314: </em>
<em>315: </em>  int32 simtime;
<em>316: </em>        
<em>317: </em>  printf(<font color="red">&quot;\n\n\nSimple Generic Engine &amp; ECU\n\t%s\n\t%s&quot;</font>, version, copyright);
<em>318: </em>    
<em>319: </em>  t = 0.0;
<em>320: </em>  dt = 0.1;
<em>321: </em>  dv = 0.0;
<em>322: </em>  init_vehicle();
<em>323: </em>  init_statistics();
<em>324: </em>    
<em>325: </em>  <font color="#ffa600"><em>// configuration</em></font>
<em>326: </em>  cpu_MIPS[(int)zen.name()] = zen_mips;
<em>327: </em>  cpu_MIPS[(int)tpu.name()] = tpu_mips;
<em>328: </em>  cpu_MIPS[(int)hardware.name()] = 0;
<em>329: </em>    
<em>330: </em>  <font color="#ffa600"><em>// run the engine</em></font>
<em>331: </em>    
<em>332: </em>  speed = 0.15;
<em>333: </em>  simtime = 500000;
<em>334: </em>  const char *logname = <font color="red">&quot;LogFile&quot;</font>;
<em>335: </em>  <strong>if</strong> (!(logfile = fopen(logname, <font color="red">&quot;w&quot;</font>))) <font color="red"><strong>{</strong></font>
<em>336: </em>    pAbort(<font color="red">&quot;Unable to open logfile.&quot;</font>);
<em>337: </em>  <font color="red"><strong>}</strong></font>
<em>338: </em>
<em>339: </em><a name="339" class="mark"></a>  <font color="#ffa600"><em></em></font>
<em>340: </em>  par <font color="red"><strong>{</strong></font>
<em>341: </em>    
<em>342: </em>    <font color="#ffa600"><em>// the simulated machinery</em></font>
<em>343: </em>    on (hardware) <font color="red"><strong>{</strong></font> report(1000, simtime);  <font color="red"><strong>}</strong></font>               <font color="#ffa600"><em>// cyclic status reports and sim time-out</em></font>
<em>344: </em>        
<em>345: </em>    on (hardware) <font color="red"><strong>{</strong></font> flywheel(tick, to_starter);     <font color="red"><strong>}</strong></font>           <font color="#ffa600"><em>// interrupt per tooth</em></font>
<em>346: </em>    on (hardware) <font color="red"><strong>{</strong></font> starter(to_starter, started); <font color="red"><strong>}</strong></font>             <font color="#ffa600"><em>// gets engine turning</em></font>
<em>347: </em>    on (hardware) <font color="red"><strong>{</strong></font> engine(inject, spark); <font color="red"><strong>}</strong></font>    <font color="#ffa600"><em>// the engine itself</em></font>
<em>348: </em>    on (hardware) <font color="red"><strong>{</strong></font> accelerator(simtime, acc_query, acc_val); <font color="red"><strong>}</strong></font>     <font color="#ffa600"><em>// the stimulus</em></font>
<em>349: </em>        
<em>350: </em>    <font color="#ffa600"><em>// the simulated software and processors</em></font>
<em>351: </em>    on (zen) <font color="red"><strong>{</strong></font> ecu(started, tick, acc_query, acc_val, num_cylinders, inject, spark, wakeups); <font color="red"><strong>}</strong></font>
<em>352: </em>  <font color="red"><strong>}</strong></font>
<em>353: </em>    
<em>354: </em>  printf(<font color="red">&quot;\n==== Closing Down =====\n&quot;</font>);
<em>355: </em>  fclose(logfile);
<em>356: </em>  <strong>return</strong> 0;
<em>357: </em><font color="red"><strong>}</strong></font>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
</div>
</div></td>
</tr></table><div class="skribe-ending">
<hr> 
<p class="ending"><font size="-1">
This <span class="sc">Html</span> page has been produced by 
<a href="http://www.inria.fr/mimosa/fp/Skribe" class="http">Skribe</a>.
<br/>
Last update <em>Mon Sep 20 15:21:21 2004</em>.</font></p></div>
</body>
</html>