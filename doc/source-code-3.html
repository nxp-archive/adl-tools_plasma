<!-- 95% W3C COMPLIANT, 95% CSS FREE, RAW HTML -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=ISO-8859-1">
<title>Example Source Code</title>
 <style type="text/css">
  <!--
  pre { font-family: monospace }
  tt { font-family: monospace }
  code { font-family: monospace }
  p.flushright { text-align: right }
  p.flushleft { text-align: left }
  span.sc { font-variant: small-caps }
  span.sf { font-family: sans-serif }
  span.skribetitle { font-family: sans-serif; font-weight: bolder; font-size: x-large; }
  -->
 </style>
</head>

<body class="section" bgcolor="#ffffff">
<table width="100%" class="skribetitle" cellspacing="0" cellpadding="0"><tbody>
<tr><td align="center" bgcolor="#8381de"><div class="skribetitle"><strong><big><big><big>3 Example Source Code -- Network System Example</big></big></big></strong></div><center>
</center>
</td></tr></tbody></table>
<table cellpadding="3" cellspacing="0" width="100%" class="skribe-margins"><tr>
<td align="left" valign="top" class="skribe-left-margin" width="20%" bgcolor="#dedeff"><div class="skribe-left-margin">
<br/><center><table width="97%" border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse;" frame="box" rules="none"><tbody>
<tr bgcolor="#8381de"><th align="center" colspan="1"><font color="#ffffff"><strong>main page</strong></font></th></tr>
<tr bgcolor="#ffffff"><td align="center" colspan="1"><table width="100%" border="0" style="border-collapse: collapse;" frame="void" rules="none"><tbody>
<tr><td align="left" valign="top" colspan="1"><strong>top:</strong></td><td align="right" valign="top" colspan="1"><a href="../../plasma/doc/source-code.html#Example-Source-Code" class="inbound">Example Source Code</a></td></tr>
</tbody></table>
</td></tr>
</tbody></table>
</center>
<br/><br/><center><table width="97%" border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse;" frame="box" rules="none"><tbody>
<tr bgcolor="#8381de"><th align="center" colspan="1"><font color="#ffffff"><strong>Sections</strong></font></th></tr>
<tr bgcolor="#ffffff"><td align="center" colspan="1"><table cellspacing="1" cellpadding="1" width="100%" class="toc">
<tbody>
 <tr><td valign="top" align="left">1</td><td colspan="4" width="100%"><a href="../../plasma/doc/source-code-1.html#RISC-Pipeline-Example">RISC Pipeline Example</a></td></tr>
 <tr><td></td><td valign="top" align="left">1.1</td><td colspan="3" width="100%"><a href="../../plasma/doc/source-code-1.html#sw/pipe.pa">sw/pipe.pa</a></td></tr>
 <tr><td valign="top" align="left">2</td><td colspan="4" width="100%"><a href="../../plasma/doc/source-code-2.html#RISC-Pipeline-Example-2">RISC Pipeline Example 2</a></td></tr>
 <tr><td></td><td valign="top" align="left">2.1</td><td colspan="3" width="100%"><a href="../../plasma/doc/source-code-2.html#../doc/pipe2.pa">../doc/pipe2.pa</a></td></tr>
 <tr><td valign="top" align="left">3</td><td colspan="4" width="100%"><a href="../../plasma/doc/source-code-3.html#Network-System-Example">Network System Example</a></td></tr>
 <tr><td></td><td valign="top" align="left">3.1</td><td colspan="3" width="100%"><a href="../../plasma/doc/source-code-3.html#eav/eav.pa">eav/eav.pa</a></td></tr>
 <tr><td valign="top" align="left">4</td><td colspan="4" width="100%"><a href="../../plasma/doc/source-code-4.html#Embedded-Application-Example">Embedded Application Example</a></td></tr>
 <tr><td></td><td valign="top" align="left">4.1</td><td colspan="3" width="100%"><a href="../../plasma/doc/source-code-4.html#Header-Files">Header Files</a></td></tr>
 <tr><td></td><td valign="top" align="left">4.2</td><td colspan="3" width="100%"><a href="../../plasma/doc/source-code-4.html#Implementation-Files">Implementation Files</a></td></tr>
 <tr><td valign="top" align="left">5</td><td colspan="4" width="100%"><a href="../../plasma/doc/source-code-5.html#Desktop-Application-Example">Desktop Application Example</a></td></tr>
 <tr><td></td><td valign="top" align="left">5.1</td><td colspan="3" width="100%"><a href="../../plasma/doc/source-code-5.html#Main-Program">Main Program</a></td></tr>
 <tr><td></td><td valign="top" align="left">5.2</td><td colspan="3" width="100%"><a href="../../plasma/doc/source-code-5.html#Compiler-Driver">Compiler Driver</a></td></tr>
 <tr><td></td><td valign="top" align="left">5.3</td><td colspan="3" width="100%"><a href="../../plasma/doc/source-code-5.html#Lexer">Lexer</a></td></tr>
 <tr><td></td><td valign="top" align="left">5.4</td><td colspan="3" width="100%"><a href="../../plasma/doc/source-code-5.html#Parser">Parser</a></td></tr>
 <tr><td></td><td valign="top" align="left">5.5</td><td colspan="3" width="100%"><a href="../../plasma/doc/source-code-5.html#"></a></td></tr>
 <tr><td></td><td valign="top" align="left">5.6</td><td colspan="3" width="100%"><a href="../../plasma/doc/source-code-5.html#Symbol-Table">Symbol Table</a></td></tr>
 <tr><td></td><td valign="top" align="left">5.7</td><td colspan="3" width="100%"><a href="../../plasma/doc/source-code-5.html#Code-Generation">Code Generation</a></td></tr>
 <tr><td></td><td valign="top" align="left">5.8</td><td colspan="3" width="100%"><a href="../../plasma/doc/source-code-5.html#Register-Allocation">Register Allocation</a></td></tr>
 <tr><td></td><td valign="top" align="left">5.9</td><td colspan="3" width="100%"><a href="../../plasma/doc/source-code-5.html#Assembly-Code-Writer">Assembly Code Writer</a></td></tr>
 <tr><td></td><td valign="top" align="left">5.10</td><td colspan="3" width="100%"><a href="../../plasma/doc/source-code-5.html#String-Class">String Class</a></td></tr>
 <tr><td></td><td valign="top" align="left">5.11</td><td colspan="3" width="100%"><a href="../../plasma/doc/source-code-5.html#Miscellaneous-Headers">Miscellaneous Headers</a></td></tr>
</tbody>
</table>
</td></tr>
</tbody></table>
</center>
</div></td>
<td align="left" valign="top" class="skribe-body"><div class="skribe-body">
<!-- eav/eav.pa -->
<a name="eav/eav.pa"></a>
<div class="skribesubsectiontitle"><table width="100%"><tr><td bgcolor="#ffffff"><h3><font color="#8381de">3.1 eav/eav.pa</font>
</h3></td></tr></table>
</div><div class="subsection">
<table cellspacing="0" class="color" cellpadding="0"><tbody>
<tr><td bgcolor="#ffffcc"><table cellspacing="0" class="frame" cellpadding="2" border="1" width="100%"><tbody>
<tr><td><pre class="prog"><em>  1: </em><font color="#ffa600"><em>//</em></font>
<em>  2: </em><font color="#ffa600"><em>// Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.</em></font>
<em>  3: </em><font color="#ffa600"><em>//</em></font>
<em>  4: </em><font color="#ffa600"><em>// You may distribute under the terms of the Artistic License, as specified in</em></font>
<em>  5: </em><font color="#ffa600"><em>// the COPYING file.</em></font>
<em>  6: </em><font color="#ffa600"><em>//</em></font>
<em>  7: </em><font color="#ffa600"><em>//</em></font>
<em>  8: </em><font color="#ffa600"><em>// eav.sw: a simplistic model of the eav</em></font>
<em>  9: </em><font color="#ffa600"><em>//</em></font>
<em> 10: </em>
<em> 11: </em><font color="#1919af"><strong>#include</strong></font> &lt;vector&gt;
<em> 12: </em>
<em> 13: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;plasma.h&quot;</font>
<em> 14: </em>
<em> 15: </em><font color="#1919af"><strong>#include</strong></font> <font color="red">&quot;Random.h&quot;</font>
<em> 16: </em>
<em> 17: </em>using namespace std;
<em> 18: </em>using namespace plasma;
<em> 19: </em>
<em> 20: </em><font color="#ffa600"><em>//	this model says the eav is </em></font>
<em> 21: </em><font color="#ffa600"><em>//	a set of user processes who squirt messages every now and then</em></font>
<em> 22: </em><font color="#ffa600"><em>//      to a comms multiplexer</em></font>
<em> 23: </em><font color="#ffa600"><em>//	a comms multiplexer who passes the messages on to a free transaction</em></font>
<em> 24: </em><font color="#ffa600"><em>//      agent (there are fewer agents than terminals) </em></font>
<em> 25: </em><font color="#ffa600"><em>//	tp agents who call upon database routines to effect transactions and</em></font>
<em> 26: </em><font color="#ffa600"><em>//      who pass messages on to a memory manager </em></font>
<em> 27: </em><font color="#ffa600"><em>//	the memory manager plays with journals and records and so forth, waiting</em></font>
<em> 28: </em><font color="#ffa600"><em>//      for access to complete when needed.</em></font>
<em> 29: </em><font color="#ffa600"><em>//	the system behavior is explored by having the memory manager sometimes use</em></font>
<em> 30: </em><font color="#ffa600"><em>//      fast memory for storage and sometimes use a disk manager; the ratio </em></font>
<em> 31: </em><font color="#ffa600"><em>//      between the two is a cache hit rate (ignoring writethru) and on an</em></font>
<em> 32: </em><font color="#ffa600"><em>//      enterprise attack vehicle the hit rate is assumed to be 100%</em></font>
<em> 33: </em><font color="#ffa600"><em>//	this version doesn't worry about contention for record locks between</em></font>
<em> 34: </em><font color="#ffa600"><em>//      transactions</em></font>
<em> 35: </em><font color="#ffa600"><em>//	this version uses a TP-1 like transaction - two reads and a write</em></font>
<em> 36: </em>
<em> 37: </em><font color="#ffa600"><em>// bkahne 21 june 2004</em></font>
<em> 38: </em><font color="#ffa600"><em>//      conversion to plasma</em></font>
<em> 39: </em><font color="#ffa600"><em>//</em></font>
<em> 40: </em><font color="#ffa600"><em>// pete 26 july 1990</em></font>
<em> 41: </em><font color="#ffa600"><em>//      modified june 3 1994: change to order of summary tps computation</em></font>
<em> 42: </em>
<em> 43: </em>
<em> 44: </em><font color="#ffa600"><em>// timeunits.sw</em></font>
<em> 45: </em><font color="#ffa600"><em>// names for the base values of time</em></font>
<em> 46: </em>
<em> 47: </em><strong>typedef</strong> int int32;
<em> 48: </em>
<em> 49: </em>const int32 musec = 1;
<em> 50: </em>const int32 msec  = musec * 1000;
<em> 51: </em>const int32 sec       = msec * 1000;
<em> 52: </em>const int32 minute= sec * 60;
<em> 53: </em>const int32 hour  = minute * 60;
<em> 54: </em>const int32 day       = hour * 24;
<em> 55: </em>
<em> 56: </em><font color="#ffa600"><em>// configuration</em></font>
<em> 57: </em>
<em> 58: </em>const int32 ThinkTime = 1000;       <font color="#ffa600"><em>// average think time for user(msec)</em></font>
<em> 59: </em>const int32 ThinkVar  = 250;        <font color="#ffa600"><em>// half the think range(msec)</em></font>
<em> 60: </em>
<em> 61: </em><font color="#ffa600"><em>// Instruction Path Lengths for Various Things</em></font>
<em> 62: </em><font color="#ffa600"><em>// these numbers are from Tony Pizzarello's figures</em></font>
<em> 63: </em>
<em> 64: </em>const int32 ReadPath        = 25000;    <font color="#ffa600"><em>// transaction path length (read)</em></font>
<em> 65: </em>const int32 WritePath       = 25000;    <font color="#ffa600"><em>// .. after a write to db</em></font>
<em> 66: </em>const int32 TermInPath          = 1500;     <font color="#ffa600"><em>// read message from terminal</em></font>
<em> 67: </em>const int32 TermOutPath     = 1500;     <font color="#ffa600"><em>// send message to terminal</em></font>
<em> 68: </em>const int32 DiskCmndPath    = 900;      <font color="#ffa600"><em>// instrucs to launch disk access</em></font>
<em> 69: </em>const int32 DiskResponsePath    = 1200;             <font color="#ffa600"><em>// to read stuff back</em></font>
<em> 70: </em>const int32 LockPath        = 7500;     <font color="#ffa600"><em>// to set a lock</em></font>
<em> 71: </em>const int32 UnlockPath      = 500;      <font color="#ffa600"><em>// to unset a lock</em></font>
<em> 72: </em>
<em> 73: </em>const int32 VT100 = 0;
<em> 74: </em>const int32 SuperMIPS = 1;
<em> 75: </em>const int32 Interphase = 2;
<em> 76: </em>const int32 num_terminals = 1000;       <font color="#ffa600"><em>// max number of terminals</em></font>
<em> 77: </em>const int32 num_drives  = 100;          <font color="#ffa600"><em>// max number of drives</em></font>
<em> 78: </em>
<em> 79: </em><strong>typedef</strong> vector&lt;int&gt; IntVect;
<em> 80: </em><strong>typedef</strong> Channel&lt;int32&gt; Chan;
<em> 81: </em><strong>typedef</strong> vector&lt;Chan&gt; Chans;
<em> 82: </em>
<em> 83: </em>Processors terminals(num_terminals);
<em> 84: </em>Processor mainframe;
<em> 85: </em>Processors diskdrives(num_drives);
<em> 86: </em>
<em> 87: </em><font color="#ffa600"><em>// Random number generation.</em></font>
<em> 88: </em>Random&lt;&gt; Rand(1);
<em> 89: </em>
<em> 90: </em><font color="#ffa600"><em>//</em></font>
<em> 91: </em><font color="#ffa600"><em>// Miscellaneous output routines to mirror those of sw.</em></font>
<em> 92: </em><font color="#ffa600"><em>//</em></font>
<em> 93: </em>
<em> 94: </em>void say(const char *s)
<em> 95: </em><font color="red"><strong>{</strong></font>
<em> 96: </em>  mprintf (<font color="red">&quot;%s&quot;</font>,s);
<em> 97: </em><font color="red"><strong>}</strong></font>
<em> 98: </em>
<em> 99: </em>void saynum(int32 d)
<em>100: </em><font color="red"><strong>{</strong></font>
<em>101: </em>  mprintf (<font color="red">&quot;%d&quot;</font>,d);
<em>102: </em><font color="red"><strong>}</strong></font>
<em>103: </em>
<em>104: </em>void sayflush()
<em>105: </em><font color="red"><strong>{</strong></font>
<em>106: </em>  fflush(stdout);
<em>107: </em><font color="red"><strong>}</strong></font>
<em>108: </em>
<em>109: </em><font color="#ffa600"><em>// Prints out x/y to 2 decimal places when x&gt;=0 and y&gt;=0</em></font>
<em>110: </em>void printfixed(uint64 x, uint64 y) 
<em>111: </em><font color="red"><strong>{</strong></font>
<em>112: </em>  <strong>if</strong> (x == 0) <font color="red"><strong>{</strong></font>
<em>113: </em>    mprintf(<font color="red">&quot;0.00&quot;</font>);
<em>114: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <strong>if</strong> (y == 0) <font color="red"><strong>{</strong></font>
<em>115: </em>    mprintf(<font color="red">&quot;Infinity&quot;</font>);
<em>116: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em>117: </em>    uint64 vi = x/y;
<em>118: </em>    uint64 vf = vi * y;
<em>119: </em>    vf = x - vf;
<em>120: </em>    <strong>if</strong> (vf &gt; 20000000) <font color="red"><strong>{</strong></font>
<em>121: </em>      y = y/100;
<em>122: </em>    <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em>123: </em>      vf = vf * 100;
<em>124: </em>    <font color="red"><strong>}</strong></font>
<em>125: </em>    vf = vf / y;
<em>126: </em>    mprintf (<font color="red">&quot;%lld.%02lld&quot;</font>, vi, vf);
<em>127: </em>  <font color="red"><strong>}</strong></font>
<em>128: </em><font color="red"><strong>}</strong></font>
<em>129: </em>
<em>130: </em><font color="#ffa600"><em>// Debugging output:  Only displays if debug variable is set.</em></font>
<em>131: </em>bool Debug = false;
<em>132: </em>int dprintf(const char *fmt, ... )
<em>133: </em><font color="red"><strong>{</strong></font>
<em>134: </em>  <strong>if</strong> (Debug) <font color="red"><strong>{</strong></font>
<em>135: </em>    va_list ap;
<em>136: </em>    va_start (ap,fmt);
<em>137: </em>    int c = mprintf(fmt,ap);
<em>138: </em>    va_end (ap);
<em>139: </em>    <strong>return</strong> c;
<em>140: </em>  <font color="red"><strong>}</strong></font>
<em>141: </em>  <strong>return</strong> 0;
<em>142: </em><font color="red"><strong>}</strong></font>
<em>143: </em>
<em>144: </em><font color="#ffa600"><em>//////////////////////////// think /////////////////////////////// </em></font>
<em>145: </em>
<em>146: </em><font color="#ffa600"><em>// uses up compute time for the right number of microseconds</em></font>
<em>147: </em><font color="#ffa600"><em>// given the number of instructions and the MIPS rate</em></font>
<em>148: </em>void think(int32 mips, int32 instructions) 
<em>149: </em><font color="red"><strong>{</strong></font>
<em>150: </em>  pBusy(instructions/mips);
<em>151: </em><font color="red"><strong>}</strong></font>
<em>152: </em>
<em>153: </em><font color="#ffa600"><em>//////////////////////////// user //////////////////////////////////</em></font>
<em>154: </em>
<em>155: </em><font color="#ffa600"><em>// a user</em></font>
<em>156: </em>void user(Chan &amp;in, Chan &amp;out, int32 usernum, int32 max_in,
<em>157: </em>          int32 &amp;transactions1, int32 &amp;times1, int32 &amp;transactions, int32 &amp;times)
<em>158: </em><font color="red"><strong>{</strong></font>
<em>159: </em>  int32 sigma_t = 0, dt;
<em>160: </em>  int32 count = 0;
<em>161: </em>  pDelay(Rand.uniform(0, 0, ThinkTime * msec)); <font color="#ffa600"><em>//stagger the start-ups of the users</em></font>
<em>162: </em>  ptime_t now, max = max_in;
<em>163: </em>  <strong>while</strong> ((now = pTime()) &lt; max) <font color="red"><strong>{</strong></font>
<em>164: </em>    int32 dummy, t;
<em>165: </em>    t = now;
<em>166: </em>    dprintf (<font color="red">&quot;user %d:  Sent request\n&quot;</font>,usernum);
<em>167: </em>    out.write(usernum);
<em>168: </em>    dummy = in.get();
<em>169: </em>    dprintf (<font color="red">&quot;user %d:  Got response.\n&quot;</font>,usernum);
<em>170: </em>    dt = (now - t)/msec;            <font color="#ffa600"><em>// delta t in milliseconds</em></font>
<em>171: </em>    count = count + 1;              <font color="#ffa600"><em>// number of transactions</em></font>
<em>172: </em>    sigma_t = sigma_t + dt;             <font color="#ffa600"><em>// total response time</em></font>
<em>173: </em>    transactions1 = transactions1 + 1;      <font color="#ffa600"><em>// global transaction sigma</em></font>
<em>174: </em>    times1 = times1 + dt;                   <font color="#ffa600"><em>// global response time sigma</em></font>
<em>175: </em>    pDelay(Rand.uniform(0, (ThinkTime - ThinkVar) * msec, 
<em>176: </em>                 (ThinkTime + ThinkVar) * msec));
<em>177: </em>    dprintf (<font color="red">&quot;user %d:  Total transactions %d at time %lld\n&quot;</font>,usernum,transactions1,now);
<em>178: </em>  <font color="red"><strong>}</strong></font>
<em>179: </em>  dprintf (<font color="red">&quot;user %d:  Done.\n&quot;</font>);
<em>180: </em>  transactions = transactions + count;
<em>181: </em>  times = times + sigma_t;
<em>182: </em><font color="red"><strong>}</strong></font>
<em>183: </em>
<em>184: </em><font color="#ffa600"><em>///////////////////////// curr_stats ////////////////////////</em></font>
<em>185: </em>
<em>186: </em>void curr_stats(int32 maxtime, int32 &amp;transactions, int32 &amp;time) 
<em>187: </em><font color="red"><strong>{</strong></font>
<em>188: </em>  say(<font color="red">&quot;\n..&quot;</font>);
<em>189: </em>  printfixed(pTime(), sec);
<em>190: </em>  say(<font color="red">&quot; secs of &quot;</font>);
<em>191: </em>  printfixed(maxtime, sec);
<em>192: </em>  say(<font color="red">&quot; did &quot;</font>);
<em>193: </em>  saynum(transactions);
<em>194: </em>  say(<font color="red">&quot; = &quot;</font>);
<em>195: </em>  printfixed(time, transactions);
<em>196: </em>  say(<font color="red">&quot;ms/t;&quot;</font>);
<em>197: </em><font color="red"><strong>}</strong></font>
<em>198: </em>    
<em>199: </em><font color="#ffa600"><em>////////////////////////////// dots ////////////////////////////////</em></font>
<em>200: </em>
<em>201: </em><font color="#ffa600"><em>// simply prints a dot every dt time units</em></font>
<em>202: </em>void dots(int32 dt) 
<em>203: </em><font color="red"><strong>{</strong></font>
<em>204: </em>  <strong>if</strong> (dt &lt;= 0) <font color="red"><strong>{</strong></font>
<em>205: </em>    dt = 1;
<em>206: </em>  <font color="red"><strong>}</strong></font>
<em>207: </em>  <strong>while</strong>(1) <font color="red"><strong>{</strong></font>
<em>208: </em>    say(<font color="red">&quot;.&quot;</font>);
<em>209: </em>    sayflush();
<em>210: </em>    pDelay(dt);
<em>211: </em>  <font color="red"><strong>}</strong></font>
<em>212: </em><font color="red"><strong>}</strong></font>
<em>213: </em>
<em>214: </em><font color="#ffa600"><em>//////////////////////////// timestamp /////////////////////////////</em></font>
<em>215: </em>
<em>216: </em><font color="#ffa600"><em>// simply prints time every dt units</em></font>
<em>217: </em>void timestamp(int32 dt, int32 maxtime, int32 &amp;transactions, int32 &amp;time) 
<em>218: </em><font color="red"><strong>{</strong></font>
<em>219: </em>  int32 newtime = 0;
<em>220: </em>  ptime_t EndTime;
<em>221: </em>  int32 LastCount = 0, LastTime = 0;
<em>222: </em>  int32 newtrans, newdt, oldtrans = 0, olddt = 0;
<em>223: </em>    
<em>224: </em>  EndTime = (maxtime + (10 * ((ThinkTime + ThinkVar)* msec)));
<em>225: </em>  <strong>if</strong> (maxtime &lt; 0) <font color="red"><strong>{</strong></font>
<em>226: </em>    maxtime = 0x7fffffff;
<em>227: </em>  <font color="red"><strong>}</strong></font>
<em>228: </em>  <strong>if</strong> (EndTime &lt; 0) <font color="red"><strong>{</strong></font>
<em>229: </em>    EndTime = 0x7fffffff;
<em>230: </em>  <font color="red"><strong>}</strong></font>
<em>231: </em>  <strong>while</strong>(1) <font color="red"><strong>{</strong></font>
<em>232: </em>    <strong>if</strong> (pTime() &gt; EndTime) <font color="red"><strong>{</strong></font>
<em>233: </em>      say(<font color="red">&quot;\n====Running much longer than expected; asked-for time is &quot;</font>);
<em>234: </em>      printfixed(maxtime, msec);
<em>235: </em>      say(<font color="red">&quot;\n\tmsec and now is &quot;</font>);
<em>236: </em>      saynum(pTime()/msec);
<em>237: </em>      say(<font color="red">&quot; msec.\n\n&quot;</font>);
<em>238: </em>      curr_stats(maxtime, transactions, time);
<em>239: </em>      pExit(1);
<em>240: </em>    <font color="red"><strong>}</strong></font>
<em>241: </em>    
<em>242: </em>    curr_stats(maxtime, transactions, time);
<em>243: </em>    <font color="#ffa600"><em>// now give average msec/transaction since last time</em></font>
<em>244: </em>    newtrans = transactions - LastCount;
<em>245: </em>    newdt   = time - LastTime;
<em>246: </em>    <strong>if</strong> (newtrans &gt; 0) <font color="red"><strong>{</strong></font>     
<em>247: </em>      int32 n, t;   
<em>248: </em>      say(<font color="red">&quot; (&quot;</font>);
<em>249: </em>      t = (newdt + olddt)/2;
<em>250: </em>      n = (newtrans + oldtrans)/2;
<em>251: </em>      printfixed(t, n);
<em>252: </em>      olddt = t;
<em>253: </em>      oldtrans = n;
<em>254: </em>      LastCount = transactions;
<em>255: </em>      LastTime	= time; 
<em>256: </em>      say(<font color="red">&quot;ms/t)&quot;</font>);
<em>257: </em>    <font color="red"><strong>}</strong></font>
<em>258: </em>  
<em>259: </em>    say(<font color="red">&quot;-&gt;&quot;</font>);
<em>260: </em>    printfixed(newtrans, dt/sec);
<em>261: </em>    say(<font color="red">&quot;tps.&quot;</font>);
<em>262: </em>    sayflush();
<em>263: </em>    pDelay((newtime + dt) - pTime());
<em>264: </em>    newtime = newtime + dt;
<em>265: </em>  <font color="red"><strong>}</strong></font>
<em>266: </em><font color="red"><strong>}</strong></font>   
<em>267: </em>    
<em>268: </em><font color="#ffa600"><em>/////////////////////////// comms_in //////////////////////////</em></font>
<em>269: </em>
<em>270: </em><font color="#ffa600"><em>// comms_in listens to the terminals and sends their messages on to</em></font>
<em>271: </em><font color="#ffa600"><em>//	one of the available transaction processes</em></font>
<em>272: </em>
<em>273: </em>void comms_in(int32 mips, Chans &amp;in, Chans &amp;out, Chans &amp;free) 
<em>274: </em><font color="red"><strong>{</strong></font>
<em>275: </em>  int32 terminal, tp;
<em>276: </em>  say(<font color="red">&quot;\nComms starting.&quot;</font>);
<em>277: </em>  <strong>while</strong> (1) <font color="red"><strong>{</strong></font>
<em>278: </em>    afor (int i = 0; i != (int)in.size(); ++i) <font color="red"><strong>{</strong></font>
<em>279: </em>      in[i].port(int v) <font color="red"><strong>{</strong></font>
<em>280: </em>        <font color="#ffa600"><em>// Drain a value from the input channels.</em></font>
<em>281: </em>        terminal = v;
<em>282: </em>        dprintf (<font color="red">&quot;comms_in:  Got a value from terminal %d\n&quot;</font>,v);
<em>283: </em>      <font color="red"><strong>}</strong></font>
<em>284: </em>    <font color="red"><strong>}</strong></font>
<em>285: </em>    <font color="#ffa600"><em>// Got input from a terminal; now find a free tp process</em></font>
<em>286: </em>    afor (int i = 0; i != (int)free.size(); ++i) <font color="red"><strong>{</strong></font>
<em>287: </em>      free[i].port() <font color="red"><strong>{</strong></font>
<em>288: </em>        tp = i;
<em>289: </em>        dprintf (<font color="red">&quot;comms_in:  Got a tp process %d\n&quot;</font>,tp);
<em>290: </em>      <font color="red"><strong>}</strong></font>
<em>291: </em>    <font color="red"><strong>}</strong></font>
<em>292: </em>    <font color="#ffa600"><em>// Compute.</em></font>
<em>293: </em>    think(mips, TermInPath);
<em>294: </em>    dprintf (<font color="red">&quot;comms_in:  Finished thinking.\n&quot;</font>);
<em>295: </em>    <font color="#ffa600"><em>// Send value.</em></font>
<em>296: </em>    out[tp].write(terminal);
<em>297: </em>    dprintf (<font color="red">&quot;comms_in:  Wrote value %d to tp %d\n&quot;</font>,terminal,tp);
<em>298: </em>  <font color="red"><strong>}</strong></font>
<em>299: </em><font color="red"><strong>}</strong></font>
<em>300: </em>
<em>301: </em><font color="#ffa600"><em>/////////////////////////////// comms_out /////////////////////////</em></font>
<em>302: </em>
<em>303: </em><font color="#ffa600"><em>// This collects up the outputs from the tp agents and sends them</em></font>
<em>304: </em><font color="#ffa600"><em>// back out to the terminals    </em></font>
<em>305: </em>void comms_out(int32 mips, Chans &amp;from_agents, Chans &amp;to_terminals)
<em>306: </em><font color="red"><strong>{</strong></font>
<em>307: </em>  int32 terminal;
<em>308: </em>  <strong>while</strong>(1) <font color="red"><strong>{</strong></font>
<em>309: </em>    afor(unsigned i = 0; i != from_agents.size(); ++i) <font color="red"><strong>{</strong></font>
<em>310: </em>      from_agents[i].port(int v) <font color="red"><strong>{</strong></font>
<em>311: </em>        terminal = v;
<em>312: </em>        dprintf (<font color="red">&quot;comms_out:  Got tp message of %d.\n&quot;</font>,terminal);
<em>313: </em>      <font color="red"><strong>}</strong></font>
<em>314: </em>    <font color="red"><strong>}</strong></font>
<em>315: </em>    <font color="#ffa600"><em>// ok, got the value back from the system. give it to a terminal</em></font>
<em>316: </em>    think(mips, TermOutPath);
<em>317: </em>    dprintf (<font color="red">&quot;comms_out:  Finished thinking.\n&quot;</font>);
<em>318: </em>    to_terminals[terminal].write(terminal);
<em>319: </em>    dprintf (<font color="red">&quot;comms_out:  Send messageof %d to terminal %d.\n&quot;</font>,terminal,terminal);
<em>320: </em>  <font color="red"><strong>}</strong></font>
<em>321: </em><font color="red"><strong>}</strong></font>
<em>322: </em>    
<em>323: </em><font color="#ffa600"><em>//////////////////////// transaction routines /////////////////////</em></font>
<em>324: </em>
<em>325: </em><font color="#ffa600"><em>// these routines 'do transactions'; they call upon the memory manager</em></font>
<em>326: </em><font color="#ffa600"><em>//	(who can be in essence a ram manager or a disk manager) to read,</em></font>
<em>327: </em><font color="#ffa600"><em>//	lock, write, free etc things, and they wait for writes to complete</em></font>
<em>328: </em><font color="#ffa600"><em>//	appropriately thus getting the right amount of performance-sapping</em></font>
<em>329: </em><font color="#ffa600"><em>//	synchronisation</em></font>
<em>330: </em>
<em>331: </em><font color="#ffa600"><em>//	in this version, everybody just tosses pennies; there's no representation</em></font>
<em>332: </em><font color="#ffa600"><em>//	of real records. also, we assume no contention for records for the moment</em></font>
<em>333: </em><font color="#ffa600"><em>//	and further, we assume that no record is locked over multiple terminal</em></font>
<em>334: </em><font color="#ffa600"><em>//	requests.</em></font>
<em>335: </em>
<em>336: </em><font color="#ffa600"><em>///////////////////////// DISKS ////////////////////////////////</em></font>
<em>337: </em>
<em>338: </em>const int32 Read = 0, Write_synch = 1, Write_asynch = 2;
<em>339: </em>
<em>340: </em><font color="#ffa600"><em>//////////////////////// disk_manager //////////////////////////</em></font>
<em>341: </em>
<em>342: </em><font color="#ffa600"><em>// the disk manager listens to all the tp agents who may sometimes</em></font>
<em>343: </em><font color="#ffa600"><em>// call upon him to do disk accesses</em></font>
<em>344: </em><font color="#ffa600"><em>// the disk manager runs a number of disks, which he chooses between </em></font>
<em>345: </em><font color="#ffa600"><em>// at random for a request. each disk is represented by a process</em></font>
<em>346: </em><strong>class</strong> DiskManager <font color="red"><strong>{</strong></font>
<em>347: </em>
<em>348: </em>public:
<em>349: </em>
<em>350: </em>  <font color="#ffa600"><em>// a sequential buffer implementation</em></font>
<em>351: </em>  void drive_buffer(int32 buff_size, Chan &amp;in, Chan &amp;out, int32 number) 
<em>352: </em>  <font color="red"><strong>{</strong></font>
<em>353: </em>    IntVect stuff(buff_size);
<em>354: </em>
<em>355: </em>    Chan in_to_out, out_to_in;
<em>356: </em>    bool in_asleep = false, out_asleep = true;
<em>357: </em>    int32 inptr = 0, outptr = 0, count = 0;
<em>358: </em>
<em>359: </em>    <font color="#ffa600"><em>// the input handler    </em></font>
<em>360: </em>    par <font color="red"><strong>{</strong></font>
<em>361: </em>      <font color="red"><strong>{</strong></font>
<em>362: </em>        int32 any;
<em>363: </em>        <strong>while</strong>(1) <font color="red"><strong>{</strong></font>
<em>364: </em>          int32 data = in.get();
<em>365: </em>          stuff[inptr] = data;
<em>366: </em>          inptr = (inptr + 1) % buff_size;	<font color="#ffa600"><em>// increment in pointer</em></font>
<em>367: </em>          count = count + 1;            <font color="#ffa600"><em>// increment count</em></font>
<em>368: </em>          <strong>if</strong> (out_asleep) <font color="red"><strong>{</strong></font>
<em>369: </em>            out_asleep = false;
<em>370: </em>            in_to_out.write(any);
<em>371: </em>          <font color="red"><strong>}</strong></font>
<em>372: </em>          <strong>if</strong> (count == buff_size) <font color="red"><strong>{</strong></font>
<em>373: </em>            <font color="#ffa600"><em>// buffer is full</em></font>
<em>374: </em>            in_asleep = true;
<em>375: </em>            any = out_to_in.get();
<em>376: </em>          <font color="red"><strong>}</strong></font>
<em>377: </em>        <font color="red"><strong>}</strong></font>
<em>378: </em>      <font color="red"><strong>}</strong></font>
<em>379: </em>      <font color="red"><strong>{</strong></font>
<em>380: </em>        <font color="#ffa600"><em>// the output handler   </em></font>
<em>381: </em>        int32 data, any;
<em>382: </em>        <strong>while</strong>(1) <font color="red"><strong>{</strong></font>
<em>383: </em>          <font color="#ffa600"><em>// first see if we got any data</em></font>
<em>384: </em>          <strong>if</strong> (out_asleep) <font color="red"><strong>{</strong></font>
<em>385: </em>            any = in_to_out.get();	<font color="#ffa600"><em>// wait for stuff</em></font>
<em>386: </em>          <font color="red"><strong>}</strong></font>
<em>387: </em>          data = stuff[outptr];
<em>388: </em>          out.write(data);
<em>389: </em>          outptr = (outptr + 1) % buff_size;
<em>390: </em>          count = count - 1;
<em>391: </em>          <strong>if</strong> (in_asleep) <font color="red"><strong>{</strong></font>
<em>392: </em>            <font color="#ffa600"><em>// in has gone to sleep</em></font>
<em>393: </em>            in_asleep = false;
<em>394: </em>            out_to_in.write(any);   <font color="#ffa600"><em>// wake him up</em></font>
<em>395: </em>          <font color="red"><strong>}</strong></font>
<em>396: </em>          <strong>if</strong> (count == 0) <font color="red"><strong>{</strong></font>
<em>397: </em>            out_asleep = true;
<em>398: </em>          <font color="red"><strong>}</strong></font>
<em>399: </em>        <font color="red"><strong>}</strong></font>    
<em>400: </em>      <font color="red"><strong>}</strong></font>
<em>401: </em>    <font color="red"><strong>}</strong></font>
<em>402: </em>  <font color="red"><strong>}</strong></font>
<em>403: </em>
<em>404: </em>  <font color="#ffa600"><em>//////////////////////// drive /////////////////////////</em></font>
<em>405: </em>
<em>406: </em>  void drive(Chan &amp;in, Chan &amp;out, int32 n) 
<em>407: </em>  <font color="red"><strong>{</strong></font>
<em>408: </em>    int32 cmnd;
<em>409: </em>    const int32 rotation_time = 10 * msec;
<em>410: </em>    const int32 seek_time = 100 * musec;    <font color="#ffa600"><em>// per track</em></font>
<em>411: </em>    const int32 settling_time = 1 * msec;
<em>412: </em>    const int32 num_tracks	= 100;
<em>413: </em>    <font color="#ffa600"><em>// these disks have a rotation speed of 10 msec, a head movement and</em></font>
<em>414: </em>    <font color="#ffa600"><em>// settling time of 100musec/track + 1 msec, 100 tracks, and are </em></font>
<em>415: </em>    <font color="#ffa600"><em>// unsynchronised.</em></font>
<em>416: </em>    
<em>417: </em>    int32 agent;
<em>418: </em>    int32 track = 0;
<em>419: </em>    int32 newtrack = 0;
<em>420: </em>    int32 dtrack;
<em>421: </em>    
<em>422: </em>    pDelay(Rand.uniform(0, 10 * msec, 20 * msec));
<em>423: </em>    <strong>while</strong>(1) <font color="red"><strong>{</strong></font>
<em>424: </em>      int32 wait_time;
<em>425: </em>      
<em>426: </em>      cmnd = in.get();             <font color="#ffa600"><em>// get the composite command</em></font>
<em>427: </em>      agent = cmnd &gt;&gt; 16;          <font color="#ffa600"><em>// resolve into agent number</em></font>
<em>428: </em>      cmnd = cmnd &amp; 255;           <font color="#ffa600"><em>// ..and command</em></font>
<em>429: </em>      newtrack = Rand.uniform(0, 0, num_tracks);
<em>430: </em>      <strong>if</strong> (newtrack &lt; track) <font color="red"><strong>{</strong></font>
<em>431: </em>    dtrack = track - newtrack;
<em>432: </em>      <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em>433: </em>        dtrack = newtrack - track;
<em>434: </em>      <font color="red"><strong>}</strong></font>
<em>435: </em>      wait_time = Rand.uniform(0, 0, rotation_time) + <font color="#ffa600"><em>// rotate latency</em></font>
<em>436: </em>        (dtrack * seek_time) +      <font color="#ffa600"><em>// seek latency</em></font>
<em>437: </em>        settling_time;
<em>438: </em>      pDelay(wait_time);
<em>439: </em>      <font color="#ffa600"><em>// synchronous command?</em></font>
<em>440: </em>      <strong>if</strong> ((cmnd == Read) || (cmnd == Write_synch)) <font color="red"><strong>{</strong></font>
<em>441: </em>    out.write(agent);
<em>442: </em>      <font color="red"><strong>}</strong></font>
<em>443: </em>      pDelay(100 * musec);
<em>444: </em>    <font color="red"><strong>}</strong></font>
<em>445: </em>  <font color="red"><strong>}</strong></font>
<em>446: </em>
<em>447: </em>  <font color="#ffa600"><em>///////////////////////// manager /////////////////////////</em></font>
<em>448: </em>    
<em>449: </em>  <font color="#ffa600"><em>// Accepts commands from tp agents and sends to drives</em></font>
<em>450: </em>  void manager(int32 mips, int32 disks, Chans &amp;commands, Chans &amp;to_drives)
<em>451: </em>  <font color="red"><strong>{</strong></font>  
<em>452: </em>    int32 cmnd, agent, drivenum, composite;
<em>453: </em>    say(<font color="red">&quot;\nDisk manager starting.&quot;</font>);    
<em>454: </em>    <strong>while</strong>(1) <font color="red"><strong>{</strong></font>
<em>455: </em>      dprintf (<font color="red">&quot;disk manager:  waiting for command.\n&quot;</font>,cmnd,agent);
<em>456: </em>      afor(unsigned i = 0; i != commands.size(); ++i) <font color="red"><strong>{</strong></font>
<em>457: </em>        commands[i].port(int v) <font color="red"><strong>{</strong></font>
<em>458: </em>          cmnd = v;
<em>459: </em>          agent = i;
<em>460: </em>          dprintf (<font color="red">&quot;disk manager:  command %d from %d.\n&quot;</font>,cmnd,agent);
<em>461: </em>        <font color="red"><strong>}</strong></font>
<em>462: </em>      <font color="red"><strong>}</strong></font>
<em>463: </em>      <font color="#ffa600"><em>// got a request from a tp agent; assign it to a drive</em></font>
<em>464: </em>      drivenum = Rand.uniform(0, 0, disks);     <font color="#ffa600"><em>// chooses rv in 0..disks-1</em></font>
<em>465: </em>      composite = cmnd + (agent &lt;&lt; 16);
<em>466: </em>      think(mips, DiskCmndPath);        <font color="#ffa600"><em>// IO-issuing path length</em></font>
<em>467: </em>      to_drives[drivenum].write(composite);
<em>468: </em>      dprintf (<font color="red">&quot;disk manager:  wrote message to drives.\n&quot;</font>);
<em>469: </em>    <font color="red"><strong>}</strong></font>
<em>470: </em>  <font color="red"><strong>}</strong></font>
<em>471: </em>
<em>472: </em>  <font color="#ffa600"><em>///////////////////////// responder ////////////////////////////</em></font>
<em>473: </em>
<em>474: </em>  <font color="#ffa600"><em>// the disk interrupt handler; catches 'done' messages from disks,</em></font>
<em>475: </em>  <font color="#ffa600"><em>// sends signal to appropriate tp agent</em></font>
<em>476: </em>  void responder(int32 mips, Chans &amp;to_agents, Chans &amp;from_disks) 
<em>477: </em>  <font color="red"><strong>{</strong></font>
<em>478: </em>    int32 agent;
<em>479: </em>    <strong>while</strong>(1) <font color="red"><strong>{</strong></font>
<em>480: </em>      afor (unsigned i = 0; i != from_disks.size(); ++i) <font color="red"><strong>{</strong></font>
<em>481: </em>        from_disks[i].port(int v) <font color="red"><strong>{</strong></font>
<em>482: </em>          agent = v;
<em>483: </em>        <font color="red"><strong>}</strong></font>
<em>484: </em>      <font color="red"><strong>}</strong></font>
<em>485: </em>      to_agents[agent].write(agent);
<em>486: </em>      think(mips, DiskResponsePath);            
<em>487: </em>    <font color="red"><strong>}</strong></font>
<em>488: </em>  <font color="red"><strong>}</strong></font>
<em>489: </em>
<em>490: </em>public:
<em>491: </em>  <font color="#ffa600"><em>// Now, the body of the disk manager just runs the manager on the</em></font>
<em>492: </em>  <font color="#ffa600"><em>// computer and the drives on themselves</em></font>
<em>493: </em>  void operator()(int32 mips, int32 buff_size, int32 disks, Chans &amp;in, Chans &amp;out) 
<em>494: </em>  <font color="red"><strong>{</strong></font>
<em>495: </em>    Chans to_drives(disks), from_drives(disks), buff_to_drives(disks);
<em>496: </em>    
<em>497: </em>    par <font color="red"><strong>{</strong></font>
<em>498: </em>      par <font color="red"><strong>{</strong></font>
<em>499: </em>        on (mainframe) <font color="red"><strong>{</strong></font>
<em>500: </em>          manager(mips, disks, in, to_drives);
<em>501: </em>        <font color="red"><strong>}</strong></font>
<em>502: </em>        on (mainframe) <font color="red"><strong>{</strong></font>
<em>503: </em>          responder(mips, out, from_drives);
<em>504: </em>        <font color="red"><strong>}</strong></font>
<em>505: </em>      <font color="red"><strong>}</strong></font>
<em>506: </em>      pfor (int i = 0; i != disks; ++i) <font color="red"><strong>{</strong></font>
<em>507: </em>        on (diskdrives[i]) <font color="red"><strong>{</strong></font>
<em>508: </em>          drive(buff_to_drives[i], from_drives[i], i);
<em>509: </em>        <font color="red"><strong>}</strong></font>
<em>510: </em>      <font color="red"><strong>}</strong></font>
<em>511: </em>      pfor (int i = 0; i != disks; ++i) <font color="red"><strong>{</strong></font>      
<em>512: </em>        on (diskdrives[i]) <font color="red"><strong>{</strong></font>
<em>513: </em>          drive_buffer(buff_size, to_drives[i], buff_to_drives[i], i); 
<em>514: </em>        <font color="red"><strong>}</strong></font>
<em>515: </em>      <font color="red"><strong>}</strong></font>
<em>516: </em>    <font color="red"><strong>}</strong></font>
<em>517: </em>  <font color="red"><strong>}</strong></font>
<em>518: </em>
<em>519: </em><font color="red"><strong>}</strong></font>;
<em>520: </em>
<em>521: </em><font color="#ffa600"><em>// reads a block from disk by sending the disk manager a message    </em></font>
<em>522: </em>void disk_read(Chan &amp;to_disks, Chan &amp;from_disks) 
<em>523: </em><font color="red"><strong>{</strong></font>
<em>524: </em>  dprintf (<font color="red">&quot;disk_read:  start %d.\n&quot;</font>,Read);
<em>525: </em>  to_disks.write(Read);
<em>526: </em>  dprintf (<font color="red">&quot;disk_read:  before get.\n&quot;</font>);
<em>527: </em>  from_disks.get();
<em>528: </em>  dprintf (<font color="red">&quot;disk_read:  finish.\n&quot;</font>);
<em>529: </em><font color="red"><strong>}</strong></font>
<em>530: </em>
<em>531: </em><font color="#ffa600"><em>// writes a block to the disk controller</em></font>
<em>532: </em>void disk_write_asynch(Chan &amp;to_disks, Chan &amp;from_disks) 
<em>533: </em><font color="red"><strong>{</strong></font>
<em>534: </em>  to_disks.write(Write_asynch);
<em>535: </em><font color="red"><strong>}</strong></font>
<em>536: </em>    
<em>537: </em><font color="#ffa600"><em>// writes a block to the disk</em></font>
<em>538: </em>void disk_write_synch(Chan &amp;to_disks, Chan &amp;from_disks) 
<em>539: </em><font color="red"><strong>{</strong></font>
<em>540: </em>  to_disks.write(Write_synch);
<em>541: </em>  from_disks.get();
<em>542: </em><font color="red"><strong>}</strong></font>
<em>543: </em>
<em>544: </em><font color="#ffa600"><em>//////////////////////////// MEMORY /////////////////////////////</em></font>
<em>545: </em>
<em>546: </em><font color="#ffa600"><em>// asks for stuff from the memory system; in a normal system, this means</em></font>
<em>547: </em><font color="#ffa600"><em>// going to a disk; in a giant memory system, it means reading memory. we</em></font>
<em>548: </em><font color="#ffa600"><em>// treat the thing as cached, with a supplied hit rate. with 100% hit, we</em></font>
<em>549: </em><font color="#ffa600"><em>// always go to memory; with 90% hit rate we go to disk 10% of the time</em></font>
<em>550: </em><a name="550" class="mark"></a><font color="#ffa600"><em></em></font>
<em>551: </em>void mem_read(Chan &amp;to_disks, Chan &amp;from_disks, int32 hit_rate) 
<em>552: </em><font color="red"><strong>{</strong></font>
<em>553: </em>  dprintf (<font color="red">&quot;mem_read:  starting.\n&quot;</font>);
<em>554: </em>  <strong>if</strong> (Rand.uniform(0, 0, 1000) &gt; hit_rate) <font color="red"><strong>{</strong></font>
<em>555: </em>    dprintf (<font color="red">&quot;mem_read:  disk write asynch start.\n&quot;</font>);
<em>556: </em>    <font color="#ffa600"><em>// hit_rate is an integer in 0..999; if our rv is larger than hitrate</em></font>
<em>557: </em>    <font color="#ffa600"><em>//then we have a MISS   </em></font>
<em>558: </em>    disk_read(to_disks, from_disks);
<em>559: </em>    dprintf (<font color="red">&quot;mem_read:  disk write asynch finish.\n&quot;</font>);
<em>560: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em>561: </em>    <font color="#ffa600"><em>// memory read; this is quick; assume 10 microseconds</em></font>
<em>562: </em>    dprintf (<font color="red">&quot;mem_read:  delay start.\n&quot;</font>);
<em>563: </em>    pDelay(15 * musec);
<em>564: </em>    dprintf (<font color="red">&quot;mem_read:  delay finish.\n&quot;</font>);
<em>565: </em>  <font color="red"><strong>}</strong></font>
<em>566: </em>  dprintf (<font color="red">&quot;mem_read:  finished.\n&quot;</font>);
<em>567: </em><font color="red"><strong>}</strong></font>
<em>568: </em>    
<em>569: </em>void mem_write_synch(Chan &amp;to_disks, Chan &amp;from_disks, int32 hit_rate) 
<em>570: </em><font color="red"><strong>{</strong></font>
<em>571: </em>  <font color="#ffa600"><em>// gives stuff to the memory system and waits for write to finish</em></font>
<em>572: </em>  <strong>if</strong> (Rand.uniform(0, 0, 1000) &gt; hit_rate) <font color="red"><strong>{</strong></font>
<em>573: </em>    <font color="#ffa600"><em>// hit_rate is an integer in 0..999; if our rv is larger than hitrate</em></font>
<em>574: </em>    <font color="#ffa600"><em>// then we have a MISS</em></font>
<em>575: </em>    disk_write_synch(to_disks, from_disks);
<em>576: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em>577: </em>    <font color="#ffa600"><em>// memory write; this is quick; assume 10 microseconds</em></font>
<em>578: </em>    pDelay(15 * musec);
<em>579: </em>  <font color="red"><strong>}</strong></font>
<em>580: </em><font color="red"><strong>}</strong></font>
<em>581: </em>    
<em>582: </em>void mem_write_asynch(Chan &amp;to_disks, Chan &amp;from_disks, int32 hit_rate)
<em>583: </em><font color="red"><strong>{</strong></font>
<em>584: </em>  dprintf (<font color="red">&quot;mem_write_asynch:  starting.\n&quot;</font>);
<em>585: </em>  <font color="#ffa600"><em>// gives stuff to the memory system</em></font>
<em>586: </em>  <strong>if</strong> (Rand.uniform(0, 0, 1000) &gt; hit_rate) <font color="red"><strong>{</strong></font>
<em>587: </em>    dprintf (<font color="red">&quot;mem_write_asynch:  disk write asynch start.\n&quot;</font>);
<em>588: </em>    disk_write_asynch(to_disks, from_disks);
<em>589: </em>    dprintf (<font color="red">&quot;mem_write_asynch:  disk write asynch finish.\n&quot;</font>);
<em>590: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em>591: </em>    <font color="#ffa600"><em>// memory write; this is quick; assume 10 microseconds</em></font>
<em>592: </em>    dprintf (<font color="red">&quot;mem_write_asynch:  delay start.\n&quot;</font>);
<em>593: </em>    pDelay(15 * musec);
<em>594: </em>    dprintf (<font color="red">&quot;mem_write_asynch:  delay finish.\n&quot;</font>);
<em>595: </em>  <font color="red"><strong>}</strong></font>
<em>596: </em>  dprintf (<font color="red">&quot;mem_write_asynch:  finished.\n&quot;</font>);
<em>597: </em><font color="red"><strong>}</strong></font>
<em>598: </em>
<em>599: </em><font color="#ffa600"><em>//////////////////// RECORDS AND JOURNALS /////////////////////////</em></font>
<em>600: </em>
<em>601: </em>void before_journal(Chan &amp;to_disks, Chan &amp;from_disks, int32 hit_rate) 
<em>602: </em><font color="red"><strong>{</strong></font>
<em>603: </em>  <font color="#ffa600"><em>// this writes an entry to the before journal; no synchronisation is needed</em></font>
<em>604: </em>  <font color="#ffa600"><em>//say(&quot;\n\tBeforeJrnl&quot;);</em></font>
<em>605: </em>  mem_write_asynch(to_disks, from_disks, hit_rate);
<em>606: </em><font color="red"><strong>}</strong></font>
<em>607: </em>    
<em>608: </em>void after_journal(Chan &amp;to_disks, Chan &amp;from_disks, int32 hit_rate) 
<em>609: </em><font color="red"><strong>{</strong></font>
<em>610: </em>  <font color="#ffa600"><em>// this write an entry to the after journal; must wait until complete</em></font>
<em>611: </em>  mem_write_synch(to_disks, from_disks, hit_rate);
<em>612: </em><font color="red"><strong>}</strong></font>
<em>613: </em>    
<em>614: </em>void get_record(Chan &amp;to_disks, Chan &amp;from_disks, int32 hit_rate) 
<em>615: </em><font color="red"><strong>{</strong></font>
<em>616: </em>  <font color="#ffa600"><em>// reads a record from the database</em></font>
<em>617: </em>  mem_read(to_disks, from_disks, hit_rate);
<em>618: </em><font color="red"><strong>}</strong></font>
<em>619: </em>    
<em>620: </em>void put_record(Chan &amp;to_disks, Chan &amp;from_disks, int32 hit_rate) 
<em>621: </em><font color="red"><strong>{</strong></font>
<em>622: </em>  <font color="#ffa600"><em>// synchronised write to memory</em></font>
<em>623: </em>  mem_write_synch(to_disks, from_disks, hit_rate);
<em>624: </em><font color="red"><strong>}</strong></font>
<em>625: </em>
<em>626: </em>void read_record(int32 mips, Chan &amp;to_disks, Chan &amp;from_disks, int32 hit_rate)
<em>627: </em><font color="red"><strong>{</strong></font>
<em>628: </em>  <font color="#ffa600"><em>// this routine does a read operation on one record</em></font>
<em>629: </em>  dprintf (<font color="red">&quot;read_record:  start.\n&quot;</font>);
<em>630: </em>  before_journal(to_disks, from_disks, hit_rate);
<em>631: </em>  think(mips, ReadPath);
<em>632: </em>  dprintf (<font color="red">&quot;read_record:  before get.\n&quot;</font>);
<em>633: </em>  get_record(to_disks, from_disks, hit_rate);
<em>634: </em>  dprintf (<font color="red">&quot;read_record:  finish.\n&quot;</font>);
<em>635: </em><font color="red"><strong>}</strong></font>
<em>636: </em>    
<em>637: </em>void update_record(int32 mips, Chan &amp;to_disks, Chan &amp;from_disks, int32 hit_rate)
<em>638: </em><font color="red"><strong>{</strong></font>
<em>639: </em>  <font color="#ffa600"><em>// this does a write operation to one record</em></font>
<em>640: </em>  before_journal(to_disks, from_disks, hit_rate);
<em>641: </em>  think(mips, WritePath);
<em>642: </em>  put_record(to_disks, from_disks, hit_rate);
<em>643: </em>  after_journal(to_disks, from_disks, hit_rate);
<em>644: </em><font color="red"><strong>}</strong></font>
<em>645: </em>        
<em>646: </em><font color="#ffa600"><em>///////////////////////// TP /////////////////////////////</em></font>
<em>647: </em>
<em>648: </em><font color="#ffa600"><em>// the tp process does all the transaction work. there are multiple</em></font>
<em>649: </em><font color="#ffa600"><em>//	instantiations; each catches stuff on its in, passes stuff on through</em></font>
<em>650: </em><font color="#ffa600"><em>//	its out and signals its free to the comms mux via the free channel</em></font>
<em>651: </em>
<em>652: </em><strong>class</strong> Agents <font color="red"><strong>{</strong></font>
<em>653: </em>
<em>654: </em>public: 
<em>655: </em>  void lock_record(int32 mips) 
<em>656: </em>  <font color="red"><strong>{</strong></font>
<em>657: </em>    <font color="#ffa600"><em>// we simply compute a bit -    locks are in memory</em></font>
<em>658: </em>    think(mips, LockPath);          
<em>659: </em>  <font color="red"><strong>}</strong></font>
<em>660: </em>    
<em>661: </em>  void unlock_record(int32 mips) 
<em>662: </em>  <font color="red"><strong>{</strong></font>
<em>663: </em>    <font color="#ffa600"><em>// same again</em></font>
<em>664: </em>    think(mips, UnlockPath);
<em>665: </em>  <font color="red"><strong>}</strong></font>
<em>666: </em>
<em>667: </em>  void tp_agent(int32 mips, Chan &amp;in, Chan &amp;out, Chan &amp;free, Chan &amp;to_disks, Chan &amp;from_disks,
<em>668: </em>                int32 tp_num, int32 hit_rate)
<em>669: </em>  <font color="red"><strong>{</strong></font>         
<em>670: </em>    int32 terminal = 0,freecount = 0;
<em>671: </em>    pSetPriority(3);            <font color="#ffa600"><em>// lower priority</em></font>
<em>672: </em>    <strong>while</strong>(1) <font color="red"><strong>{</strong></font>
<em>673: </em>      dprintf (<font color="red">&quot;tp agent  %d:  is free.\n&quot;</font>,tp_num);
<em>674: </em>      free.write(freecount++);	<font color="#ffa600"><em>// signal i'm free</em></font>
<em>675: </em>      dprintf (<font color="red">&quot;tp agent  %d:  waiting for input.\n&quot;</font>,tp_num);
<em>676: </em>      terminal = in.get();	<font color="#ffa600"><em>// get some input</em></font>
<em>677: </em>      dprintf (<font color="red">&quot;tp agent %d:  got message from terminal %d.\n&quot;</font>,tp_num,terminal);
<em>678: </em>      lock_record(mips);    <font color="#ffa600"><em>// lock all the records</em></font>
<em>679: </em>      lock_record(mips);
<em>680: </em>      lock_record(mips);
<em>681: </em>      dprintf (<font color="red">&quot;tp agent  %d:  done with locking record.\n&quot;</font>,tp_num);
<em>682: </em>            
<em>683: </em>      read_record(mips, to_disks, from_disks, hit_rate);
<em>684: </em>      read_record(mips, to_disks, from_disks, hit_rate);
<em>685: </em>      dprintf (<font color="red">&quot;tp agent  %d:  done with reading record.\n&quot;</font>,tp_num);
<em>686: </em>      update_record(mips, to_disks, from_disks, hit_rate);
<em>687: </em> 
<em>688: </em>      dprintf (<font color="red">&quot;tp agent  %d:  sent message to terminal %d.\n&quot;</font>,tp_num,terminal);
<em>689: </em>      out.write(terminal);      <font color="#ffa600"><em>// provide results to terminal</em></font>
<em>690: </em>            
<em>691: </em>      unlock_record(mips);
<em>692: </em>      unlock_record(mips);
<em>693: </em>      unlock_record(mips);
<em>694: </em>      dprintf (<font color="red">&quot;tp agent  %d:  records unlocked.\n&quot;</font>,tp_num);
<em>695: </em>    <font color="red"><strong>}</strong></font>
<em>696: </em>  <font color="red"><strong>}</strong></font>
<em>697: </em>
<em>698: </em>public:
<em>699: </em>  void operator()(int32 mips, Chans &amp;in, Chans &amp;out, Chans &amp;free, Chans &amp;to_disks, Chans &amp;from_disks, 
<em>700: </em>         int32 num_agents, int32 hit_rate) 
<em>701: </em>  <font color="red"><strong>{</strong></font>
<em>702: </em>    <font color="#ffa600"><em>//	the body, forking the agents..</em></font>
<em>703: </em>    say(<font color="red">&quot;\nTP agent starting.&quot;</font>);
<em>704: </em>    pfor (int i = 0; i != num_agents; ++i) <font color="red"><strong>{</strong></font>
<em>705: </em>      tp_agent(mips, in[i], out[i], free[i], to_disks[i], from_disks[i], i, hit_rate);
<em>706: </em>    <font color="red"><strong>}</strong></font>
<em>707: </em>  <font color="red"><strong>}</strong></font>
<em>708: </em>
<em>709: </em><font color="red"><strong>}</strong></font>;
<em>710: </em>    
<em>711: </em><font color="#ffa600"><em>/////////////////////////// mainbody ////////////////////////////////////</em></font>
<em>712: </em>
<em>713: </em>void pSetup(ConfigParms &amp;cp)
<em>714: </em><font color="red"><strong>{</strong></font>
<em>715: </em>  cp._numpriorities = 4;
<em>716: </em>  cp._busyokay = true;
<em>717: </em><font color="red"><strong>}</strong></font>
<em>718: </em>
<em>719: </em>int pMain(int argc,const char *argv[]) 
<em>720: </em><font color="red"><strong>{</strong></font>       
<em>721: </em>  GC_disable();
<em>722: </em>
<em>723: </em>  int32 actual_users, hit_rate, mips, buff_size, disks, tp_agents, SimulationTime, ReportInterval;
<em>724: </em>  
<em>725: </em>  int32 transactions = 0, times = 0, sigma_transac = 0, sigma_response = 0;
<em>726: </em>
<em>727: </em>  <font color="#ffa600"><em>// main body	</em></font>
<em>728: </em>  mprintf(<font color="red">&quot;\nThe Enterprise Attack Vehicle MkII (v1.01) lifts off..\nWe have some arguments: %ld&quot;</font>, argc);
<em>729: </em>        
<em>730: </em>  <strong>if</strong> (argc &lt; 2) <font color="red"><strong>{</strong></font>
<em>731: </em>    <font color="#ffa600"><em>// no arguments offered at all; use defaults</em></font>
<em>732: </em>    actual_users = 100; <font color="#ffa600"><em>// 100</em></font>
<em>733: </em>    hit_rate = 15;
<em>734: </em>    mips = 10; <font color="#ffa600"><em>// 10</em></font>
<em>735: </em>    buff_size = 128;
<em>736: </em>    disks = 40;     <font color="#ffa600"><em>// 40</em></font>
<em>737: </em>    tp_agents = 4;      <font color="#ffa600"><em>// 4</em></font>
<em>738: </em>    SimulationTime = 500; <font color="#ffa600"><em>// 500;</em></font>
<em>739: </em>    ReportInterval = 50; <font color="#ffa600"><em>// 50</em></font>
<em>740: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <strong>if</strong> (argc &lt; 9) <font color="red"><strong>{</strong></font>
<em>741: </em>    <font color="#ffa600"><em>// wrong number offered</em></font>
<em>742: </em>    mprintf(<font color="red">&quot;\nEAV: usage&quot;</font>);
<em>743: </em>    mprintf(<font color="red">&quot;\n\tNum Users [0..%ld]&quot;</font>, num_terminals);
<em>744: </em>    mprintf(<font color="red">&quot;\n\tDiskCache HitRate [0..1000]&quot;</font>);
<em>745: </em>    mprintf(<font color="red">&quot;\n\tProcessor speed in Mips&quot;</font>);
<em>746: </em>    mprintf(<font color="red">&quot;\n\tPer-Disk Command buffer size [0..]&quot;</font>);
<em>747: </em>    mprintf(<font color="red">&quot;\n\tNumber of Disks [0..%ld]&quot;</font>, num_drives);
<em>748: </em>    mprintf(<font color="red">&quot;\n\tNumber of TP daemons [1..]&quot;</font>);
<em>749: </em>    mprintf(<font color="red">&quot;\n\tMax Simulation Time in seconds [0..1500]&quot;</font>);
<em>750: </em>    mprintf(<font color="red">&quot;\n\tReporting interval in seconds [0..1500]&quot;</font>);
<em>751: </em>    mprintf(<font color="red">&quot;\nSimulation will halt almost immediately.\n\n&quot;</font>);
<em>752: </em>    pExit(1);
<em>753: </em>  <font color="red"><strong>}</strong></font> <strong>else</strong> <font color="red"><strong>{</strong></font>
<em>754: </em>    <font color="#ffa600"><em>// Init parms.</em></font>
<em>755: </em>    int i = 1;
<em>756: </em>    actual_users = atoi(argv[i++]);
<em>757: </em>    hit_rate = atoi(argv[i++]);
<em>758: </em>    mips = atoi(argv[i++]);
<em>759: </em>    buff_size = atoi(argv[i++]);
<em>760: </em>    disks = atoi(argv[i++]);
<em>761: </em>    tp_agents = atoi(argv[i++]);
<em>762: </em>    SimulationTime = atoi(argv[i++]);
<em>763: </em>    ReportInterval = atoi(argv[i++]);
<em>764: </em>  <font color="red"><strong>}</strong></font>
<em>765: </em>
<em>766: </em>  <strong>if</strong> (actual_users &gt; num_terminals) <font color="red"><strong>{</strong></font>
<em>767: </em>    actual_users = num_terminals;
<em>768: </em>  <font color="red"><strong>}</strong></font>
<em>769: </em>  
<em>770: </em>  mprintf(<font color="red">&quot;\n\tActual Number of users   = %ld&quot;</font>, actual_users);
<em>771: </em>  mprintf(<font color="red">&quot;\n\tUser Think time (msec)   = %ld&quot;</font>, ThinkTime);
<em>772: </em>  mprintf(<font color="red">&quot;\n\tNumber of TP Agents	= %ld&quot;</font>, tp_agents);
<em>773: </em>  mprintf(<font color="red">&quot;\n\tProcessor speed (mips) = %ld&quot;</font>, mips);
<em>774: </em>  mprintf(<font color="red">&quot;\n\tDisk Buffer Hit Rate     = &quot;</font>);
<em>775: </em>  printfixed(hit_rate, 10);
<em>776: </em>  mprintf(<font color="red">&quot; percent&quot;</font>);
<em>777: </em>  <strong>if</strong> (disks &gt; num_drives) <font color="red"><strong>{</strong></font>
<em>778: </em>    disks = num_drives;
<em>779: </em>  <font color="red"><strong>}</strong></font>
<em>780: </em>  mprintf(<font color="red">&quot;\n\tNumber of Disks      = %ld&quot;</font>, disks);
<em>781: </em>  mprintf(<font color="red">&quot;\n\tPer Disk Buffer size     = %ld commands&quot;</font>, buff_size);
<em>782: </em>  mprintf(<font color="red">&quot;\n\tSimulation will run for %ld simulated seconds&quot;</font>, SimulationTime);
<em>783: </em>  <strong>if</strong> (ReportInterval &lt;= 0) <font color="red"><strong>{</strong></font>
<em>784: </em>    ReportInterval = 1;
<em>785: </em>  <font color="red"><strong>}</strong></font>
<em>786: </em>  mprintf(<font color="red">&quot;\n\tProgress reports every %ld seconds\n&quot;</font>, ReportInterval);
<em>787: </em>  ReportInterval = ReportInterval * sec;
<em>788: </em>
<em>789: </em>  <font color="#ffa600"><em>// create the dynamically-sized interconnect</em></font>
<em>790: </em>  Chans 
<em>791: </em>    terms_to_comms(actual_users), 
<em>792: </em>    comms_to_terms(actual_users),
<em>793: </em>    comms_to_tp(tp_agents),
<em>794: </em>    tp_to_comms(tp_agents),
<em>795: </em>    free(tp_agents),
<em>796: </em>    tp_to_disks(tp_agents),
<em>797: </em>    disks_to_tp(tp_agents);
<em>798: </em>    
<em>799: </em>  par <font color="red"><strong>{</strong></font>
<em>800: </em>    par <font color="red"><strong>{</strong></font>
<em>801: </em>      on (mainframe) <font color="red"><strong>{</strong></font>
<em>802: </em>        comms_in(mips, terms_to_comms, comms_to_tp, free);
<em>803: </em>      <font color="red"><strong>}</strong></font>
<em>804: </em>      on (mainframe) <font color="red"><strong>{</strong></font>
<em>805: </em>        comms_out(mips, tp_to_comms, comms_to_terms);
<em>806: </em>      <font color="red"><strong>}</strong></font>
<em>807: </em>      on (mainframe) <font color="red"><strong>{</strong></font>
<em>808: </em>        DiskManager disk_manager;
<em>809: </em>        disk_manager(mips,buff_size,disks,tp_to_disks,disks_to_tp);
<em>810: </em>      <font color="red"><strong>}</strong></font>
<em>811: </em>      on (mainframe) <font color="red"><strong>{</strong></font>
<em>812: </em>        Agents agents;
<em>813: </em>        agents(mips, comms_to_tp, tp_to_comms, free, 
<em>814: </em>               tp_to_disks, disks_to_tp, tp_agents, hit_rate);
<em>815: </em>      <font color="red"><strong>}</strong></font>
<em>816: </em>      on (mainframe) <font color="red"><strong>{</strong></font>
<em>817: </em>        timestamp(ReportInterval, SimulationTime * sec, 
<em>818: </em>                  transactions, times);
<em>819: </em>      <font color="red"><strong>}</strong></font>
<em>820: </em>    <font color="red"><strong>}</strong></font>
<em>821: </em>    <font color="red"><strong>{</strong></font>
<em>822: </em>      pfor (int i = 0; i != actual_users; ++i) <font color="red"><strong>{</strong></font>
<em>823: </em>        on (terminals[i]) <font color="red"><strong>{</strong></font>
<em>824: </em>          user(comms_to_terms[i], terms_to_comms[i],
<em>825: </em>               i, SimulationTime * sec, transactions, times, 
<em>826: </em>               sigma_transac, sigma_response);
<em>827: </em>        <font color="red"><strong>}</strong></font>
<em>828: </em>      <font color="red"><strong>}</strong></font>
<em>829: </em>      
<em>830: </em>      say(<font color="red">&quot;\nThe users have all finished..\nTotal of &quot;</font>);
<em>831: </em>      saynum(transactions);
<em>832: </em>      say(<font color="red">&quot; in &quot;</font>);
<em>833: </em>      printfixed(pTime(), sec);
<em>834: </em>      say(<font color="red">&quot; seconds for a transaction rate of &quot;</font>);
<em>835: </em>      <font color="#ffa600"><em>//mprintfixed(transactions * sec, Now);</em></font>
<em>836: </em>      printfixed(transactions, pTime()/sec);
<em>837: </em>      say (<font color="red">&quot; tps\n&quot;</font>);
<em>838: </em>      pExit(0);
<em>839: </em>    <font color="red"><strong>}</strong></font>
<em>840: </em>  <font color="red"><strong>}</strong></font>
<em>841: </em>  <strong>return</strong> 0;
<em>842: </em><font color="red"><strong>}</strong></font>
</pre>
</td></tr>
</tbody></table></td></tr>
</tbody></table></div>
</div></td>
</tr></table><div class="skribe-ending">
<hr> 
<p class="ending"><font size="-1">
This <span class="sc">Html</span> page has been produced by 
<a href="http://www.inria.fr/mimosa/fp/Skribe" class="http">Skribe</a>.
<br/>
Last update <em>Thu Nov  9 13:38:18 2006</em>.</font></p></div>
</body>
</html>